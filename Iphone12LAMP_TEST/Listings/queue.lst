L 1 "Common\CMSIS-FreeRTOS\10.0.1\Source\queue.c"
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060037
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199901L) || (0L && 201103L <= __cplusplus)
N      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || 1
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 29 "Common\CMSIS-FreeRTOS\10.0.1\Source\queue.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060037
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 30 "Common\CMSIS-FreeRTOS\10.0.1\Source\queue.c" 2
N
N/* Defining MPU_WRAPPERS_INCLUDED_FROM_API_FILE prevents task.h from redefining
Nall the API functions to use the MPU wrappers.  That should only be done when
Ntask.h is included from an application file. */
N#define MPU_WRAPPERS_INCLUDED_FROM_API_FILE
N
N#include "FreeRTOS.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N#ifndef INC_FREERTOS_H
N#define INC_FREERTOS_H
N
N/*
N * Include the generic headers required for the FreeRTOS port being used.
N */
N#include <stddef.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stddef.h" 1
N/* stddef.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.1.4 */
N
N/* Copyright (C) ARM Ltd., 1999
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright 1991 ARM Limited. All rights reserved.             */
N/* version 0.05 */
N
N/*
N * The following types and macros are defined in several headers referred to in
N * the descriptions of the functions declared in that header. They are also
N * defined in this header file.
N */
N
N#ifndef __stddef_h
N#define __stddef_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __STDDEF_DECLS
N  #define __STDDEF_DECLS
N    #undef __CLIBNS
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS ::std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if __sizeof_ptr == 8
X#if 4 == 8
S  typedef signed long ptrdiff_t;
N#else
N  typedef signed int ptrdiff_t;
N#endif
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
S   /* the unsigned integral type of the result of the sizeof operator. */
N#endif
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N  /* unconditional in non-strict C for consistency of debug info */
N    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X    #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #else
N      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
N    #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S    #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S      typedef unsigned int wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #else
S      typedef unsigned short wchar_t; /* also in <stdlib.h> and <inttypes.h> */
S    #endif
S   /*
S    * An integral type whose range of values can represent distinct codes for
S    * all members of the largest extended character set specified among the
S    * supported locales; the null character shall have the code value zero and
S    * each member of the basic character set shall have a code value when used
S    * as the lone character in an integer character constant.
S    */
N  #endif
N#endif
N
N#undef NULL  /* others (e.g. <stdio.h>) also define */
N#define NULL 0
N   /* null pointer constant. */
N
N#ifdef __clang__
S  #define offsetof(t, d) __builtin_offsetof(t, d)
N#else
N  /* EDG uses __INTADDR__ to avoid errors when strict */
N  #define offsetof(t, memb) ((__CLIBNS size_t)__INTADDR__(&(((t *)0)->memb)))
N#endif
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 201112L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 201112L <= 199901L) || (0L && 201103L <= __cplusplus)
N  typedef long double max_align_t;
N#endif
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDDEF_DECLS */
N
N
N  #ifdef __cplusplus
S    #ifndef __STDDEF_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::ptrdiff_t;
S      #if !defined(__STRICT_ANSI__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S        using ::std::max_align_t;
S      #endif
S    #endif 
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of stddef.h */
N
L 35 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N
N/*
N * If stdint.h cannot be located then:
N *   + If using GCC ensure the -nostdint options is *not* being used.
N *   + Ensure the project's include path includes the directory in which your
N *     compiler stores stdint.h.
N *   + Set any compiler options necessary for it to support C99, as technically
N *     stdint.h is only mandatory with C99 (FreeRTOS does not require C99 in any
N *     other way).
N *   + The FreeRTOS download includes a simple stdint.h definition that can be
N *     used in cases where none is provided by the compiler.  The files only
N *     contains the typedefs required to build FreeRTOS.  Read the instructions
N *     in FreeRTOS/source/stdint.readme for more information.
N */
N#include <stdint.h> /* READ COMMENT ABOVE. */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060037
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 50 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Application specific configuration options. */
N#include "FreeRTOSConfig.h"
L 1 ".\Common\RTE\RTOS\FreeRTOSConfig.h" 1
N/* --------------------------------------------------------------------------
N * Copyright (c) 2013-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N * --------------------------------------------------------------------------
N *
N * $Revision:   V10.0.1
N *
N * Project:     CMSIS-FreeRTOS
N * Title:       FreeRTOS configuration definitions
N *
N * --------------------------------------------------------------------------*/
N
N
N#ifndef FREERTOS_CONFIG_H
N#define FREERTOS_CONFIG_H
N
N/*-----------------------------------------------------------
N * Application specific definitions.
N *
N * These definitions should be adjusted for your particular hardware and
N * application requirements.
N *
N * THESE PARAMETERS ARE DESCRIBED WITHIN THE 'CONFIGURATION' SECTION OF THE
N * FreeRTOS API DOCUMENTATION AVAILABLE ON THE FreeRTOS.org WEB SITE.
N *
N * See http://www.freertos.org/a00110.html.
N *----------------------------------------------------------*/
N
N#include <stdint.h>
N
N
N//#include "RTE_Components.h"
N//#include CMSIS_device_header
N
N//#include "os_tick.h"
N
N//-------- <<< Use Configuration Wizard in Context Menu >>> --------------------
N
N//  <o>Minimal stack size [words] <0-65535>
N//  <i> Stack for idle task and default task stack in words.
N//  <i> Default: 128
N#define configMINIMAL_STACK_SIZE                ((uint16_t)(128))
N
N//  <o>Total heap size [bytes] <0-0xFFFFFFFF>
N//  <i> Heap memory size in bytes.
N//  <i> Default: 8192
N#define configTOTAL_HEAP_SIZE                   ((size_t)2048)
N
N//  <o>Kernel tick frequency [Hz] <0-0xFFFFFFFF>
N//  <i> Kernel tick rate in Hz.
N//  <i> Default: 1000
N#define configTICK_RATE_HZ                      ((TickType_t)1000)
N
N//  <o>Timer task stack depth [words] <0-65535>
N//  <i> Stack for timer task in words.
N//  <i> Default: 80
N#define configTIMER_TASK_STACK_DEPTH            80
N
N//  <o>Timer task priority <0-56>
N//  <i> Timer task priority.
N//  <i> Default: 40 (High)
N#define configTIMER_TASK_PRIORITY               6
N
N//  <o>Timer queue length <0-1024>
N//  <i> Timer command queue length.
N//  <i> Default: 5
N#define configTIMER_QUEUE_LENGTH                5
N
N//  <o>Preemption interrupt priority
N//  <i> Maximum priority of interrupts that are safe to call FreeRTOS API.
N//  <i> Default: 16
N#define configMAX_SYSCALL_INTERRUPT_PRIORITY    3
N
N//  <q>Use time slicing
N//  <i> Enable setting to use timeslicing.
N//  <i> Default: 1
N#define configUSE_TIME_SLICING                  1
N
N//  <q>Idle should yield
N//  <i> Control Yield behaviour of the idle task.
N//  <i> Default: 1
N#define configIDLE_SHOULD_YIELD                 1
N
N//  <o>Check for stack overflow
N//    <0=>Disable <1=>Method one <2=>Method two
N//  <i> Enable or disable stack overflow checking.
N//  <i> Callback function vApplicationStackOverflowHook implementation is required when stack checking is enabled.
N//  <i> Default: 0
N#define configCHECK_FOR_STACK_OVERFLOW          0
N
N//  <q>Use idle hook
N//  <i> Enable callback function call on each idle task iteration.
N//  <i> Callback function vApplicationIdleHook implementation is required when idle hook is enabled.
N//  <i> Default: 0
N#define configUSE_IDLE_HOOK                     1
N
N//  <q>Use tick hook
N//  <i> Enable callback function call during each tick interrupt.
N//  <i> Callback function vApplicationTickHook implementation is required when tick hook is enabled.
N//  <i> Default: 0
N#define configUSE_TICK_HOOK                     0
N
N//  <q>Use deamon task startup hook
N//  <i> Enable callback function call when timer service starts.
N//  <i> Callback function vApplicationDaemonTaskStartupHook implementation is required when deamon task startup hook is enabled.
N//  <i> Default: 0
N#define configUSE_DAEMON_TASK_STARTUP_HOOK      0
N
N//  <q>Use malloc failed hook
N//  <i> Enable callback function call when out of dynamic memory.
N//  <i> Callback function vApplicationMallocFailedHook implementation is required when malloc failed hook is enabled.
N//  <i> Default: 0
N#define configUSE_MALLOC_FAILED_HOOK            0
N
N//  <o>Queue registry size
N//  <i> Define maximum number of queue objects registered for debug purposes.
N//  <i> The queue registry is used by kernel aware debuggers to locate queue and semaphore structures and display associated text names.
N//  <i> Default: 0
N#define configQUEUE_REGISTRY_SIZE               0
N
N#define configAPPLICATION_ALLOCATED_HEAP				1
N
N//------------- <<< end of configuration section >>> ---------------------------
N
N/* Defines needed by FreeRTOS to implement CMSIS RTOS2 API. Do not change! */
N#define configCPU_CLOCK_HZ                      9000000ul
N#define configSUPPORT_STATIC_ALLOCATION         1
N#define configSUPPORT_DYNAMIC_ALLOCATION        1
N#define configUSE_PREEMPTION                    1
N#define configUSE_TIMERS                        0
N#define configUSE_MUTEXES                       1
N#define configUSE_RECURSIVE_MUTEXES             0
N#define configUSE_COUNTING_SEMAPHORES           1
N#define configUSE_TASK_NOTIFICATIONS            1
N#define configUSE_TRACE_FACILITY                0
N#define configUSE_16_BIT_TICKS                  0
N#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#define configMAX_PRIORITIES                    12
N#define configKERNEL_INTERRUPT_PRIORITY         3
N
N/* Defines that include FreeRTOS functions which implement CMSIS RTOS2 API. Do not change! */
N#define INCLUDE_xEventGroupSetBitsFromISR       1
N#define INCLUDE_xSemaphoreGetMutexHolder        1
N#define INCLUDE_vTaskDelay                      1
N#define INCLUDE_vTaskDelayUntil                 1
N#define INCLUDE_vTaskDelete                     1
N#define INCLUDE_xTaskGetCurrentTaskHandle       1
N#define INCLUDE_xTaskGetSchedulerState          1
N#define INCLUDE_uxTaskGetStackHighWaterMark     1
N#define INCLUDE_uxTaskPriorityGet               1
N#define INCLUDE_vTaskPrioritySet                1
N#define INCLUDE_eTaskGetState                   1
N#define INCLUDE_vTaskSuspend                    1
N#define INCLUDE_xTimerPendFunctionCall          0
N
N/* Map the FreeRTOS port interrupt handlers to their CMSIS standard names. */
N#define xPortPendSVHandler                    PendSV_Handler
N#define vPortSVCHandler                       SVC_Handler
N
N/* Include debug event definitions */
N#include "freertos_evr.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\CMSIS\RTOS2\FreeRTOS\Include\freertos_evr.h" 1
N/* --------------------------------------------------------------------------
N * Copyright (c) 2013-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N *
N *      Name:    freertos_evr.h
N *      Purpose: FreeRTOS Event Recorder definitions
N *
N *---------------------------------------------------------------------------*/
N
N#ifndef FREERTOS_EVR_H_
N#define FREERTOS_EVR_H_
N
N#include <string.h>
N#include <stdint.h>
N
N#include "RTE_Components.h"
L 1 ".\RTE\_soc_m0\RTE_Components.h" 1
N
N/*
N * Auto generated Run-Time-Environment Configuration File
N *      *** Do not modify ! ***
N *
N * Project: 'M0_SOC' 
N * Target:  'soc_m0' 
N */
N
N#ifndef RTE_COMPONENTS_H
N#define RTE_COMPONENTS_H
N
N
N/*
N * Define the Device Header File: 
N */
N#define CMSIS_device_header "ARMCM0.h"
N
N
N
N#endif /* RTE_COMPONENTS_H */
L 30 ".\Common\CMSIS-FreeRTOS\10.0.1\CMSIS\RTOS2\FreeRTOS\Include\freertos_evr.h" 2
N
N#if !defined(RTE_Compiler_EventRecorder)
X#if !0L
N  /* Disable debug events if Event Recorder is not used */
N  #ifndef EVR_FREERTOS_DISABLE
N    #define EVR_FREERTOS_DISABLE
N  #endif
N#endif
N
N/* Temporarily define FreeRTOS object types */
N#define TCB_t            void*
N#define Queue_t          void*
N#define Timer_t          void*
N#define PendedFunction_t void*
N#define EventGroup_t     void*
N#define StreamBuffer_t   void*
N
N/**
N  \brief  Event on successful task create (Op)
N  \param[in]  pxNewTCB          pointer to task handle.
N*/
Nextern void EvrFreeRTOSTasks_TaskCreate (TCB_t pxNewTCB);
Xextern void EvrFreeRTOSTasks_TaskCreate (void* pxNewTCB);
N
N/**
N  \brief  Event on unsuccessful task create (Error)
N*/
Nextern void EvrFreeRTOSTasks_TaskCreateFailed (void);
N
N/**
N  \brief  Event on task delete (Op)
N  \param[in]  pxTCB             pointer to task handle.
N*/
Nextern void EvrFreeRTOSTasks_TaskDelete (TCB_t pxTCB);
Xextern void EvrFreeRTOSTasks_TaskDelete (void* pxTCB);
N
N/**
N  \brief  Event before current running task execution is delayed (Op)
N  \param[in]  xTimeToWake       wake time (ticks).
N*/
Nextern void EvrFreeRTOSTasks_TaskDelayUntil (uint32_t xTimeToWake);
N
N/**
N  \brief  Event on current thread execution delay (Op)
N  \param[in]  xTicksToDelay     number of ticks to delay.
N*/
Nextern void EvrFreeRTOSTasks_TaskDelay (uint32_t xTicksToDelay);
N
N/**
N  \brief  Event on task priority set (Op)
N  \param[in]  pxTCB             pointer to task handle.
N  \param[in]  uxNewPriority
N*/
Nextern void EvrFreeRTOSTasks_TaskPrioritySet (TCB_t pxTCB, uint32_t uxNewPriority);
Xextern void EvrFreeRTOSTasks_TaskPrioritySet (void* pxTCB, uint32_t uxNewPriority);
N
N/**
N  \brief  Event on task suspend (Op)
N  \param[in]  pxTCB             pointer to task handle.
N*/
Nextern void EvrFreeRTOSTasks_TaskSuspend (TCB_t pxTCB);
Xextern void EvrFreeRTOSTasks_TaskSuspend (void* pxTCB);
N
N/**
N  \brief  Event on task resume (Op)
N  \param[in]  pxTCB             pointer to task handle.
N*/
Nextern void EvrFreeRTOSTasks_TaskResume (TCB_t pxTCB);
Xextern void EvrFreeRTOSTasks_TaskResume (void* pxTCB);
N
N/**
N  \brief  Event on task resume call from ISR (Op)
N  \param[in]  pxTCB             pointer to task handle.
N*/
Nextern void EvrFreeRTOSTasks_TaskResumeFromIsr (TCB_t pxTCB);
Xextern void EvrFreeRTOSTasks_TaskResumeFromIsr (void* pxTCB);
N
N/**
N  \brief  Event on tick count increment (Detail)
N  \param[in]  xTickCount        tick count before increment.
N*/
Nextern void EvrFreeRTOSTasks_TaskIncrementTick (uint32_t xTickCount);
N
N/**
N  \brief  Event on tick count increase (Op)
N  \param[in]  xTicksToJump      number of ticks by which the tick count is increased.
N*/
Nextern void EvrFreeRTOSTasks_IncreaseTickCount (uint32_t xTicksToJump);
N
N/**
N  \brief  Event before a new task is selected to run (Op)
N  \param[in]  pxCurrentTCB      handle to the task about to leave the running state.
N*/
Nextern void EvrFreeRTOSTasks_TaskSwitchedOut (TCB_t pxCurrentTCB);
Xextern void EvrFreeRTOSTasks_TaskSwitchedOut (void* pxCurrentTCB);
N
N/**
N  \brief  Event after a task has been selected to run (Op)
N  \param[in]  pxCurrentTCB      handle to the task about to enter the running state.
N  \param[in]  uxTopPriority     pxCurrentTCB task priority.
N*/
Nextern void EvrFreeRTOSTasks_TaskSwitchedIn  (TCB_t pxCurrentTCB, uint32_t uxTopPriority);
Xextern void EvrFreeRTOSTasks_TaskSwitchedIn  (void* pxCurrentTCB, uint32_t uxTopPriority);
N
N/**
N  \brief  Event on task priority inheritance (Op)
N  \param[in]  pxTCBOfMutexHolder  pointer to task handle.
N  \param[in]  uxInheritedPriority new (inherited) task priority.
N*/
Nextern void EvrFreeRTOSTasks_TaskPriorityInherit (TCB_t pxTCBOfMutexHolder, uint32_t uxInheritedPriority);
Xextern void EvrFreeRTOSTasks_TaskPriorityInherit (void* pxTCBOfMutexHolder, uint32_t uxInheritedPriority);
N
N/**
N  \brief  Event on task priority disinheritance (Op)
N  \param[in]  pxTCBOfMutexHolder  pointer to task handle.
N  \param[in]  uxOriginalPriority  old (original) task priority.
N*/
Nextern void EvrFreeRTOSTasks_TaskPriorityDisinherit (TCB_t pxTCBOfMutexHolder, uint32_t uxOriginalPriority);
Xextern void EvrFreeRTOSTasks_TaskPriorityDisinherit (void* pxTCBOfMutexHolder, uint32_t uxOriginalPriority);
N
N/**
N  \brief  Event sent before transition of a task into the Ready state (Op)
N  \param[in]  pxTCB             pointer to task handle.
N*/
Nextern void EvrFreeRTOSTasks_MovedTaskToReadyState (TCB_t pxTCB);
Xextern void EvrFreeRTOSTasks_MovedTaskToReadyState (void* pxTCB);
N
N/**
N  \brief  Event sent after transition of a task into the Ready state (Op)
N  \param[in]  pxTCB             pointer to task handle.
N*/
Nextern void EvrFreeRTOSTasks_PostMovedTaskToReadyState (TCB_t pxTCB);
Xextern void EvrFreeRTOSTasks_PostMovedTaskToReadyState (void* pxTCB);
N
N/**
N  \brief  Event on enter to the low power mode (Op)
N  \param[in]  xExpectedIdleTime expected idle time in ticks.
N*/
Nextern void EvrFreeRTOSTasks_LowPowerIdleBegin (uint32_t xExpectedIdleTime);
N
N/**
N  \brief  Event on exit from the low power mode (Op)
N*/
Nextern void EvrFreeRTOSTasks_LowPowerIdleEnd (void);
N
N/**
N  \brief  Event on indicating the current running task is about to block while waiting for notification to be non-zero (Op)
N  \param[in]  xTicksToWait      wait timeout in ticks.
N*/
Nextern void EvrFreeRTOSTasks_TaskNotifyTakeBlock (uint32_t xTicksToWait);
N
N/**
N  \brief  Event on successful task notify take (Op)
N  \param[in]  ulNotifiedValue   current state of the notification value.
N*/
Nextern void EvrFreeRTOSTasks_TaskNotifyTake (uint32_t ulNotifiedValue);
N
N/**
N  \brief  Event indicating the current running task is about to block while waiting to receive notification (Op)
N  \param[in]  xTicksToWait      wait timeout in ticks.
N*/
Nextern void EvrFreeRTOSTasks_TaskNotifyWaitBlock (uint32_t xTicksToWait);
N
N/**
N  \brief  Event on successful task notify wait (Op)
N  \param[in]  ulNotifiedValue   current state of the notification value.
N*/
Nextern void EvrFreeRTOSTasks_TaskNotifyWait (uint32_t ulNotifiedValue);
N
N/**
N  \brief  Event on successful task notify (Op)
N  \param[in]  xTaskToNotify     pointer to task to be notified.
N  \param[in]  ulValue           notify value.
N  \param[in]  eAction           task notification action.
N  \param[in]  ulNotifiedValue   current state of the notification value.
N*/
Nextern void EvrFreeRTOSTasks_TaskNotify (TCB_t xTaskToNotify, uint32_t ulValue, uint32_t eAction, uint32_t ulNotifiedValue);
Xextern void EvrFreeRTOSTasks_TaskNotify (void* xTaskToNotify, uint32_t ulValue, uint32_t eAction, uint32_t ulNotifiedValue);
N
N/**
N  \brief  Event on successful task notify from ISR (Op)
N  \param[in]  xTaskToNotify     pointer to task to be notified.
N  \param[in]  ulValue           notify value.
N  \param[in]  eAction           task notification action.
N  \param[in]  ulNotifiedValue   current state of the notification value.
N*/
Nextern void EvrFreeRTOSTasks_TaskNotifyFromIsr (TCB_t xTaskToNotify, uint32_t ulValue, uint32_t eAction, uint32_t ulNotifiedValue);
Xextern void EvrFreeRTOSTasks_TaskNotifyFromIsr (void* xTaskToNotify, uint32_t ulValue, uint32_t eAction, uint32_t ulNotifiedValue);
N
N/**
N  \brief  Event on successful task notify give from ISR (Op)
N  \param[in]  xTaskToNotify     pointer to task to be notified.
N  \param[in]  ulNotifiedValue   current state of the notification value.
N*/
Nextern void EvrFreeRTOSTasks_TaskNotifyGiveFromIsr (TCB_t xTaskToNotify, uint32_t ulNotifiedValue);
Xextern void EvrFreeRTOSTasks_TaskNotifyGiveFromIsr (void* xTaskToNotify, uint32_t ulNotifiedValue);
N
N/**
N  \brief  Event on successful queue create (Op)
N  \param[in]  pxQueue           pointer to mutex object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueCreate (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueCreate (void* pxQueue);
N
N/**
N  \brief  Event on unsuccessful queue create (Error)
N  \param[in]  ucQueueType       queue type
N*/
Nextern void EvrFreeRTOSQueue_QueueCreateFailed (uint32_t ucQueueType);
N
N/**
N  \brief  Event on successful mutex create (Op)
N  \param[in]  pxNewQueue        pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_CreateMutex (Queue_t pxNewQueue);
Xextern void EvrFreeRTOSQueue_CreateMutex (void* pxNewQueue);
N
N/**
N  \brief  Event on unsuccessful mutex create (Error)
N*/
Nextern void EvrFreeRTOSQueue_CreateMutexFailed (void);
N
N/**
N  \brief  Event on successful recursive mutex give (Op)
N  \param[in]  pxMutex           pointer to mutex object handle.
N*/
Nextern void EvrFreeRTOSQueue_GiveMutexRecursive (Queue_t pxMutex);
Xextern void EvrFreeRTOSQueue_GiveMutexRecursive (void* pxMutex);
N
N/**
N  \brief  Event on unsuccessful recursive mutex give (Error)
N  \param[in]  pxMutex           pointer to mutex object handle.
N*/
Nextern void EvrFreeRTOSQueue_GiveMutexRecursiveFailed (Queue_t pxMutex);
Xextern void EvrFreeRTOSQueue_GiveMutexRecursiveFailed (void* pxMutex);
N
N/**
N  \brief  Event on successful recursive mutex take (Op)
N  \param[in]  pxMutex           pointer to mutex object handle.
N*/
Nextern void EvrFreeRTOSQueue_TakeMutexRecursive (Queue_t pxMutex);
Xextern void EvrFreeRTOSQueue_TakeMutexRecursive (void* pxMutex);
N
N/**
N  \brief  Event on unsuccessful recursive mutex take (Error)
N  \param[in]  pxMutex           pointer to mutex object handle.
N*/
Nextern void EvrFreeRTOSQueue_TakeMutexRecursiveFailed (Queue_t pxMutex);
Xextern void EvrFreeRTOSQueue_TakeMutexRecursiveFailed (void* pxMutex);
N
N/**
N  \brief  Event on successful counting semaphore create (Op)
N  \param[in]  xHandle           pointer to semaphore object handle.
N*/
Nextern void EvrFreeRTOSQueue_CreateCountingSemaphore (Queue_t xHandle);
Xextern void EvrFreeRTOSQueue_CreateCountingSemaphore (void* xHandle);
N
N/**
N  \brief  Event on unsuccessful counting semaphore create (Error)
N*/
Nextern void EvrFreeRTOSQueue_CreateCountingSemaphoreFailed (void);
N
N/**
N  \brief  Event on queue write (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueSend (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueSend (void* pxQueue);
N
N/**
N  \brief  Event on write to the full queue (Error)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueSendFailed (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueSendFailed (void* pxQueue);
N
N/**
N  \brief  Event on queue read (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueReceive (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueReceive (void* pxQueue);
N
N/**
N  \brief  Event on queue peek (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueuePeek (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueuePeek (void* pxQueue);
N
N/**
N  \brief  Event on queue peek when queue is empty and no block time was specified (Error)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueuePeekFailed (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueuePeekFailed (void* pxQueue);
N
N/**
N  \brief  Event on queue peek from ISR (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueuePeekFromIsr (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueuePeekFromIsr (void* pxQueue);
N
N/**
N  \brief  Event on read from the empty queue (Error)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueReceiveFailed (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueReceiveFailed (void* pxQueue);
N
N/**
N  \brief  Event on write to the queue from ISR (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueSendFromIsr (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueSendFromIsr (void* pxQueue);
N
N/**
N  \brief  Event on write to the full queue from ISR (Error)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueSendFromIsrFailed (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueSendFromIsrFailed (void* pxQueue);
N
N/**
N  \brief  Event on queue read from ISR (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueReceiveFromIsr (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueReceiveFromIsr (void* pxQueue);
N
N/**
N  \brief  Event on empty queue read from ISR (Error)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueReceiveFromIsrFailed (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueReceiveFromIsrFailed (void* pxQueue);
N
N/**
N  \brief  Event on empty queue peek from ISR (Error)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueuePeekFromIsrFailed (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueuePeekFromIsrFailed (void* pxQueue);
N
N/**
N  \brief  Event on queue delete (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_QueueDelete (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_QueueDelete (void* pxQueue);
N
N/**
N  \brief  Event on assignment of a human readable name to a queue (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N  \param[in]  pcQueueName       pointer to queue object name.
N*/
Nextern void EvrFreeRTOSQueue_QueueRegistryAdd (Queue_t pxQueue, const char *pcQueueName);
Xextern void EvrFreeRTOSQueue_QueueRegistryAdd (void* pxQueue, const char *pcQueueName);
N
N/**
N  \brief  Event indicating the current running task is about to block while reading from an empty queue (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_BlockingOnQueueReceive (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_BlockingOnQueueReceive (void* pxQueue);
N
N/**
N  \brief  Event indicating the current running task is about to block while writting to a full queue (Op)
N  \param[in]  pxQueue           pointer to queue object handle.
N*/
Nextern void EvrFreeRTOSQueue_BlockingOnQueueSend (Queue_t pxQueue);
Xextern void EvrFreeRTOSQueue_BlockingOnQueueSend (void* pxQueue);
N
N/**
N  \brief  Event on successful timer object create (Op)
N  \param[in]  pxNewTimer        pointer to timer object handle.
N*/
Nextern void EvrFreeRTOSTimers_TimerCreate (Timer_t pxNewTimer);
Xextern void EvrFreeRTOSTimers_TimerCreate (void* pxNewTimer);
N
N/**
N  \brief  Event on unsuccessful timer object create (Error)
N*/
Nextern void EvrFreeRTOSTimers_TimerCreateFailed (void);
N
N/**
N  \brief  Event on timer queue command send (Op)
N  \param[in]  pxTimer           pointer to timer object handle.
N  \param[in]  xCommandID        timer command ID.
N  \param[in]  xOptionalValue    optional command value.
N  \param[in]  xReturn           return value.
N*/
Nextern void EvrFreeRTOSTimers_TimerCommandSend (Timer_t pxTimer, uint32_t xCommandID, uint32_t xOptionalValue, uint32_t xReturn);
Xextern void EvrFreeRTOSTimers_TimerCommandSend (void* pxTimer, uint32_t xCommandID, uint32_t xOptionalValue, uint32_t xReturn);
N
N/**
N  \brief  Event on timer queue command receive (Op)
N  \param[in]  pxTimer           pointer to timer object handle.
N  \param[in]  xCommandID        timer command ID.
N  \param[in]  xOptionalValue    optional command value.
N*/
Nextern void EvrFreeRTOSTimers_TimerCommandReceived (Timer_t pxTimer, uint32_t xCommandID, uint32_t xOptionalValue);
Xextern void EvrFreeRTOSTimers_TimerCommandReceived (void* pxTimer, uint32_t xCommandID, uint32_t xOptionalValue);
N
N/**
N  \brief  Event on timer expire (Op)
N  \param[in]  pxTimer           pointer to timer object handle.
N*/
Nextern void EvrFreeRTOSTimers_TimerExpired (Timer_t pxTimer);
Xextern void EvrFreeRTOSTimers_TimerExpired (void* pxTimer);
N
N/**
N  \brief  Event on pass of the function execution to the timer service task (Op)
N  \param[in]  pxFunctionToPend  pointer to callback function
N  \param[in]  pvParameter1      function parameter 1.
N  \param[in]  ulParameter2      function parameter 2.
N  \param[in]  xReturn           return value.
N*/
Nextern void EvrFreeRTOSTimers_PendFuncCall (PendedFunction_t pxFunctionToPend, void *pvParameter1, uint32_t ulParameter2, uint32_t xReturn);
Xextern void EvrFreeRTOSTimers_PendFuncCall (void* pxFunctionToPend, void *pvParameter1, uint32_t ulParameter2, uint32_t xReturn);
N
N/**
N  \brief  Event on pass of the function execution to the timer service task from the ISR (Op)
N  \param[in]  pxFunctionToPend  pointer to callback function
N  \param[in]  pvParameter1      function parameter 1.
N  \param[in]  ulParameter2      function parameter 2.
N  \param[in]  xReturn           return value.
N*/
Nextern void EvrFreeRTOSTimers_PendFuncCallFromIsr (PendedFunction_t pxFunctionToPend, void *pvParameter1, uint32_t ulParameter2, uint32_t xReturn);
Xextern void EvrFreeRTOSTimers_PendFuncCallFromIsr (void* pxFunctionToPend, void *pvParameter1, uint32_t ulParameter2, uint32_t xReturn);
N
N/**
N  \brief  Event on successful event groups object create (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupCreate (EventGroup_t pxEventGroup);
Xextern void EvrFreeRTOSEventGroups_EventGroupCreate (void* pxEventGroup);
N
N/**
N  \brief  Event on unsuccessful event groups object create (Error)
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupCreateFailed (void);
N
N/**
N  \brief  Event on event groups sync wait start (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N  \param[in]  uxBitsToSet       event bits that shall be set.
N  \param[in]  uxBitsToWaitFor   event bits to wait for.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupSyncBlock (EventGroup_t pxEventGroup, uint32_t uxBitsToSet, uint32_t uxBitsToWaitFor);
Xextern void EvrFreeRTOSEventGroups_EventGroupSyncBlock (void* pxEventGroup, uint32_t uxBitsToSet, uint32_t uxBitsToWaitFor);
N
N/**
N  \brief  Event on event groups sync completed (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N  \param[in]  uxBitsToSet       event bits that shall be set.
N  \param[in]  uxBitsToWaitFor   event bits to wait for.
N  \param[in]  xTimeoutOccurred  timeout value.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupSyncEnd (EventGroup_t pxEventGroup, uint32_t uxBitsToSet, uint32_t uxBitsToWaitFor, uint32_t xTimeoutOccurred);
Xextern void EvrFreeRTOSEventGroups_EventGroupSyncEnd (void* pxEventGroup, uint32_t uxBitsToSet, uint32_t uxBitsToWaitFor, uint32_t xTimeoutOccurred);
N
N/**
N  \brief  Event on event groups bit wait start (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N  \param[in]  uxBitsToWaitFor   event bits to wait for.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupWaitBitsBlock (EventGroup_t pxEventGroup, uint32_t uxBitsToWaitFor);
Xextern void EvrFreeRTOSEventGroups_EventGroupWaitBitsBlock (void* pxEventGroup, uint32_t uxBitsToWaitFor);
N
N/**
N  \brief  Event on event groups bit wait completed (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N  \param[in]  uxBitsToWaitFor   event bits to wait for.
N  \param[in]  xTimeoutOccurred  timeout value.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupWaitBitsEnd (EventGroup_t pxEventGroup, uint32_t uxBitsToWaitFor, uint32_t xTimeoutOccurred);
Xextern void EvrFreeRTOSEventGroups_EventGroupWaitBitsEnd (void* pxEventGroup, uint32_t uxBitsToWaitFor, uint32_t xTimeoutOccurred);
N
N/**
N  \brief  Event on event groups bit clear (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N  \param[in]  uxBitsToClear     event bits that shall be cleared.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupClearBits (EventGroup_t pxEventGroup, uint32_t uxBitsToClear);
Xextern void EvrFreeRTOSEventGroups_EventGroupClearBits (void* pxEventGroup, uint32_t uxBitsToClear);
N
N/**
N  \brief  Event on event groups bit clear call from ISR (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N  \param[in]  uxBitsToClear     event bits that shall be cleared.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupClearBitsFromIsr (EventGroup_t pxEventGroup, uint32_t uxBitsToClear);
Xextern void EvrFreeRTOSEventGroups_EventGroupClearBitsFromIsr (void* pxEventGroup, uint32_t uxBitsToClear);
N
N/**
N  \brief  Event on event groups bit set (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N  \param[in]  uxBitsToSet       event bits that shall be set.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupSetBits (EventGroup_t pxEventGroup, uint32_t uxBitsToSet);
Xextern void EvrFreeRTOSEventGroups_EventGroupSetBits (void* pxEventGroup, uint32_t uxBitsToSet);
N
N/**
N  \brief  Event on event groups bit set call from ISR (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N  \param[in]  uxBitsToSet       event bits that shall be set.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupSetBitsFromIsr (EventGroup_t pxEventGroup, uint32_t uxBitsToSet);
Xextern void EvrFreeRTOSEventGroups_EventGroupSetBitsFromIsr (void* pxEventGroup, uint32_t uxBitsToSet);
N
N/**
N  \brief  Event on event groups object delete (Op)
N  \param[in]  pxEventGroup      pointer to Event Groups object handle.
N*/
Nextern void EvrFreeRTOSEventGroups_EventGroupDelete (EventGroup_t pxEventGroup);
Xextern void EvrFreeRTOSEventGroups_EventGroupDelete (void* pxEventGroup);
N
N/**
N  \brief  Event on unsuccessful stream buffer object create (Error)
N  \param[in]  uxIsMessageBuffer buffer type designator (0:stream, 1:message).
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferCreateFailed (uint32_t uxIsMessageBuffer);
N
N/**
N  \brief  Event on unsuccessful stream buffer object create (Error)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N  \param[in]  uxIsMessageBuffer buffer type designator (0:stream, 1:message).
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferCreateStaticFailed (StreamBuffer_t pxStreamBuffer, uint32_t uxIsMessageBuffer);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferCreateStaticFailed (void* pxStreamBuffer, uint32_t uxIsMessageBuffer);
N
N/**
N  \brief  Event on successful stream buffer object create (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N  \param[in]  uxIsMessageBuffer buffer type designator (0:stream, 1:message).
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferCreate (StreamBuffer_t pxStreamBuffer, uint32_t uxIsMessageBuffer);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferCreate (void* pxStreamBuffer, uint32_t uxIsMessageBuffer);
N
N/**
N  \brief  Event on stream buffer object delete (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferDelete (StreamBuffer_t pxStreamBuffer);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferDelete (void* pxStreamBuffer);
N
N/**
N  \brief  Event on stream buffer object reset (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferReset (StreamBuffer_t pxStreamBuffer);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferReset (void* pxStreamBuffer);
N
N/**
N  \brief  Event on stream buffer send when buffer is full and sending task is blocked (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferBlockingOnSend (StreamBuffer_t pxStreamBuffer);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferBlockingOnSend (void* pxStreamBuffer);
N
N/**
N  \brief  Event on stream buffer send when data is successfully copied into the buffer (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N  \param[in]  xBytesSent        number of bytes copied into the buffer
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferSend (StreamBuffer_t pxStreamBuffer, uint32_t xBytesSent);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferSend (void* pxStreamBuffer, uint32_t xBytesSent);
N
N/**
N  \brief  Event on stream buffer send when data is not copied into the buffer (Error)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferSendFailed (StreamBuffer_t pxStreamBuffer);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferSendFailed (void* pxStreamBuffer);
N
N/**
N  \brief  Event on stream buffer send from ISR when data is successfully copied into the buffer (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N  \param[in]  xBytesSent        number of bytes copied into the buffer
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferSendFromIsr (StreamBuffer_t pxStreamBuffer, uint32_t xBytesSent);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferSendFromIsr (void* pxStreamBuffer, uint32_t xBytesSent);
N
N/**
N  \brief  Event on stream buffer receive when buffer is empty and receiving task is blocked (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferBlockingOnReceive (StreamBuffer_t pxStreamBuffer);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferBlockingOnReceive (void* pxStreamBuffer);
N
N/**
N  \brief  Event on stream buffer receive when data is successfully copied from the buffer (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N  \param[in]  xReceivedLength   number of bytes copied from the buffer
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferReceive (StreamBuffer_t pxStreamBuffer, uint32_t xReceivedLength);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferReceive (void* pxStreamBuffer, uint32_t xReceivedLength);
N
N/**
N  \brief  Event on stream buffer receive when data is not copied from the buffer (Error)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferReceiveFailed (StreamBuffer_t pxStreamBuffer);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferReceiveFailed (void* pxStreamBuffer);
N
N/**
N  \brief  Event on stream buffer receive from ISR when data is successfully copied from the buffer (Op)
N  \param[in]  pxStreamBuffer    pointer to Stream Buffer object handle.
N  \param[in]  xReceivedLength   number of bytes copied from the buffer
N*/
Nextern void EvrFreeRTOSStreamBuf_StreamBufferReceiveFromIsr (StreamBuffer_t pxStreamBuffer, uint32_t xReceivedLength);
Xextern void EvrFreeRTOSStreamBuf_StreamBufferReceiveFromIsr (void* pxStreamBuffer, uint32_t xReceivedLength);
N
N/**
N  \brief  Event on heap memory block allocation (Op)
N  \param[in]  pvAddress         pointer to memory block.
N  \param[in]  uiSize            memory block size.
N*/
Nextern void EvrFreeRTOSHeap_Malloc (void *pvAddress, uint32_t uiSize);
N
N/**
N  \brief  Event on heap memory block free (Op)
N  \param[in]  pvAddress         pointer to memory block.
N  \param[in]  uiSize            memory block size.
N*/
Nextern void EvrFreeRTOSHeap_Free (void *pvAddress, uint32_t uiSize);
N
N
N/* Tasks */
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_CREATE_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_CREATE(px)                        EvrFreeRTOSTasks_TaskCreate(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_CREATE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_CREATE_FAILED()                   EvrFreeRTOSTasks_TaskCreateFailed()
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_DELETE_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_DELETE(px)                        EvrFreeRTOSTasks_TaskDelete(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_DELAY_UNTIL_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_DELAY_UNTIL(x)                    EvrFreeRTOSTasks_TaskDelayUntil(x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_DELAY_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_DELAY()                           EvrFreeRTOSTasks_TaskDelay(xTicksToDelay)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_PRIORITY_SET_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_PRIORITY_SET(px,ux)               EvrFreeRTOSTasks_TaskPrioritySet(px,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_SUSPEND_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_SUSPEND(px)                       EvrFreeRTOSTasks_TaskSuspend(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_RESUME_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_RESUME(px)                        EvrFreeRTOSTasks_TaskResume(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_RESUME_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_RESUME_FROM_ISR(px)               EvrFreeRTOSTasks_TaskResumeFromIsr(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_INCREMENT_TICK_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_INCREMENT_TICK(x)                 EvrFreeRTOSTasks_TaskIncrementTick(x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceINCREASE_TICK_COUNT_DISABLE))
X#if (!1L && !0L)
S  #define traceINCREASE_TICK_COUNT(x)                 EvrFreeRTOSTasks_IncreaseTickCount(x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_SWITCHED_OUT_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_SWITCHED_OUT()                    EvrFreeRTOSTasks_TaskSwitchedOut(pxCurrentTCB)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_SWITCHED_IN_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_SWITCHED_IN()                     EvrFreeRTOSTasks_TaskSwitchedIn(pxCurrentTCB, uxTopReadyPriority)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_PRIORITY_INHERIT_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_PRIORITY_INHERIT(px,ux)           EvrFreeRTOSTasks_TaskPriorityInherit(px,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_PRIORITY_DISINHERIT_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_PRIORITY_DISINHERIT(px,ux)        EvrFreeRTOSTasks_TaskPriorityDisinherit(px,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceMOVED_TASK_TO_READY_STATE_DISABLE))
X#if (!1L && !0L)
S  #define traceMOVED_TASK_TO_READY_STATE(px)          EvrFreeRTOSTasks_MovedTaskToReadyState(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(tracePOST_MOVED_TASK_TO_READY_STATE_DISABLE))
X#if (!1L && !0L)
S  #define tracePOST_MOVED_TASK_TO_READY_STATE(px)     EvrFreeRTOSTasks_PostMovedTaskToReadyState(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceLOW_POWER_IDLE_BEGIN_DISABLE))
X#if (!1L && !0L)
S  #define traceLOW_POWER_IDLE_BEGIN()                 EvrFreeRTOSTasks_LowPowerIdleBegin(xExpectedIdleTime)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceLOW_POWER_IDLE_END_DISABLE))
X#if (!1L && !0L)
S  #define traceLOW_POWER_IDLE_END()                   EvrFreeRTOSTasks_LowPowerIdleEnd()
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_NOTIFY_TAKE_BLOCK_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_NOTIFY_TAKE_BLOCK()               EvrFreeRTOSTasks_TaskNotifyTakeBlock(xTicksToWait)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_NOTIFY_TAKE_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_NOTIFY_TAKE()                     EvrFreeRTOSTasks_TaskNotifyTake(pxCurrentTCB->ulNotifiedValue)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_NOTIFY_WAIT_BLOCK_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_NOTIFY_WAIT_BLOCK()               EvrFreeRTOSTasks_TaskNotifyWaitBlock(xTicksToWait)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_NOTIFY_WAIT_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_NOTIFY_WAIT()                     EvrFreeRTOSTasks_TaskNotifyWait(pxCurrentTCB->ulNotifiedValue)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_NOTIFY_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_NOTIFY()                          EvrFreeRTOSTasks_TaskNotify(pxTCB, ulValue, eAction, pxTCB->ulNotifiedValue)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_NOTIFY_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_NOTIFY_FROM_ISR()                 EvrFreeRTOSTasks_TaskNotifyFromIsr(pxTCB, ulValue, eAction, pxTCB->ulNotifiedValue)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTASK_NOTIFY_GIVE_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceTASK_NOTIFY_GIVE_FROM_ISR()            EvrFreeRTOSTasks_TaskNotifyGiveFromIsr(pxTCB, pxTCB->ulNotifiedValue)
N#endif
N
N
N/* Queue */
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_CREATE_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_CREATE(px)                       EvrFreeRTOSQueue_QueueCreate(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_CREATE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_CREATE_FAILED(uc)                EvrFreeRTOSQueue_QueueCreateFailed(uc)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceCREATE_MUTEX_DISABLE))
X#if (!1L && !0L)
S  #define traceCREATE_MUTEX(px)                       EvrFreeRTOSQueue_CreateMutex(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceCREATE_MUTEX_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceCREATE_MUTEX_FAILED()                  EvrFreeRTOSQueue_CreateMutexFailed()
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceGIVE_MUTEX_RECURSIVE_DISABLE))
X#if (!1L && !0L)
S  #define traceGIVE_MUTEX_RECURSIVE(px)               EvrFreeRTOSQueue_GiveMutexRecursive(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceGIVE_MUTEX_RECURSIVE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceGIVE_MUTEX_RECURSIVE_FAILED(px)        EvrFreeRTOSQueue_GiveMutexRecursiveFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTAKE_MUTEX_RECURSIVE_DISABLE))
X#if (!1L && !0L)
S  #define traceTAKE_MUTEX_RECURSIVE(px)               EvrFreeRTOSQueue_TakeMutexRecursive(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTAKE_MUTEX_RECURSIVE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceTAKE_MUTEX_RECURSIVE_FAILED(px)        EvrFreeRTOSQueue_TakeMutexRecursiveFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceCREATE_COUNTING_SEMAPHORE_DISABLE))
X#if (!1L && !0L)
S  #define traceCREATE_COUNTING_SEMAPHORE()            EvrFreeRTOSQueue_CreateCountingSemaphore(xHandle)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceCREATE_COUNTING_SEMAPHORE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceCREATE_COUNTING_SEMAPHORE_FAILED()     EvrFreeRTOSQueue_CreateCountingSemaphoreFailed()
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_SEND_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_SEND(px)                         EvrFreeRTOSQueue_QueueSend(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_SEND_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_SEND_FAILED(px)                  EvrFreeRTOSQueue_QueueSendFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_RECEIVE_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_RECEIVE(px)                      EvrFreeRTOSQueue_QueueReceive(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_PEEK_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_PEEK(px)                         EvrFreeRTOSQueue_QueuePeek(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_PEEK_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_PEEK_FAILED(px)                  EvrFreeRTOSQueue_QueuePeekFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_PEEK_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_PEEK_FROM_ISR(px)                EvrFreeRTOSQueue_QueuePeekFromIsr(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_RECEIVE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_RECEIVE_FAILED(px)               EvrFreeRTOSQueue_QueueReceiveFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_SEND_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_SEND_FROM_ISR(px)                EvrFreeRTOSQueue_QueueSendFromIsr(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_SEND_FROM_ISR_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_SEND_FROM_ISR_FAILED(px)         EvrFreeRTOSQueue_QueueSendFromIsrFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_RECEIVE_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_RECEIVE_FROM_ISR(px)             EvrFreeRTOSQueue_QueueReceiveFromIsr(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_RECEIVE_FROM_ISR_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_RECEIVE_FROM_ISR_FAILED(px)      EvrFreeRTOSQueue_QueueReceiveFromIsrFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_PEEK_FROM_ISR_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_PEEK_FROM_ISR_FAILED(px)         EvrFreeRTOSQueue_QueuePeekFromIsrFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_DELETE_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_DELETE(px)                       EvrFreeRTOSQueue_QueueDelete(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceQUEUE_REGISTRY_ADD_DISABLE))
X#if (!1L && !0L)
S  #define traceQUEUE_REGISTRY_ADD(px,pc)              EvrFreeRTOSQueue_QueueRegistryAdd(px,pc)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceBLOCKING_ON_QUEUE_RECEIVE_DISABLE))
X#if (!1L && !0L)
S  #define traceBLOCKING_ON_QUEUE_RECEIVE(px)          EvrFreeRTOSQueue_BlockingOnQueueReceive(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceBLOCKING_ON_QUEUE_SEND_DISABLE))
X#if (!1L && !0L)
S  #define traceBLOCKING_ON_QUEUE_SEND(px)             EvrFreeRTOSQueue_BlockingOnQueueSend(px)
N#endif
N
N
N/* Timers */
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTIMER_CREATE_DISABLE))
X#if (!1L && !0L)
S  #define traceTIMER_CREATE(px)                       EvrFreeRTOSTimers_TimerCreate(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTIMER_CREATE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceTIMER_CREATE_FAILED()                  EvrFreeRTOSTimers_TimerCreateFailed()
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTIMER_COMMAND_SEND_DISABLE))
X#if (!1L && !0L)
S  #define traceTIMER_COMMAND_SEND(pxT,xC,xO,xR)       EvrFreeRTOSTimers_TimerCommandSend(pxT,xC,xO,xR)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTIMER_COMMAND_RECEIVED_DISABLE))
X#if (!1L && !0L)
S  #define traceTIMER_COMMAND_RECEIVED(px,xC,xO)       EvrFreeRTOSTimers_TimerCommandReceived(px,xC,xO)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceTIMER_EXPIRED_DISABLE))
X#if (!1L && !0L)
S  #define traceTIMER_EXPIRED(px)                      EvrFreeRTOSTimers_TimerExpired(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(tracePEND_FUNC_CALL_DISABLE))
X#if (!1L && !0L)
S  #define tracePEND_FUNC_CALL(px,pv,ul,x)             EvrFreeRTOSTimers_PendFuncCall(px,pv,ul,x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(tracePEND_FUNC_CALL_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define tracePEND_FUNC_CALL_FROM_ISR(px,pv,ul,x)    EvrFreeRTOSTimers_PendFuncCallFromIsr(px,pv,ul,x)
N#endif
N
N
N/* Event Groups */
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_CREATE_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_CREATE(px)                 EvrFreeRTOSEventGroups_EventGroupCreate(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_CREATE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_CREATE_FAILED()            EvrFreeRTOSEventGroups_EventGroupCreateFailed()
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_SYNC_BLOCK_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_SYNC_BLOCK(px,uxS,uxW)     EvrFreeRTOSEventGroups_EventGroupSyncBlock(px,uxS,uxW)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_SYNC_END_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_SYNC_END(px,uxS,uxW,x)     EvrFreeRTOSEventGroups_EventGroupSyncEnd(px,uxS,uxW,x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_WAIT_BITS_BLOCK_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_WAIT_BITS_BLOCK(px,ux)     EvrFreeRTOSEventGroups_EventGroupWaitBitsBlock(px,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_WAIT_BITS_END_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_WAIT_BITS_END(px,ux,x)     EvrFreeRTOSEventGroups_EventGroupWaitBitsEnd(px,ux,x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_CLEAR_BITS_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_CLEAR_BITS(px,ux)          EvrFreeRTOSEventGroups_EventGroupClearBits(px,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_CLEAR_BITS_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR(px,ux) EvrFreeRTOSEventGroups_EventGroupClearBitsFromIsr(px,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_SET_BITS_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_SET_BITS(px,ux)            EvrFreeRTOSEventGroups_EventGroupSetBits(px,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_SET_BITS_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_SET_BITS_FROM_ISR(px,ux)   EvrFreeRTOSEventGroups_EventGroupSetBitsFromIsr(px,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceEVENT_GROUP_DELETE_DISABLE))
X#if (!1L && !0L)
S  #define traceEVENT_GROUP_DELETE(px)                 EvrFreeRTOSEventGroups_EventGroupDelete(px)
N#endif
N
N
N/* Stream Buffer */
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_CREATE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_CREATE_FAILED(ux)        EvrFreeRTOSStreamBuf_StreamBufferCreateFailed(ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_CREATE_STATIC_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_CREATE_STATIC_FAILED(x,ux)  EvrFreeRTOSStreamBuf_StreamBufferCreateStaticFailed(x,ux)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_CREATE_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_CREATE(px,x)             EvrFreeRTOSStreamBuf_StreamBufferCreate(px,x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_DELETE_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_DELETE(px)               EvrFreeRTOSStreamBuf_StreamBufferDelete(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_RESET_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_RESET(px)                EvrFreeRTOSStreamBuf_StreamBufferReset(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceBLOCKING_ON_STREAM_BUFFER_SEND_DISABLE))
X#if (!1L && !0L)
S  #define traceBLOCKING_ON_STREAM_BUFFER_SEND(px)     EvrFreeRTOSStreamBuf_StreamBufferBlockingOnSend(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_SEND_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_SEND(px,x)               EvrFreeRTOSStreamBuf_StreamBufferSend(px,x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_SEND_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_SEND_FAILED(px)          EvrFreeRTOSStreamBuf_StreamBufferSendFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_SEND_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_SEND_FROM_ISR(px,x)      EvrFreeRTOSStreamBuf_StreamBufferSendFromIsr(px,x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceBLOCKING_ON_STREAM_BUFFER_RECEIVE_DISABLE))
X#if (!1L && !0L)
S  #define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE(px)  EvrFreeRTOSStreamBuf_StreamBufferBlockingOnReceive(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_RECEIVE_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_RECEIVE(px,x)            EvrFreeRTOSStreamBuf_StreamBufferReceive(px,x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_RECEIVE_FAILED_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_RECEIVE_FAILED(px)       EvrFreeRTOSStreamBuf_StreamBufferReceiveFailed(px)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceSTREAM_BUFFER_RECEIVE_FROM_ISR_DISABLE))
X#if (!1L && !0L)
S  #define traceSTREAM_BUFFER_RECEIVE_FROM_ISR(px,x)   EvrFreeRTOSStreamBuf_StreamBufferReceiveFromIsr(px,x)
N#endif
N
N
N/* Heap */
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceMALLOC_DISABLE))
X#if (!1L && !0L)
S  #define traceMALLOC(pv,x)                           EvrFreeRTOSHeap_Malloc(pv,x)
N#endif
N
N#if (!defined(EVR_FREERTOS_DISABLE) && !defined(traceFREE_DISABLE))
X#if (!1L && !0L)
S  #define traceFREE(pv,x)                             EvrFreeRTOSHeap_Free(pv,x)
N#endif
N
N
N/* Undefine FreeRTOS object types */
N#undef TCB_t
N#undef Queue_t
N#undef Timer_t
N#undef PendedFunction_t
N#undef EventGroup_t
N#undef StreamBuffer_t
N
N#endif /* FREERTOS_EVR_H_ */
L 176 ".\Common\RTE\RTOS\FreeRTOSConfig.h" 2
N
N#endif /* FREERTOS_CONFIG_H */
L 57 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N
N/* Basic FreeRTOS definitions. */
N#include "projdefs.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\projdefs.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N#ifndef PROJDEFS_H
N#define PROJDEFS_H
N
N/*
N * Defines the prototype to which task functions must conform.  Defined in this
N * file to ensure the type is known before portable.h is included.
N */
Ntypedef void (*TaskFunction_t)( void * );
N
N/* Converts a time in milliseconds to a time in ticks.  This macro can be
Noverridden by a macro of the same name defined in FreeRTOSConfig.h in case the
Ndefinition here is not suitable for your application. */
N#ifndef pdMS_TO_TICKS
N	#define pdMS_TO_TICKS( xTimeInMs ) ( ( TickType_t ) ( ( ( TickType_t ) ( xTimeInMs ) * ( TickType_t ) configTICK_RATE_HZ ) / ( TickType_t ) 1000 ) )
N#endif
N
N#define pdFALSE			( ( BaseType_t ) 0 )
N#define pdTRUE			( ( BaseType_t ) 1 )
N
N#define pdPASS			( pdTRUE )
N#define pdFAIL			( pdFALSE )
N#define errQUEUE_EMPTY	( ( BaseType_t ) 0 )
N#define errQUEUE_FULL	( ( BaseType_t ) 0 )
N
N/* FreeRTOS error definitions. */
N#define errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY	( -1 )
N#define errQUEUE_BLOCKED						( -4 )
N#define errQUEUE_YIELD							( -5 )
N
N/* Macros used for basic data corruption checks. */
N#ifndef configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES
N	#define configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES 0
N#endif
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	#define pdINTEGRITY_CHECK_VALUE 0x5a5a
N#else
N	#define pdINTEGRITY_CHECK_VALUE 0x5a5a5a5aUL
N#endif
N
N/* The following errno values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_ERRNO_NONE			0	/* No errors */
N#define	pdFREERTOS_ERRNO_ENOENT			2	/* No such file or directory */
N#define	pdFREERTOS_ERRNO_EINTR			4	/* Interrupted system call */
N#define	pdFREERTOS_ERRNO_EIO			5	/* I/O error */
N#define	pdFREERTOS_ERRNO_ENXIO			6	/* No such device or address */
N#define	pdFREERTOS_ERRNO_EBADF			9	/* Bad file number */
N#define	pdFREERTOS_ERRNO_EAGAIN			11	/* No more processes */
N#define	pdFREERTOS_ERRNO_EWOULDBLOCK	11	/* Operation would block */
N#define	pdFREERTOS_ERRNO_ENOMEM			12	/* Not enough memory */
N#define	pdFREERTOS_ERRNO_EACCES			13	/* Permission denied */
N#define	pdFREERTOS_ERRNO_EFAULT			14	/* Bad address */
N#define	pdFREERTOS_ERRNO_EBUSY			16	/* Mount device busy */
N#define	pdFREERTOS_ERRNO_EEXIST			17	/* File exists */
N#define	pdFREERTOS_ERRNO_EXDEV			18	/* Cross-device link */
N#define	pdFREERTOS_ERRNO_ENODEV			19	/* No such device */
N#define	pdFREERTOS_ERRNO_ENOTDIR		20	/* Not a directory */
N#define	pdFREERTOS_ERRNO_EISDIR			21	/* Is a directory */
N#define	pdFREERTOS_ERRNO_EINVAL			22	/* Invalid argument */
N#define	pdFREERTOS_ERRNO_ENOSPC			28	/* No space left on device */
N#define	pdFREERTOS_ERRNO_ESPIPE			29	/* Illegal seek */
N#define	pdFREERTOS_ERRNO_EROFS			30	/* Read only file system */
N#define	pdFREERTOS_ERRNO_EUNATCH		42	/* Protocol driver not attached */
N#define	pdFREERTOS_ERRNO_EBADE			50	/* Invalid exchange */
N#define	pdFREERTOS_ERRNO_EFTYPE			79	/* Inappropriate file type or format */
N#define	pdFREERTOS_ERRNO_ENMFILE		89	/* No more files */
N#define	pdFREERTOS_ERRNO_ENOTEMPTY		90	/* Directory not empty */
N#define	pdFREERTOS_ERRNO_ENAMETOOLONG 	91	/* File or path name too long */
N#define	pdFREERTOS_ERRNO_EOPNOTSUPP		95	/* Operation not supported on transport endpoint */
N#define	pdFREERTOS_ERRNO_ENOBUFS		105	/* No buffer space available */
N#define	pdFREERTOS_ERRNO_ENOPROTOOPT	109	/* Protocol not available */
N#define	pdFREERTOS_ERRNO_EADDRINUSE		112	/* Address already in use */
N#define	pdFREERTOS_ERRNO_ETIMEDOUT		116	/* Connection timed out */
N#define	pdFREERTOS_ERRNO_EINPROGRESS	119	/* Connection already in progress */
N#define	pdFREERTOS_ERRNO_EALREADY		120	/* Socket already connected */
N#define	pdFREERTOS_ERRNO_EADDRNOTAVAIL 	125	/* Address not available */
N#define	pdFREERTOS_ERRNO_EISCONN		127	/* Socket is already connected */
N#define	pdFREERTOS_ERRNO_ENOTCONN		128	/* Socket is not connected */
N#define	pdFREERTOS_ERRNO_ENOMEDIUM		135	/* No medium inserted */
N#define	pdFREERTOS_ERRNO_EILSEQ			138	/* An invalid UTF-16 sequence was encountered. */
N#define	pdFREERTOS_ERRNO_ECANCELED		140	/* Operation canceled. */
N
N/* The following endian values are used by FreeRTOS+ components, not FreeRTOS
Nitself. */
N#define pdFREERTOS_LITTLE_ENDIAN		0
N#define pdFREERTOS_BIG_ENDIAN			1
N
N/* Re-defining endian values for generic naming. */
N#define pdLITTLE_ENDIAN					pdFREERTOS_LITTLE_ENDIAN
N#define pdBIG_ENDIAN					pdFREERTOS_BIG_ENDIAN
N
N
N#endif /* PROJDEFS_H */
N
N
N
L 60 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N
N/* Definitions specific to the port being used. */
N#include "portable.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\portable.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N/*-----------------------------------------------------------
N * Portable layer API.  Each function must be defined for each port.
N *----------------------------------------------------------*/
N
N#ifndef PORTABLE_H
N#define PORTABLE_H
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.
NPurely for reasons of backward compatibility the old method is still valid, but
Nto make it clear that new projects should not use it, support for the port
Nspecific constants has been moved into the deprecated_definitions.h header
Nfile. */
N#include "deprecated_definitions.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\deprecated_definitions.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N#ifndef DEPRECATED_DEFINITIONS_H
N#define DEPRECATED_DEFINITIONS_H
N
N
N/* Each FreeRTOS port has a unique portmacro.h header file.  Originally a
Npre-processor definition was used to ensure the pre-processor found the correct
Nportmacro.h file for the port being used.  That scheme was deprecated in favour
Nof setting the compiler's include path such that it found the correct
Nportmacro.h file - removing the need for the constant and allowing the
Nportmacro.h file to be located anywhere in relation to the port being used.  The
Ndefinitions below remain in the code for backward compatibility only.  New
Nprojects should not use them. */
N
N#ifdef OPEN_WATCOM_INDUSTRIAL_PC_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\pc\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef OPEN_WATCOM_FLASH_LITE_186_PORT
S	#include "..\..\Source\portable\owatcom\16bitdos\flsh186\portmacro.h"
S	typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef GCC_MEGA_AVR
S	#include "../portable/GCC/ATMega323/portmacro.h"
N#endif
N
N#ifdef IAR_MEGA_AVR
S	#include "../portable/IAR/ATMega323/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC24_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_DSPIC_PORT
S	#include "../../Source/portable/MPLAB/PIC24_dsPIC/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC18F_PORT
S	#include "../../Source/portable/MPLAB/PIC18F/portmacro.h"
N#endif
N
N#ifdef MPLAB_PIC32MX_PORT
S	#include "../../Source/portable/MPLAB/PIC32MX/portmacro.h"
N#endif
N
N#ifdef _FEDPICC
S	#include "libFreeRTOS/Include/portmacro.h"
N#endif
N
N#ifdef SDCC_CYGNAL
S	#include "../../Source/portable/SDCC/Cygnal/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7
S	#include "../../Source/portable/GCC/ARM7_LPC2000/portmacro.h"
N#endif
N
N#ifdef GCC_ARM7_ECLIPSE
S	#include "portmacro.h"
N#endif
N
N#ifdef ROWLEY_LPC23xx
S	#include "../../Source/portable/GCC/ARM7_LPC23xx/portmacro.h"
N#endif
N
N#ifdef IAR_MSP430
S	#include "..\..\Source\portable\IAR\MSP430\portmacro.h"
N#endif
N
N#ifdef GCC_MSP430
S	#include "../../Source/portable/GCC/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ROWLEY_MSP430
S	#include "../../Source/portable/Rowley/MSP430F449/portmacro.h"
N#endif
N
N#ifdef ARM7_LPC21xx_KEIL_RVDS
S	#include "..\..\Source\portable\RVDS\ARM7_LPC21xx\portmacro.h"
N#endif
N
N#ifdef SAM7_GCC
S	#include "../../Source/portable/GCC/ARM7_AT91SAM7S/portmacro.h"
N#endif
N
N#ifdef SAM7_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM7S64\portmacro.h"
N#endif
N
N#ifdef SAM9XE_IAR
S	#include "..\..\Source\portable\IAR\AtmelSAM9XE\portmacro.h"
N#endif
N
N#ifdef LPC2000_IAR
S	#include "..\..\Source\portable\IAR\LPC2000\portmacro.h"
N#endif
N
N#ifdef STR71X_IAR
S	#include "..\..\Source\portable\IAR\STR71x\portmacro.h"
N#endif
N
N#ifdef STR75X_IAR
S	#include "..\..\Source\portable\IAR\STR75x\portmacro.h"
N#endif
N
N#ifdef STR75X_GCC
S	#include "..\..\Source\portable\GCC\STR75x\portmacro.h"
N#endif
N
N#ifdef STR91X_IAR
S	#include "..\..\Source\portable\IAR\STR91x\portmacro.h"
N#endif
N
N#ifdef GCC_H8S
S	#include "../../Source/portable/GCC/H8S2329/portmacro.h"
N#endif
N
N#ifdef GCC_AT91FR40008
S	#include "../../Source/portable/GCC/ARM7_AT91FR40008/portmacro.h"
N#endif
N
N#ifdef RVDS_ARMCM3_LM3S102
S	#include "../../Source/portable/RVDS/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3_LM3S102
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef GCC_ARMCM3
S	#include "../../Source/portable/GCC/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARM_CM3
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef IAR_ARMCM3_LM
S	#include "../../Source/portable/IAR/ARM_CM3/portmacro.h"
N#endif
N
N#ifdef HCS12_CODE_WARRIOR
S	#include "../../Source/portable/CodeWarrior/HCS12/portmacro.h"
N#endif
N
N#ifdef MICROBLAZE_GCC
S	#include "../../Source/portable/GCC/MicroBlaze/portmacro.h"
N#endif
N
N#ifdef TERN_EE
S	#include "..\..\Source\portable\Paradigm\Tern_EE\small\portmacro.h"
N#endif
N
N#ifdef GCC_HCS12
S	#include "../../Source/portable/GCC/HCS12/portmacro.h"
N#endif
N
N#ifdef GCC_MCF5235
S    #include "../../Source/portable/GCC/MCF5235/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_GCC
S	#include "../../../Source/portable/GCC/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef COLDFIRE_V2_CODEWARRIOR
S	#include "../../Source/portable/CodeWarrior/ColdFire_V2/portmacro.h"
N#endif
N
N#ifdef GCC_PPC405
S	#include "../../Source/portable/GCC/PPC405_Xilinx/portmacro.h"
N#endif
N
N#ifdef GCC_PPC440
S	#include "../../Source/portable/GCC/PPC440_Xilinx/portmacro.h"
N#endif
N
N#ifdef _16FX_SOFTUNE
S	#include "..\..\Source\portable\Softune\MB96340\portmacro.h"
N#endif
N
N#ifdef BCC_INDUSTRIAL_PC_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\PC\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef BCC_FLASH_LITE_186_PORT
S	/* A short file name has to be used in place of the normal
S	FreeRTOSConfig.h when using the Borland compiler. */
S	#include "frconfig.h"
S	#include "..\portable\BCC\16BitDOS\flsh186\prtmacro.h"
S    typedef void ( __interrupt __far *pxISR )();
N#endif
N
N#ifdef __GNUC__
S   #ifdef __AVR32_AVR32A__
S	   #include "portmacro.h"
S   #endif
N#endif
N
N#ifdef __ICCAVR32__
S   #ifdef __CORE__
S      #if __CORE__ == __AVR32A__
S	      #include "portmacro.h"
S      #endif
S   #endif
N#endif
N
N#ifdef __91467D
S	#include "portmacro.h"
N#endif
N
N#ifdef __96340
S	#include "portmacro.h"
N#endif
N
N
N#ifdef __IAR_V850ES_Fx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx3_L__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Jx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_V850ES_Hx2__
S	#include "../../Source/portable/IAR/V850ES/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#ifdef __IAR_78K0R_Kx3L__
S	#include "../../Source/portable/IAR/78K0R/portmacro.h"
N#endif
N
N#endif /* DEPRECATED_DEFINITIONS_H */
N
L 46 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\portable.h" 2
N
N/* If portENTER_CRITICAL is not defined then including deprecated_definitions.h
Ndid not result in a portmacro.h header file being included - and it should be
Nincluded here.  In this case the path to the correct portmacro.h header file
Nmust be set in the compiler's include path. */
N#ifndef portENTER_CRITICAL
N	#include "portmacro.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\portable\RVDS\ARM_CM0\portmacro.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N
N#ifndef PORTMACRO_H
N#define PORTMACRO_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * Port specific definitions.
N *
N * The settings in this file configure FreeRTOS correctly for the
N * given hardware and compiler.
N *
N * These settings should not be altered.
N *-----------------------------------------------------------
N */
N
N/* Type definitions. */
N#define portCHAR		char
N#define portFLOAT		float
N#define portDOUBLE		double
N#define portLONG		long
N#define portSHORT		short
N#define portSTACK_TYPE	uint32_t
N#define portBASE_TYPE	long
N
Ntypedef portSTACK_TYPE StackType_t;
Xtypedef uint32_t StackType_t;
Ntypedef long BaseType_t;
Ntypedef unsigned long UBaseType_t;
N
N#if( configUSE_16_BIT_TICKS == 1 )
X#if( 0 == 1 )
S	typedef uint16_t TickType_t;
S	#define portMAX_DELAY ( TickType_t ) 0xffff
N#else
N	typedef uint32_t TickType_t;
N	#define portMAX_DELAY ( TickType_t ) 0xffffffffUL
N
N	/* 32-bit tick type on a 32-bit architecture, so reads of the tick count do
N	not need to be guarded with a critical section. */
N	#define portTICK_TYPE_IS_ATOMIC 1
N#endif
N/*-----------------------------------------------------------*/
N
N/* Architecture specifics. */
N#define portSTACK_GROWTH			( -1 )
N#define portTICK_PERIOD_MS			( ( TickType_t ) 1000 / configTICK_RATE_HZ )
N#define portBYTE_ALIGNMENT			8
N/*-----------------------------------------------------------*/
N
N
N/* Scheduler utilities. */
Nextern void vPortYield( void );
N#define portNVIC_INT_CTRL_REG		( * ( ( volatile uint32_t * ) 0xe000ed04 ) )
N#define portNVIC_PENDSVSET_BIT		( 1UL << 28UL )
N#define portYIELD()					vPortYield()
N#define portEND_SWITCHING_ISR( xSwitchRequired ) if( xSwitchRequired ) portNVIC_INT_CTRL_REG = portNVIC_PENDSVSET_BIT
N#define portYIELD_FROM_ISR( x ) portEND_SWITCHING_ISR( x )
N/*-----------------------------------------------------------*/
N
N/* Critical section management. */
Nextern void vPortEnterCritical( void );
Nextern void vPortExitCritical( void );
Nextern uint32_t ulSetInterruptMaskFromISR( void );
Nextern void vClearInterruptMaskFromISR( uint32_t ulMask );
N
N#define portSET_INTERRUPT_MASK_FROM_ISR()		ulSetInterruptMaskFromISR()
N#define portCLEAR_INTERRUPT_MASK_FROM_ISR(x)	vClearInterruptMaskFromISR( x )
N#define portDISABLE_INTERRUPTS()				__disable_irq()
N#define portENABLE_INTERRUPTS()					__enable_irq()
N#define portENTER_CRITICAL()					vPortEnterCritical()
N#define portEXIT_CRITICAL()						vPortExitCritical()
N
N/*-----------------------------------------------------------*/
N
N/* Task function macros as described on the FreeRTOS.org WEB site. */
N#define portTASK_FUNCTION_PROTO( vFunction, pvParameters ) void vFunction( void *pvParameters )
N#define portTASK_FUNCTION( vFunction, pvParameters ) void vFunction( void *pvParameters )
N
N#define portNOP()
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTMACRO_H */
N
L 53 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\portable.h" 2
N#endif
N
N#if portBYTE_ALIGNMENT == 32
X#if 8 == 32
S	#define portBYTE_ALIGNMENT_MASK ( 0x001f )
N#endif
N
N#if portBYTE_ALIGNMENT == 16
X#if 8 == 16
S	#define portBYTE_ALIGNMENT_MASK ( 0x000f )
N#endif
N
N#if portBYTE_ALIGNMENT == 8
X#if 8 == 8
N	#define portBYTE_ALIGNMENT_MASK ( 0x0007 )
N#endif
N
N#if portBYTE_ALIGNMENT == 4
X#if 8 == 4
S	#define portBYTE_ALIGNMENT_MASK	( 0x0003 )
N#endif
N
N#if portBYTE_ALIGNMENT == 2
X#if 8 == 2
S	#define portBYTE_ALIGNMENT_MASK	( 0x0001 )
N#endif
N
N#if portBYTE_ALIGNMENT == 1
X#if 8 == 1
S	#define portBYTE_ALIGNMENT_MASK	( 0x0000 )
N#endif
N
N#ifndef portBYTE_ALIGNMENT_MASK
S	#error "Invalid portBYTE_ALIGNMENT definition"
N#endif
N
N#ifndef portNUM_CONFIGURABLE_REGIONS
N	#define portNUM_CONFIGURABLE_REGIONS 1
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include "mpu_wrappers.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\mpu_wrappers.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N#ifndef MPU_WRAPPERS_H
N#define MPU_WRAPPERS_H
N
N/* This file redefines API functions to be called through a wrapper macro, but
Nonly for ports that are using the MPU. */
N#ifdef portUSING_MPU_WRAPPERS
S
S	/* MPU_WRAPPERS_INCLUDED_FROM_API_FILE will be defined when this file is
S	included from queue.c or task.c to prevent it from having an effect within
S	those files. */
S	#ifndef MPU_WRAPPERS_INCLUDED_FROM_API_FILE
S
S		/*
S		 * Map standard (non MPU) API functions to equivalents that start
S		 * "MPU_".  This will cause the application code to call the MPU_
S		 * version, which wraps the non-MPU version with privilege promoting
S		 * then demoting code, so the kernel code always runs will full
S		 * privileges.
S		 */
S
S		/* Map standard tasks.h API functions to the MPU equivalents. */
S		#define xTaskCreate								MPU_xTaskCreate
S		#define xTaskCreateStatic						MPU_xTaskCreateStatic
S		#define xTaskCreateRestricted					MPU_xTaskCreateRestricted
S		#define vTaskAllocateMPURegions					MPU_vTaskAllocateMPURegions
S		#define vTaskDelete								MPU_vTaskDelete
S		#define vTaskDelay								MPU_vTaskDelay
S		#define vTaskDelayUntil							MPU_vTaskDelayUntil
S		#define xTaskAbortDelay							MPU_xTaskAbortDelay
S		#define uxTaskPriorityGet						MPU_uxTaskPriorityGet
S		#define eTaskGetState							MPU_eTaskGetState
S		#define vTaskGetInfo							MPU_vTaskGetInfo
S		#define vTaskPrioritySet						MPU_vTaskPrioritySet
S		#define vTaskSuspend							MPU_vTaskSuspend
S		#define vTaskResume								MPU_vTaskResume
S		#define vTaskSuspendAll							MPU_vTaskSuspendAll
S		#define xTaskResumeAll							MPU_xTaskResumeAll
S		#define xTaskGetTickCount						MPU_xTaskGetTickCount
S		#define uxTaskGetNumberOfTasks					MPU_uxTaskGetNumberOfTasks
S		#define pcTaskGetName							MPU_pcTaskGetName
S		#define xTaskGetHandle							MPU_xTaskGetHandle
S		#define uxTaskGetStackHighWaterMark				MPU_uxTaskGetStackHighWaterMark
S		#define vTaskSetApplicationTaskTag				MPU_vTaskSetApplicationTaskTag
S		#define xTaskGetApplicationTaskTag				MPU_xTaskGetApplicationTaskTag
S		#define vTaskSetThreadLocalStoragePointer		MPU_vTaskSetThreadLocalStoragePointer
S		#define pvTaskGetThreadLocalStoragePointer		MPU_pvTaskGetThreadLocalStoragePointer
S		#define xTaskCallApplicationTaskHook			MPU_xTaskCallApplicationTaskHook
S		#define xTaskGetIdleTaskHandle					MPU_xTaskGetIdleTaskHandle
S		#define uxTaskGetSystemState					MPU_uxTaskGetSystemState
S		#define vTaskList								MPU_vTaskList
S		#define vTaskGetRunTimeStats					MPU_vTaskGetRunTimeStats
S		#define xTaskGenericNotify						MPU_xTaskGenericNotify
S		#define xTaskNotifyWait							MPU_xTaskNotifyWait
S		#define ulTaskNotifyTake						MPU_ulTaskNotifyTake
S		#define xTaskNotifyStateClear					MPU_xTaskNotifyStateClear
S
S		#define xTaskGetCurrentTaskHandle				MPU_xTaskGetCurrentTaskHandle
S		#define vTaskSetTimeOutState					MPU_vTaskSetTimeOutState
S		#define xTaskCheckForTimeOut					MPU_xTaskCheckForTimeOut
S		#define xTaskGetSchedulerState					MPU_xTaskGetSchedulerState
S
S		/* Map standard queue.h API functions to the MPU equivalents. */
S		#define xQueueGenericSend						MPU_xQueueGenericSend
S		#define xQueueReceive							MPU_xQueueReceive
S		#define xQueuePeek								MPU_xQueuePeek
S		#define xQueueSemaphoreTake						MPU_xQueueSemaphoreTake
S		#define uxQueueMessagesWaiting					MPU_uxQueueMessagesWaiting
S		#define uxQueueSpacesAvailable					MPU_uxQueueSpacesAvailable
S		#define vQueueDelete							MPU_vQueueDelete
S		#define xQueueCreateMutex						MPU_xQueueCreateMutex
S		#define xQueueCreateMutexStatic					MPU_xQueueCreateMutexStatic
S		#define xQueueCreateCountingSemaphore			MPU_xQueueCreateCountingSemaphore
S		#define xQueueCreateCountingSemaphoreStatic		MPU_xQueueCreateCountingSemaphoreStatic
S		#define xQueueGetMutexHolder					MPU_xQueueGetMutexHolder
S		#define xQueueTakeMutexRecursive				MPU_xQueueTakeMutexRecursive
S		#define xQueueGiveMutexRecursive				MPU_xQueueGiveMutexRecursive
S		#define xQueueGenericCreate						MPU_xQueueGenericCreate
S		#define xQueueGenericCreateStatic				MPU_xQueueGenericCreateStatic
S		#define xQueueCreateSet							MPU_xQueueCreateSet
S		#define xQueueAddToSet							MPU_xQueueAddToSet
S		#define xQueueRemoveFromSet						MPU_xQueueRemoveFromSet
S		#define xQueueSelectFromSet						MPU_xQueueSelectFromSet
S		#define xQueueGenericReset						MPU_xQueueGenericReset
S
S		#if( configQUEUE_REGISTRY_SIZE > 0 )
S			#define vQueueAddToRegistry						MPU_vQueueAddToRegistry
S			#define vQueueUnregisterQueue					MPU_vQueueUnregisterQueue
S			#define pcQueueGetName							MPU_pcQueueGetName
S		#endif
S
S		/* Map standard timer.h API functions to the MPU equivalents. */
S		#define xTimerCreate							MPU_xTimerCreate
S		#define xTimerCreateStatic						MPU_xTimerCreateStatic
S		#define pvTimerGetTimerID						MPU_pvTimerGetTimerID
S		#define vTimerSetTimerID						MPU_vTimerSetTimerID
S		#define xTimerIsTimerActive						MPU_xTimerIsTimerActive
S		#define xTimerGetTimerDaemonTaskHandle			MPU_xTimerGetTimerDaemonTaskHandle
S		#define xTimerPendFunctionCall					MPU_xTimerPendFunctionCall
S		#define pcTimerGetName							MPU_pcTimerGetName
S		#define xTimerGetPeriod							MPU_xTimerGetPeriod
S		#define xTimerGetExpiryTime						MPU_xTimerGetExpiryTime
S		#define xTimerGenericCommand					MPU_xTimerGenericCommand
S
S		/* Map standard event_group.h API functions to the MPU equivalents. */
S		#define xEventGroupCreate						MPU_xEventGroupCreate
S		#define xEventGroupCreateStatic					MPU_xEventGroupCreateStatic
S		#define xEventGroupWaitBits						MPU_xEventGroupWaitBits
S		#define xEventGroupClearBits					MPU_xEventGroupClearBits
S		#define xEventGroupSetBits						MPU_xEventGroupSetBits
S		#define xEventGroupSync							MPU_xEventGroupSync
S		#define vEventGroupDelete						MPU_vEventGroupDelete
S
S		/* Map standard message/stream_buffer.h API functions to the MPU
S		equivalents. */
S		#define xStreamBufferSend						MPU_xStreamBufferSend
S		#define xStreamBufferSendFromISR				MPU_xStreamBufferSendFromISR
S		#define xStreamBufferReceive					MPU_xStreamBufferReceive
S		#define xStreamBufferReceiveFromISR				MPU_xStreamBufferReceiveFromISR
S		#define vStreamBufferDelete						MPU_vStreamBufferDelete
S		#define xStreamBufferIsFull						MPU_xStreamBufferIsFull
S		#define xStreamBufferIsEmpty					MPU_xStreamBufferIsEmpty
S		#define xStreamBufferReset						MPU_xStreamBufferReset
S		#define xStreamBufferSpacesAvailable			MPU_xStreamBufferSpacesAvailable
S		#define xStreamBufferBytesAvailable				MPU_xStreamBufferBytesAvailable
S		#define xStreamBufferSetTriggerLevel			MPU_xStreamBufferSetTriggerLevel
S		#define xStreamBufferGenericCreate				MPU_xStreamBufferGenericCreate
S		#define xStreamBufferGenericCreateStatic		MPU_xStreamBufferGenericCreateStatic
S
S
S		/* Remove the privileged function macro, but keep the PRIVILEGED_DATA
S		macro so applications can place data in privileged access sections
S		(useful when using statically allocated objects). */
S		#define PRIVILEGED_FUNCTION
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#else /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
S		/* Ensure API functions go in the privileged execution section. */
S		#define PRIVILEGED_FUNCTION __attribute__((section("privileged_functions")))
S		#define PRIVILEGED_DATA __attribute__((section("privileged_data")))
S
S	#endif /* MPU_WRAPPERS_INCLUDED_FROM_API_FILE */
S
N#else /* portUSING_MPU_WRAPPERS */
N
N	#define PRIVILEGED_FUNCTION
N	#define PRIVILEGED_DATA
N	#define portUSING_MPU_WRAPPERS 0
N
N#endif /* portUSING_MPU_WRAPPERS */
N
N
N#endif /* MPU_WRAPPERS_H */
N
L 92 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\portable.h" 2
N
N/*
N * Setup the stack of a new task so it is ready to be placed under the
N * scheduler control.  The registers have to be placed on the stack in
N * the order that the port expects to find them.
N *
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters, BaseType_t xRunPrivileged ) PRIVILEGED_FUNCTION;
N#else
N	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) PRIVILEGED_FUNCTION;
X	StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters ) ;
N#endif
N
N/* Used by heap_5.c. */
Ntypedef struct HeapRegion
N{
N	uint8_t *pucStartAddress;
N	size_t xSizeInBytes;
N} HeapRegion_t;
N
N/*
N * Used to define multiple heap regions for use by heap_5.c.  This function
N * must be called before any calls to pvPortMalloc() - not creating a task,
N * queue, semaphore, mutex, software timer, event group, etc. will result in
N * pvPortMalloc being called.
N *
N * pxHeapRegions passes in an array of HeapRegion_t structures - each of which
N * defines a region of memory that can be used as the heap.  The array is
N * terminated by a HeapRegions_t structure that has a size of 0.  The region
N * with the lowest start address must appear first in the array.
N */
Nvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) PRIVILEGED_FUNCTION;
Xvoid vPortDefineHeapRegions( const HeapRegion_t * const pxHeapRegions ) ;
N
N
N/*
N * Map to the memory management routines required for the port.
N */
Nvoid *pvPortMalloc( size_t xSize ) PRIVILEGED_FUNCTION;
Xvoid *pvPortMalloc( size_t xSize ) ;
Nvoid vPortFree( void *pv ) PRIVILEGED_FUNCTION;
Xvoid vPortFree( void *pv ) ;
Nvoid vPortInitialiseBlocks( void ) PRIVILEGED_FUNCTION;
Xvoid vPortInitialiseBlocks( void ) ;
Nsize_t xPortGetFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetFreeHeapSize( void ) ;
Nsize_t xPortGetMinimumEverFreeHeapSize( void ) PRIVILEGED_FUNCTION;
Xsize_t xPortGetMinimumEverFreeHeapSize( void ) ;
N
N/*
N * Setup the hardware ready for the scheduler to take control.  This generally
N * sets up a tick interrupt and sets timers for the correct tick frequency.
N */
NBaseType_t xPortStartScheduler( void ) PRIVILEGED_FUNCTION;
XBaseType_t xPortStartScheduler( void ) ;
N
N/*
N * Undo any hardware/ISR setup that was performed by xPortStartScheduler() so
N * the hardware is left in its original condition after the scheduler stops
N * executing.
N */
Nvoid vPortEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vPortEndScheduler( void ) ;
N
N/*
N * The structures and methods of manipulating the MPU are contained within the
N * port layer.
N *
N * Fills the xMPUSettings structure with the memory region information
N * contained in xRegions.
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	struct xMEMORY_REGION;
S	void vPortStoreTaskMPUSettings( xMPU_SETTINGS *xMPUSettings, const struct xMEMORY_REGION * const xRegions, StackType_t *pxBottomOfStack, uint32_t ulStackDepth ) PRIVILEGED_FUNCTION;
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* PORTABLE_H */
N
L 63 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N#include <stdlib.h>
N#include <string.h>
N#include <stdbool.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdbool.h" 1
N/* stdbool.h: ISO/IEC 9899:1999 (C99), section 7.16 */
N
N/* Copyright (C) ARM Ltd., 2002
N * All rights reserved
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: drodgman $
N */
N
N#ifndef __bool_true_false_are_defined
N#define __bool_true_false_are_defined 1
N#define __ARMCLIB_VERSION 5060037
N
N  #ifndef __cplusplus /* In C++, 'bool', 'true' and 'false' and keywords */
N    #define bool _Bool
N    #define true 1
N    #define false 0
N  #else
S    #ifdef __GNUC__
S      /* GNU C++ supports direct inclusion of stdbool.h to provide C99
S         compatibility by defining _Bool */
S      #define _Bool bool
S    #endif
N  #endif
N
N#endif /* __bool_true_false_are_defined */
N
L 66 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N#include <stdint.h>
N#include "main.h"
L 1 ".\APP\main.h" 1
N#ifndef MAIN_H
N#define MAIN_H
N
N
Nvoid INT_init(void);
N
N#endif
L 68 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N#include "..\..\..\Device_desc\TN2115s1.h"
L 1 ".\Common\RTE\RTOS\..\..\..\Device_desc\TN2115s1.h" 1
N/*
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontroller, but can be equally used for other
N * suitable processor architectures. This file can be freely distributed.
N * Modifications to this file shall be clearly marked.
N * 
N * THIS SOFTWARE IS PROVIDED "AS IS". NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N * @file     TN2115s1.h
N * @brief    CMSIS HeaderFile
N * @version  1.0
N * @date     20. August 2019
N * @note     Generated by SVDConv V3.2.66 on Tuesday, 20.08.2019 11:11:19
N *           from File 'TN2115s1.svd',
N *           last modified on Tuesday, 20.08.2019 15:10:23
N */
N
N
N
N/** @addtogroup Fusens Micro Ltd.
N  * @{
N  */
N
N
N/** @addtogroup TN2115s1
N  * @{
N  */
N
N
N#ifndef TN2115S1_H
N#define TN2115S1_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/** @addtogroup Configuration_of_CMSIS
N  * @{
N  */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                Interrupt Number Definition                                ================ */
N/* =========================================================================================================================== */
N
Ntypedef enum {
N/* =======================================  ARM Cortex-M0 Specific Interrupt Numbers  ======================================== */
N  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
N  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
N  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
N  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
N  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
N  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
N/* ==========================================  TN2115s1 Specific Interrupt Numbers  ========================================== */
N  UART_IRQn                 =   0,              /*!< 0  UART                                                                   */
N  SPI_IRQn                  =   1,              /*!< 1  SPI                                                                    */
N  I2C_IRQn                  =   2,              /*!< 2  I2C                                                                    */
N  NFCTX_IRQn                =   3,              /*!< 3  NFCTX                                                                  */
N  NFCRX_IRQn                =   4,              /*!< 4  NFCRX                                                                  */
N  NFCFIELD_IRQn             =   5,              /*!< 5  NFCFIELD                                                               */
N  TIM32_IRQn                =   6,              /*!< 6  TIM32                                                                  */
N  CAP_OK_IRQn               =   8               /*!< 8  CAP_OK                                                                 */
N} IRQn_Type;
N
N
N
N/* =========================================================================================================================== */
N/* ================                           Processor and Core Peripheral Section                           ================ */
N/* =========================================================================================================================== */
N
N/* ===========================  Configuration of the ARM Cortex-M0 Processor and Core Peripherals  =========================== */
N#define __CM0_REV                 0x0000U       /*!< CM0 Core Revision                                                         */
N#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels                                   */
N#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
N
N
N/** @} */ /* End of group Configuration_of_CMSIS */
N
N#include "core_cm0.h"                           /*!< ARM Cortex-M0 processor and core peripherals                              */
L 1 "C:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V5.0.6
N * @date     13. March 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N#include <stdint.h>
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/**
N  \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/**
N  \ingroup Cortex_M0
N  @{
N */
N
N#include "cmsis_version.h"
L 1 "C:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include\cmsis_version.h" 1
N/**************************************************************************//**
N * @file     cmsis_version.h
N * @brief    CMSIS Core(M) Version definitions
N * @version  V5.0.3
N * @date     24. June 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 ARM Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#if   defined ( __ICCARM__ )
X#if   0L
S  #pragma system_include         /* treat file as system include file for MISRA check */
S#elif defined (__clang__)
X#elif 0L
S  #pragma clang system_header   /* treat file as system include file */
N#endif
N
N#ifndef __CMSIS_VERSION_H
N#define __CMSIS_VERSION_H
N
N/*  CMSIS Version definitions */
N#define __CM_CMSIS_VERSION_MAIN  ( 5U)                                      /*!< [31:16] CMSIS Core(M) main version */
N#define __CM_CMSIS_VERSION_SUB   ( 3U)                                      /*!< [15:0]  CMSIS Core(M) sub version */
N#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) | \
N                                   __CM_CMSIS_VERSION_SUB           )       /*!< CMSIS Core(M) version number */
X#define __CM_CMSIS_VERSION       ((__CM_CMSIS_VERSION_MAIN << 16U) |                                    __CM_CMSIS_VERSION_SUB           )        
N#endif
L 64 "C:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include\core_cm0.h" 2
N 
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (__CM_CMSIS_VERSION_MAIN)              /*!< \deprecated [31:16] CMSIS HAL main version */
N#define __CM0_CMSIS_VERSION_SUB   (__CM_CMSIS_VERSION_SUB)               /*!< \deprecated [15:0]  CMSIS HAL sub version */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) | \
N                                    __CM0_CMSIS_VERSION_SUB           )  /*!< \deprecated CMSIS HAL version number */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16U) |                                     __CM0_CMSIS_VERSION_SUB           )   
N
N#define __CORTEX_M                (0U)                                   /*!< Cortex-M Core */
N
N/** __FPU_USED indicates whether an FPU is used or not.
N    This core does not support an FPU at all
N*/
N#define __FPU_USED       0U
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #if defined __ARM_FP
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TI_ARM__ )
S  #if defined __TI_VFP_SUPPORT__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __CSMC__ )
S  #if ( __CSMC__ & 0x400U)
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
N#endif
N
N#include "cmsis_compiler.h"               /* CMSIS compiler specific defines */
L 1 "C:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include\cmsis_compiler.h" 1
N/**************************************************************************//**
N * @file     cmsis_compiler.h
N * @brief    CMSIS compiler generic header file
N * @version  V5.1.0
N * @date     09. October 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_COMPILER_H
N#define __CMSIS_COMPILER_H
N
N#include <stdint.h>
N
N/*
N * Arm Compiler 4/5
N */
N#if   defined ( __CC_ARM )
X#if   1L
N  #include "cmsis_armcc.h"
L 1 "C:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include\cmsis_armcc.h" 1
N/**************************************************************************//**
N * @file     cmsis_armcc.h
N * @brief    CMSIS compiler ARMCC (Arm Compiler 5) header file
N * @version  V5.1.0
N * @date     08. May 2019
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2019 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef __CMSIS_ARMCC_H
N#define __CMSIS_ARMCC_H
N
N
N#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 400677)
X#if 1L && (5060750 < 400677)
S  #error "Please use Arm Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* CMSIS compiler control architecture macros */
N#if ((defined (__TARGET_ARCH_6_M  ) && (__TARGET_ARCH_6_M   == 1)) || \
N     (defined (__TARGET_ARCH_6S_M ) && (__TARGET_ARCH_6S_M  == 1))   )
X#if ((0L && (__TARGET_ARCH_6_M   == 1)) ||      (1L && (1  == 1))   )
N  #define __ARM_ARCH_6M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7_M ) && (__TARGET_ARCH_7_M  == 1))
X#if (0L && (__TARGET_ARCH_7_M  == 1))
S  #define __ARM_ARCH_7M__           1
N#endif
N
N#if (defined (__TARGET_ARCH_7E_M) && (__TARGET_ARCH_7E_M == 1))
X#if (0L && (__TARGET_ARCH_7E_M == 1))
S  #define __ARM_ARCH_7EM__          1
N#endif
N
N  /* __ARM_ARCH_8M_BASE__  not applicable */
N  /* __ARM_ARCH_8M_MAIN__  not applicable */
N
N/* CMSIS compiler control DSP macros */
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __ARM_FEATURE_DSP         1
N#endif
N
N/* CMSIS compiler specific defines */
N#ifndef   __ASM
N  #define __ASM                                  __asm
N#endif
N#ifndef   __INLINE
N  #define __INLINE                               __inline
N#endif
N#ifndef   __STATIC_INLINE
N  #define __STATIC_INLINE                        static __inline
N#endif
N#ifndef   __STATIC_FORCEINLINE                 
N  #define __STATIC_FORCEINLINE                   static __forceinline
N#endif           
N#ifndef   __NO_RETURN
N  #define __NO_RETURN                            __declspec(noreturn)
N#endif
N#ifndef   __USED
N  #define __USED                                 __attribute__((used))
N#endif
N#ifndef   __WEAK
N  #define __WEAK                                 __attribute__((weak))
N#endif
N#ifndef   __PACKED
N  #define __PACKED                               __attribute__((packed))
N#endif
N#ifndef   __PACKED_STRUCT
N  #define __PACKED_STRUCT                        __packed struct
N#endif
N#ifndef   __PACKED_UNION
N  #define __PACKED_UNION                         __packed union
N#endif
N#ifndef   __UNALIGNED_UINT32        /* deprecated */
N  #define __UNALIGNED_UINT32(x)                  (*((__packed uint32_t *)(x)))
N#endif
N#ifndef   __UNALIGNED_UINT16_WRITE
N  #define __UNALIGNED_UINT16_WRITE(addr, val)    ((*((__packed uint16_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT16_READ
N  #define __UNALIGNED_UINT16_READ(addr)          (*((const __packed uint16_t *)(addr)))
N#endif
N#ifndef   __UNALIGNED_UINT32_WRITE
N  #define __UNALIGNED_UINT32_WRITE(addr, val)    ((*((__packed uint32_t *)(addr))) = (val))
N#endif
N#ifndef   __UNALIGNED_UINT32_READ
N  #define __UNALIGNED_UINT32_READ(addr)          (*((const __packed uint32_t *)(addr)))
N#endif
N#ifndef   __ALIGNED
N  #define __ALIGNED(x)                           __attribute__((aligned(x)))
N#endif
N#ifndef   __RESTRICT
N  #define __RESTRICT                             __restrict
N#endif
N#ifndef   __COMPILER_BARRIER
N  #define __COMPILER_BARRIER()                   __memory_changed()
N#endif
N
N/* #########################  Startup and Lowlevel Init  ######################## */
N
N#ifndef __PROGRAM_START
N#define __PROGRAM_START           __main
N#endif
N
N#ifndef __INITIAL_SP
N#define __INITIAL_SP              Image$$ARM_LIB_STACK$$ZI$$Limit
N#endif
N
N#ifndef __STACK_LIMIT
N#define __STACK_LIMIT             Image$$ARM_LIB_STACK$$ZI$$Base
N#endif
N
N#ifndef __VECTOR_TABLE
N#define __VECTOR_TABLE            __Vectors
N#endif
N
N#ifndef __VECTOR_TABLE_ATTRIBUTE
N#define __VECTOR_TABLE_ATTRIBUTE  __attribute((used, section("RESET")))
N#endif
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N/**
N  \brief   Enable IRQ Interrupts
N  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __enable_irq();     */
N
N
N/**
N  \brief   Disable IRQ Interrupts
N  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
N           Can only be executed in Privileged modes.
N */
N/* intrinsic void __disable_irq();    */
N
N/**
N  \brief   Get Control Register
N  \details Returns the content of the Control Register.
N  \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/**
N  \brief   Set Control Register
N  \details Writes the given value to the Control Register.
N  \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/**
N  \brief   Get IPSR Register
N  \details Returns the content of the IPSR Register.
N  \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/**
N  \brief   Get APSR Register
N  \details Returns the content of the APSR Register.
N  \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/**
N  \brief   Get xPSR Register
N  \details Returns the content of the xPSR Register.
N  \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/**
N  \brief   Get Process Stack Pointer
N  \details Returns the current value of the Process Stack Pointer (PSP).
N  \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/**
N  \brief   Set Process Stack Pointer
N  \details Assigns the given value to the Process Stack Pointer (PSP).
N  \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/**
N  \brief   Get Main Stack Pointer
N  \details Returns the current value of the Main Stack Pointer (MSP).
N  \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/**
N  \brief   Set Main Stack Pointer
N  \details Assigns the given value to the Main Stack Pointer (MSP).
N  \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/**
N  \brief   Get Priority Mask
N  \details Returns the current state of the priority mask bit from the Priority Mask Register.
N  \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/**
N  \brief   Set Priority Mask
N  \details Assigns the given value to the Priority Mask Register.
N  \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   Enable FIQ
S  \details Enables FIQ interrupts by clearing the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/**
S  \brief   Disable FIQ
S  \details Disables FIQ interrupts by setting the F-bit in the CPSR.
S           Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/**
S  \brief   Get Base Priority
S  \details Returns the current value of the Base Priority register.
S  \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/**
S  \brief   Set Base Priority
S  \details Assigns the given value to the Base Priority register.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Set Base Priority with condition
S  \details Assigns the given value to the Base Priority register only if BASEPRI masking is disabled,
S           or the new value increases the BASEPRI priority level.
S  \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI_MAX(uint32_t basePri)
S{
S  register uint32_t __regBasePriMax      __ASM("basepri_max");
S  __regBasePriMax = (basePri & 0xFFU);
S}
S
S
S/**
S  \brief   Get Fault Mask
S  \details Returns the current value of the Fault Mask register.
S  \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/**
S  \brief   Set Fault Mask
S  \details Assigns the given value to the Fault Mask register.
S  \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1U);
S}
S
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N
N/**
N  \brief   Get FPSCR
N  \details Returns the current value of the Floating Point Status/Control register.
N  \return               Floating Point Status/Control register value
N */
N__STATIC_INLINE uint32_t __get_FPSCR(void)
Xstatic __inline uint32_t __get_FPSCR(void)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
N#else
N   return(0U);
N#endif
N}
N
N
N/**
N  \brief   Set FPSCR
N  \details Assigns the given value to the Floating Point Status/Control register.
N  \param [in]    fpscr  Floating Point Status/Control value to set
N */
N__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
Xstatic __inline void __set_FPSCR(uint32_t fpscr)
N{
N#if ((defined (__FPU_PRESENT) && (__FPU_PRESENT == 1U)) && \
N     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
X#if ((0L && (__FPU_PRESENT == 1U)) &&      (1L && (0U    == 1U))     )
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
N#else
N  (void)fpscr;
N#endif
N}
N
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N/**
N  \brief   No Operation
N  \details No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/**
N  \brief   Wait For Interrupt
N  \details Wait For Interrupt is a hint instruction that suspends execution until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/**
N  \brief   Wait For Event
N  \details Wait For Event is a hint instruction that permits the processor to enter
N           a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/**
N  \brief   Send Event
N  \details Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/**
N  \brief   Instruction Synchronization Barrier
N  \details Instruction Synchronization Barrier flushes the pipeline in the processor,
N           so that all instructions following the ISB are fetched from cache or memory,
N           after the instruction has been completed.
N */
N#define __ISB() do {\
N                   __schedule_barrier();\
N                   __isb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __ISB() do {                   __schedule_barrier();                   __isb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Synchronization Barrier
N  \details Acts as a special kind of Data Memory Barrier.
N           It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB() do {\
N                   __schedule_barrier();\
N                   __dsb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DSB() do {                   __schedule_barrier();                   __dsb(0xF);                   __schedule_barrier();                } while (0U)
N
N/**
N  \brief   Data Memory Barrier
N  \details Ensures the apparent order of the explicit memory operations before
N           and after the instruction, without ensuring their completion.
N */
N#define __DMB() do {\
N                   __schedule_barrier();\
N                   __dmb(0xF);\
N                   __schedule_barrier();\
N                } while (0U)
X#define __DMB() do {                   __schedule_barrier();                   __dmb(0xF);                   __schedule_barrier();                } while (0U)
N
N                  
N/**
N  \brief   Reverse byte order (32 bit)
N  \details Reverses the byte order in unsigned integer value. For example, 0x12345678 becomes 0x78563412.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order within each halfword of a word. For example, 0x12345678 becomes 0x34127856.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Reverse byte order (16 bit)
N  \details Reverses the byte order in a 16-bit value and returns the signed 16-bit result. For example, 0x0080 becomes 0x8000.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#ifndef __NO_EMBEDDED_ASM
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int16_t __REVSH(int16_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int16_t __REVSH(int16_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N#endif
N
N
N/**
N  \brief   Rotate Right in unsigned value (32 bit)
N  \details Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N  \param [in]    op1  Value to rotate
N  \param [in]    op2  Number of Bits to rotate
N  \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N/**
N  \brief   Breakpoint
N  \details Causes the processor to enter Debug state.
N           Debug tools can use this to investigate system state when the instruction at a particular address is reached.
N  \param [in]    value  is ignored by the processor.
N                 If required, a debugger can use it to store additional information about the breakpoint.
N */
N#define __BKPT(value)                       __breakpoint(value)
N
N
N/**
N  \brief   Reverse bit order of value
N  \details Reverses the bit order of the given value.
N  \param [in]    value  Value to reverse
N  \return               Reversed value
N */
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S  #define __RBIT                          __rbit
N#else
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
X__attribute__((always_inline)) static __inline uint32_t __RBIT(uint32_t value)
N{
N  uint32_t result;
N  uint32_t s = (4U /*sizeof(v)*/ * 8U) - 1U; /* extra shift needed at end */
N
N  result = value;                      /* r will be reversed bits of v; first get LSB of v */
N  for (value >>= 1U; value != 0U; value >>= 1U)
N  {
N    result <<= 1U;
N    result |= value & 1U;
N    s--;
N  }
N  result <<= s;                        /* shift when v's highest bits are zero */
N  return result;
N}
N#endif
N
N
N/**
N  \brief   Count leading zeros
N  \details Counts the number of leading zeros of a data value.
N  \param [in]  value  Value to count the leading zeros
N  \return             number of leading zeros in value
N */
N#define __CLZ                             __clz
N
N
N#if ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N     (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7M__  == 1)) ||      (0L && (__ARM_ARCH_7EM__ == 1))     )
S
S/**
S  \brief   LDR Exclusive (8 bit)
S  \details Executes a exclusive LDR instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXB(ptr)                                                        ((uint8_t ) __ldrex(ptr))
S#else
S  #define __LDREXB(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint8_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (16 bit)
S  \details Executes a exclusive LDR instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXH(ptr)                                                        ((uint16_t) __ldrex(ptr))
S#else
S  #define __LDREXH(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint16_t) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   LDR Exclusive (32 bit)
S  \details Executes a exclusive LDR instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __LDREXW(ptr)                                                        ((uint32_t ) __ldrex(ptr))
S#else
S  #define __LDREXW(ptr)          _Pragma("push") _Pragma("diag_suppress 3731") ((uint32_t ) __ldrex(ptr))  _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (8 bit)
S  \details Executes a exclusive STR instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXB(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXB(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (16 bit)
S  \details Executes a exclusive STR instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXH(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXH(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   STR Exclusive (32 bit)
S  \details Executes a exclusive STR instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S  \return          0  Function succeeded
S  \return          1  Function failed
S */
S#if defined(__ARMCC_VERSION) && (__ARMCC_VERSION < 5060020)
S  #define __STREXW(value, ptr)                                                 __strex(value, ptr)
S#else
S  #define __STREXW(value, ptr)   _Pragma("push") _Pragma("diag_suppress 3731") __strex(value, ptr)        _Pragma("pop")
S#endif
S
S
S/**
S  \brief   Remove the exclusive lock
S  \details Removes the exclusive lock which is created by LDREX.
S */
S#define __CLREX                           __clrex
S
S
S/**
S  \brief   Signed Saturate
S  \details Saturates a signed value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (1..32)
S  \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/**
S  \brief   Unsigned Saturate
S  \details Saturates an unsigned value.
S  \param [in]  value  Value to be saturated
S  \param [in]    sat  Bit position to saturate to (0..31)
S  \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/**
S  \brief   Rotate Right with Extend (32 bit)
S  \details Moves each bit of a bitstring right by one bit.
S           The carry input is shifted in at the left end of the bitstring.
S  \param [in]    value  Value to rotate
S  \return               Rotated value
S */
S#ifndef __NO_EMBEDDED_ASM
S__attribute__((section(".rrx_text"))) __STATIC_INLINE __ASM uint32_t __RRX(uint32_t value)
S{
S  rrx r0, r0
S  bx lr
S}
S#endif
S
S
S/**
S  \brief   LDRT Unprivileged (8 bit)
S  \details Executes a Unprivileged LDRT instruction for 8 bit value.
S  \param [in]    ptr  Pointer to data
S  \return             value of type uint8_t at (*ptr)
S */
S#define __LDRBT(ptr)                      ((uint8_t )  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (16 bit)
S  \details Executes a Unprivileged LDRT instruction for 16 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint16_t at (*ptr)
S */
S#define __LDRHT(ptr)                      ((uint16_t)  __ldrt(ptr))
S
S
S/**
S  \brief   LDRT Unprivileged (32 bit)
S  \details Executes a Unprivileged LDRT instruction for 32 bit values.
S  \param [in]    ptr  Pointer to data
S  \return        value of type uint32_t at (*ptr)
S */
S#define __LDRT(ptr)                       ((uint32_t ) __ldrt(ptr))
S
S
S/**
S  \brief   STRT Unprivileged (8 bit)
S  \details Executes a Unprivileged STRT instruction for 8 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRBT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (16 bit)
S  \details Executes a Unprivileged STRT instruction for 16 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRHT(value, ptr)               __strt(value, ptr)
S
S
S/**
S  \brief   STRT Unprivileged (32 bit)
S  \details Executes a Unprivileged STRT instruction for 32 bit values.
S  \param [in]  value  Value to store
S  \param [in]    ptr  Pointer to location
S */
S#define __STRT(value, ptr)                __strt(value, ptr)
S
N#else  /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#else   
N
N/**
N  \brief   Signed Saturate
N  \details Saturates a signed value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (1..32)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE int32_t __SSAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline int32_t __SSAT(int32_t val, uint32_t sat)
N{
N  if ((sat >= 1U) && (sat <= 32U))
N  {
N    const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
N    const int32_t min = -1 - max ;
N    if (val > max)
N    {
N      return max;
N    }
N    else if (val < min)
N    {
N      return min;
N    }
N  }
N  return val;
N}
N
N/**
N  \brief   Unsigned Saturate
N  \details Saturates an unsigned value.
N  \param [in]  value  Value to be saturated
N  \param [in]    sat  Bit position to saturate to (0..31)
N  \return             Saturated value
N */
N__attribute__((always_inline)) __STATIC_INLINE uint32_t __USAT(int32_t val, uint32_t sat)
X__attribute__((always_inline)) static __inline uint32_t __USAT(int32_t val, uint32_t sat)
N{
N  if (sat <= 31U)
N  {
N    const uint32_t max = ((1U << sat) - 1U);
N    if (val > (int32_t)max)
N    {
N      return max;
N    }
N    else if (val < 0)
N    {
N      return 0U;
N    }
N  }
N  return (uint32_t)val;
N}
N
N#endif /* ((defined (__ARM_ARCH_7M__ ) && (__ARM_ARCH_7M__  == 1)) || \
N           (defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
X#endif  
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N
N/* ###################  Compiler specific Intrinsics  ########################### */
N/** \defgroup CMSIS_SIMD_intrinsics CMSIS SIMD Intrinsics
N  Access to dedicated SIMD instructions
N  @{
N*/
N
N#if ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     )
X#if ((0L && (__ARM_ARCH_7EM__ == 1))     )
S
S#define __SADD8                           __sadd8
S#define __QADD8                           __qadd8
S#define __SHADD8                          __shadd8
S#define __UADD8                           __uadd8
S#define __UQADD8                          __uqadd8
S#define __UHADD8                          __uhadd8
S#define __SSUB8                           __ssub8
S#define __QSUB8                           __qsub8
S#define __SHSUB8                          __shsub8
S#define __USUB8                           __usub8
S#define __UQSUB8                          __uqsub8
S#define __UHSUB8                          __uhsub8
S#define __SADD16                          __sadd16
S#define __QADD16                          __qadd16
S#define __SHADD16                         __shadd16
S#define __UADD16                          __uadd16
S#define __UQADD16                         __uqadd16
S#define __UHADD16                         __uhadd16
S#define __SSUB16                          __ssub16
S#define __QSUB16                          __qsub16
S#define __SHSUB16                         __shsub16
S#define __USUB16                          __usub16
S#define __UQSUB16                         __uqsub16
S#define __UHSUB16                         __uhsub16
S#define __SASX                            __sasx
S#define __QASX                            __qasx
S#define __SHASX                           __shasx
S#define __UASX                            __uasx
S#define __UQASX                           __uqasx
S#define __UHASX                           __uhasx
S#define __SSAX                            __ssax
S#define __QSAX                            __qsax
S#define __SHSAX                           __shsax
S#define __USAX                            __usax
S#define __UQSAX                           __uqsax
S#define __UHSAX                           __uhsax
S#define __USAD8                           __usad8
S#define __USADA8                          __usada8
S#define __SSAT16                          __ssat16
S#define __USAT16                          __usat16
S#define __UXTB16                          __uxtb16
S#define __UXTAB16                         __uxtab16
S#define __SXTB16                          __sxtb16
S#define __SXTAB16                         __sxtab16
S#define __SMUAD                           __smuad
S#define __SMUADX                          __smuadx
S#define __SMLAD                           __smlad
S#define __SMLADX                          __smladx
S#define __SMLALD                          __smlald
S#define __SMLALDX                         __smlaldx
S#define __SMUSD                           __smusd
S#define __SMUSDX                          __smusdx
S#define __SMLSD                           __smlsd
S#define __SMLSDX                          __smlsdx
S#define __SMLSLD                          __smlsld
S#define __SMLSLDX                         __smlsldx
S#define __SEL                             __sel
S#define __QADD                            __qadd
S#define __QSUB                            __qsub
S
S#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |  \
S                                           ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
X#define __PKHBT(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0x0000FFFFUL) |                                             ((((uint32_t)(ARG2)) << (ARG3)) & 0xFFFF0000UL)  )
S
S#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |  \
S                                           ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
X#define __PKHTB(ARG1,ARG2,ARG3)          ( ((((uint32_t)(ARG1))          ) & 0xFFFF0000UL) |                                             ((((uint32_t)(ARG2)) >> (ARG3)) & 0x0000FFFFUL)  )
S
S#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) + \
S                                                      ((int64_t)(ARG3) << 32U)     ) >> 32U))
X#define __SMMLA(ARG1,ARG2,ARG3)          ( (int32_t)((((int64_t)(ARG1) * (ARG2)) +                                                       ((int64_t)(ARG3) << 32U)     ) >> 32U))
S
N#endif /* ((defined (__ARM_ARCH_7EM__) && (__ARM_ARCH_7EM__ == 1))     ) */
N/*@} end of group CMSIS_SIMD_intrinsics */
N
N
N#endif /* __CMSIS_ARMCC_H */
L 35 "C:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include\cmsis_compiler.h" 2
N
N
N/*
N * Arm Compiler 6.6 LTM (armclang)
N */
N#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050) && (__ARMCC_VERSION < 6100100)
S  #include "cmsis_armclang_ltm.h"
S
S  /*
S * Arm Compiler above 6.10.1 (armclang)
S */
S#elif defined (__ARMCC_VERSION) && (__ARMCC_VERSION >= 6100100)
S  #include "cmsis_armclang.h"
S
S
S/*
S * GNU Compiler
S */
S#elif defined ( __GNUC__ )
S  #include "cmsis_gcc.h"
S
S
S/*
S * IAR Compiler
S */
S#elif defined ( __ICCARM__ )
S  #include <cmsis_iccarm.h>
S
S
S/*
S * TI Arm Compiler
S */
S#elif defined ( __TI_ARM__ )
S  #include <cmsis_ccs.h>
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __attribute__((packed))
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __attribute__((packed))
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __attribute__((packed)) T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void*)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)                           __attribute__((aligned(x)))
S  #endif
S  #ifndef   __RESTRICT
S    #define __RESTRICT                             __restrict
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * TASKING Compiler
S */
S#elif defined ( __TASKING__ )
S  /*
S   * The CMSIS functions have been implemented as intrinsics in the compiler.
S   * Please use "carm -?i" to get an up to date list of all intrinsics,
S   * Including the CMSIS ones.
S   */
S
S  #ifndef   __ASM
S    #define __ASM                                  __asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    #define __NO_RETURN                            __attribute__((noreturn))
S  #endif
S  #ifndef   __USED
S    #define __USED                                 __attribute__((used))
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __attribute__((weak))
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               __packed__
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        struct __packed__
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         union __packed__
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    struct __packed__ T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #define __ALIGNED(x)              __align(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S/*
S * COSMIC Compiler
S */
S#elif defined ( __CSMC__ )
S   #include <cmsis_csm.h>
S
S #ifndef   __ASM
S    #define __ASM                                  _asm
S  #endif
S  #ifndef   __INLINE
S    #define __INLINE                               inline
S  #endif
S  #ifndef   __STATIC_INLINE
S    #define __STATIC_INLINE                        static inline
S  #endif
S  #ifndef   __STATIC_FORCEINLINE
S    #define __STATIC_FORCEINLINE                   __STATIC_INLINE
S  #endif
S  #ifndef   __NO_RETURN
S    // NO RETURN is automatically detected hence no warning here
S    #define __NO_RETURN
S  #endif
S  #ifndef   __USED
S    #warning No compiler specific solution for __USED. __USED is ignored.
S    #define __USED
S  #endif
S  #ifndef   __WEAK
S    #define __WEAK                                 __weak
S  #endif
S  #ifndef   __PACKED
S    #define __PACKED                               @packed
S  #endif
S  #ifndef   __PACKED_STRUCT
S    #define __PACKED_STRUCT                        @packed struct
S  #endif
S  #ifndef   __PACKED_UNION
S    #define __PACKED_UNION                         @packed union
S  #endif
S  #ifndef   __UNALIGNED_UINT32        /* deprecated */
S    @packed struct T_UINT32 { uint32_t v; };
S    #define __UNALIGNED_UINT32(x)                  (((struct T_UINT32 *)(x))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT16_WRITE
S    __PACKED_STRUCT T_UINT16_WRITE { uint16_t v; };
S    #define __UNALIGNED_UINT16_WRITE(addr, val)    (void)((((struct T_UINT16_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT16_READ
S    __PACKED_STRUCT T_UINT16_READ { uint16_t v; };
S    #define __UNALIGNED_UINT16_READ(addr)          (((const struct T_UINT16_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __UNALIGNED_UINT32_WRITE
S    __PACKED_STRUCT T_UINT32_WRITE { uint32_t v; };
S    #define __UNALIGNED_UINT32_WRITE(addr, val)    (void)((((struct T_UINT32_WRITE *)(void *)(addr))->v) = (val))
S  #endif
S  #ifndef   __UNALIGNED_UINT32_READ
S    __PACKED_STRUCT T_UINT32_READ { uint32_t v; };
S    #define __UNALIGNED_UINT32_READ(addr)          (((const struct T_UINT32_READ *)(const void *)(addr))->v)
S  #endif
S  #ifndef   __ALIGNED
S    #warning No compiler specific solution for __ALIGNED. __ALIGNED is ignored.
S    #define __ALIGNED(x)
S  #endif
S  #ifndef   __RESTRICT
S    #warning No compiler specific solution for __RESTRICT. __RESTRICT is ignored.
S    #define __RESTRICT
S  #endif
S  #ifndef   __COMPILER_BARRIER
S    #warning No compiler specific solution for __COMPILER_BARRIER. __COMPILER_BARRIER is ignored.
S    #define __COMPILER_BARRIER()                   (void)0
S  #endif
S
S
S#else
S  #error Unknown compiler.
N#endif
N
N
N#endif /* __CMSIS_COMPILER_H */
N
L 116 "C:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include\core_cm0.h" 2
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000U
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2U
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0U
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions */
N
N/* following defines should be used for structure members */
N#define     __IM     volatile const      /*! Defines 'read only' structure member permissions */
N#define     __OM     volatile            /*! Defines 'write only' structure member permissions */
N#define     __IOM    volatile            /*! Defines 'read / write' structure member permissions */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/**
N  \defgroup CMSIS_core_register Defines and Type Definitions
N  \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_CORE  Status and Control Registers
N  \brief      Core Register type definitions.
N  @{
N */
N
N/**
N  \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:28;              /*!< bit:  0..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} APSR_Type;
N
N/* APSR Register Definitions */
N#define APSR_N_Pos                         31U                                            /*!< APSR: N Position */
N#define APSR_N_Msk                         (1UL << APSR_N_Pos)                            /*!< APSR: N Mask */
N
N#define APSR_Z_Pos                         30U                                            /*!< APSR: Z Position */
N#define APSR_Z_Msk                         (1UL << APSR_Z_Pos)                            /*!< APSR: Z Mask */
N
N#define APSR_C_Pos                         29U                                            /*!< APSR: C Position */
N#define APSR_C_Msk                         (1UL << APSR_C_Pos)                            /*!< APSR: C Mask */
N
N#define APSR_V_Pos                         28U                                            /*!< APSR: V Position */
N#define APSR_V_Msk                         (1UL << APSR_V_Pos)                            /*!< APSR: V Mask */
N
N
N/**
N  \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} IPSR_Type;
N
N/* IPSR Register Definitions */
N#define IPSR_ISR_Pos                        0U                                            /*!< IPSR: ISR Position */
N#define IPSR_ISR_Msk                       (0x1FFUL /*<< IPSR_ISR_Pos*/)                  /*!< IPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number */
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved */
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0) */
N    uint32_t _reserved1:3;               /*!< bit: 25..27  Reserved */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} xPSR_Type;
N
N/* xPSR Register Definitions */
N#define xPSR_N_Pos                         31U                                            /*!< xPSR: N Position */
N#define xPSR_N_Msk                         (1UL << xPSR_N_Pos)                            /*!< xPSR: N Mask */
N
N#define xPSR_Z_Pos                         30U                                            /*!< xPSR: Z Position */
N#define xPSR_Z_Msk                         (1UL << xPSR_Z_Pos)                            /*!< xPSR: Z Mask */
N
N#define xPSR_C_Pos                         29U                                            /*!< xPSR: C Position */
N#define xPSR_C_Msk                         (1UL << xPSR_C_Pos)                            /*!< xPSR: C Mask */
N
N#define xPSR_V_Pos                         28U                                            /*!< xPSR: V Position */
N#define xPSR_V_Msk                         (1UL << xPSR_V_Pos)                            /*!< xPSR: V Mask */
N
N#define xPSR_T_Pos                         24U                                            /*!< xPSR: T Position */
N#define xPSR_T_Msk                         (1UL << xPSR_T_Pos)                            /*!< xPSR: T Mask */
N
N#define xPSR_ISR_Pos                        0U                                            /*!< xPSR: ISR Position */
N#define xPSR_ISR_Msk                       (0x1FFUL /*<< xPSR_ISR_Pos*/)                  /*!< xPSR: ISR Mask */
N
N
N/**
N  \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t _reserved0:1;               /*!< bit:      0  Reserved */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used */
N    uint32_t _reserved1:30;              /*!< bit:  2..31  Reserved */
N  } b;                                   /*!< Structure used for bit  access */
N  uint32_t w;                            /*!< Type      used for word access */
N} CONTROL_Type;
N
N/* CONTROL Register Definitions */
N#define CONTROL_SPSEL_Pos                   1U                                            /*!< CONTROL: SPSEL Position */
N#define CONTROL_SPSEL_Msk                  (1UL << CONTROL_SPSEL_Pos)                     /*!< CONTROL: SPSEL Mask */
N
N/*@} end of group CMSIS_CORE */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N  \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IOM uint32_t ISER[1U];               /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register */
X  volatile uint32_t ISER[1U];                
N        uint32_t RESERVED0[31U];
N  __IOM uint32_t ICER[1U];               /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register */
X  volatile uint32_t ICER[1U];                
N        uint32_t RESERVED1[31U];
N  __IOM uint32_t ISPR[1U];               /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register */
X  volatile uint32_t ISPR[1U];                
N        uint32_t RESERVED2[31U];
N  __IOM uint32_t ICPR[1U];               /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register */
X  volatile uint32_t ICPR[1U];                
N        uint32_t RESERVED3[31U];
N        uint32_t RESERVED4[64U];
N  __IOM uint32_t IP[8U];                 /*!< Offset: 0x300 (R/W)  Interrupt Priority Register */
X  volatile uint32_t IP[8U];                  
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SCB     System Control Block (SCB)
N  \brief    Type definitions for the System Control Block Registers
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __IM  uint32_t CPUID;                  /*!< Offset: 0x000 (R/ )  CPUID Base Register */
X  volatile const  uint32_t CPUID;                   
N  __IOM uint32_t ICSR;                   /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register */
X  volatile uint32_t ICSR;                    
N        uint32_t RESERVED0;
N  __IOM uint32_t AIRCR;                  /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register */
X  volatile uint32_t AIRCR;                   
N  __IOM uint32_t SCR;                    /*!< Offset: 0x010 (R/W)  System Control Register */
X  volatile uint32_t SCR;                     
N  __IOM uint32_t CCR;                    /*!< Offset: 0x014 (R/W)  Configuration Control Register */
X  volatile uint32_t CCR;                     
N        uint32_t RESERVED1;
N  __IOM uint32_t SHP[2U];                /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED */
X  volatile uint32_t SHP[2U];                 
N  __IOM uint32_t SHCSR;                  /*!< Offset: 0x024 (R/W)  System Handler Control and State Register */
X  volatile uint32_t SHCSR;                   
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24U                                            /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20U                                            /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16U                                            /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4U                                            /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0U                                            /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL /*<< SCB_CPUID_REVISION_Pos*/)          /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31U                                            /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28U                                            /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27U                                            /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26U                                            /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25U                                            /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23U                                            /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22U                                            /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12U                                            /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0U                                            /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL /*<< SCB_ICSR_VECTACTIVE_Pos*/)       /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16U                                            /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16U                                            /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15U                                            /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2U                                            /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1U                                            /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4U                                            /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2U                                            /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1U                                            /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9U                                            /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3U                                            /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15U                                            /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N  \brief    Type definitions for the System Timer Registers.
N  @{
N */
N
N/**
N  \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IOM uint32_t CTRL;                   /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                    
N  __IOM uint32_t LOAD;                   /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register */
X  volatile uint32_t LOAD;                    
N  __IOM uint32_t VAL;                    /*!< Offset: 0x008 (R/W)  SysTick Current Value Register */
X  volatile uint32_t VAL;                     
N  __IM  uint32_t CALIB;                  /*!< Offset: 0x00C (R/ )  SysTick Calibration Register */
X  volatile const  uint32_t CALIB;                   
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16U                                            /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2U                                            /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1U                                            /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0U                                            /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL /*<< SysTick_CTRL_ENABLE_Pos*/)           /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0U                                            /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL /*<< SysTick_LOAD_RELOAD_Pos*/)    /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0U                                            /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL /*<< SysTick_VAL_CURRENT_Pos*/)    /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31U                                            /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30U                                            /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0U                                            /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL /*<< SysTick_CALIB_TENMS_Pos*/)    /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/**
N  \ingroup  CMSIS_core_register
N  \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N  \brief    Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR) are only accessible over DAP and not via processor.
N            Therefore they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_bitfield     Core register bit field macros
N  \brief      Macros for use with bit field definitions (xxx_Pos, xxx_Msk).
N  @{
N */
N
N/**
N  \brief   Mask and shift a bit field value for use in a register bit range.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of the bit field. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted value.
N*/
N#define _VAL2FLD(field, value)    (((uint32_t)(value) << field ## _Pos) & field ## _Msk)
N
N/**
N  \brief     Mask and shift a register value to extract a bit filed value.
N  \param[in] field  Name of the register bit field.
N  \param[in] value  Value of register. This parameter is interpreted as an uint32_t type.
N  \return           Masked and shifted bit field value.
N*/
N#define _FLD2VAL(field, value)    (((uint32_t)(value) & field ## _Msk) >> field ## _Pos)
N
N/*@} end of group CMSIS_core_bitfield */
N
N
N/**
N  \ingroup    CMSIS_core_register
N  \defgroup   CMSIS_core_base     Core Definitions
N  \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Core Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/**
N  \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N  \brief    Functions that manage interrupts and exceptions via the NVIC.
N  @{
N */
N
N#ifdef CMSIS_NVIC_VIRTUAL
S  #ifndef CMSIS_NVIC_VIRTUAL_HEADER_FILE
S    #define CMSIS_NVIC_VIRTUAL_HEADER_FILE "cmsis_nvic_virtual.h"
S  #endif
S  #include CMSIS_NVIC_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetPriorityGrouping    __NVIC_SetPriorityGrouping
N  #define NVIC_GetPriorityGrouping    __NVIC_GetPriorityGrouping
N  #define NVIC_EnableIRQ              __NVIC_EnableIRQ
N  #define NVIC_GetEnableIRQ           __NVIC_GetEnableIRQ
N  #define NVIC_DisableIRQ             __NVIC_DisableIRQ
N  #define NVIC_GetPendingIRQ          __NVIC_GetPendingIRQ
N  #define NVIC_SetPendingIRQ          __NVIC_SetPendingIRQ
N  #define NVIC_ClearPendingIRQ        __NVIC_ClearPendingIRQ
N/*#define NVIC_GetActive              __NVIC_GetActive             not available for Cortex-M0 */
N  #define NVIC_SetPriority            __NVIC_SetPriority
N  #define NVIC_GetPriority            __NVIC_GetPriority
N  #define NVIC_SystemReset            __NVIC_SystemReset
N#endif /* CMSIS_NVIC_VIRTUAL */
N
N#ifdef CMSIS_VECTAB_VIRTUAL
S  #ifndef CMSIS_VECTAB_VIRTUAL_HEADER_FILE
S    #define CMSIS_VECTAB_VIRTUAL_HEADER_FILE "cmsis_vectab_virtual.h"
S  #endif
S  #include CMSIS_VECTAB_VIRTUAL_HEADER_FILE
N#else
N  #define NVIC_SetVector              __NVIC_SetVector
N  #define NVIC_GetVector              __NVIC_GetVector
N#endif  /* (CMSIS_VECTAB_VIRTUAL) */
N
N#define NVIC_USER_IRQ_OFFSET          16
N
N
N/* The following EXC_RETURN values are saved the LR on exception entry */
N#define EXC_RETURN_HANDLER         (0xFFFFFFF1UL)     /* return to Handler mode, uses MSP after return                               */
N#define EXC_RETURN_THREAD_MSP      (0xFFFFFFF9UL)     /* return to Thread mode, uses MSP after return                                */
N#define EXC_RETURN_THREAD_PSP      (0xFFFFFFFDUL)     /* return to Thread mode, uses PSP after return                                */
N
N
N/* Interrupt Priorities are WORD accessible only under Armv6-M                  */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  ((((uint32_t)(int32_t)(IRQn))         )      &  0x03UL) * 8UL)
N#define _SHP_IDX(IRQn)           ( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >>    2UL)      )
N#define _IP_IDX(IRQn)            (   (((uint32_t)(int32_t)(IRQn))                >>    2UL)      )
N
N#define __NVIC_SetPriorityGrouping(X) (void)(X)
N#define __NVIC_GetPriorityGrouping()  (0U)
N
N/**
N  \brief   Enable Interrupt
N  \details Enables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    __COMPILER_BARRIER();
X    __memory_changed();
N    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __COMPILER_BARRIER();
X    __memory_changed();
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Enable status
N  \details Returns a device specific interrupt enable status from the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt is not enabled.
N  \return             1  Interrupt is enabled.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetEnableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Disable Interrupt
N  \details Disables a device specific interrupt in the NVIC interrupt controller.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N    __DSB();
X    do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);
N    __ISB();
X    do { __schedule_barrier(); __isb(0xF); __schedule_barrier(); } while (0U);
N  }
N}
N
N
N/**
N  \brief   Get Pending Interrupt
N  \details Reads the NVIC pending register and returns the pending bit for the specified device specific interrupt.
N  \param [in]      IRQn  Device specific interrupt number.
N  \return             0  Interrupt status is not pending.
N  \return             1  Interrupt status is pending.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] & (1UL << (((uint32_t)IRQn) & 0x1FUL))) != 0UL) ? 1UL : 0UL));
N  }
N  else
N  {
N    return(0U);
N  }
N}
N
N
N/**
N  \brief   Set Pending Interrupt
N  \details Sets the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Clear Pending Interrupt
N  \details Clears the pending bit of a device specific interrupt in the NVIC pending register.
N  \param [in]      IRQn  Device specific interrupt number.
N  \note    IRQn must not be negative.
N */
N__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
N  }
N}
N
N
N/**
N  \brief   Set Interrupt Priority
N  \details Sets the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]      IRQn  Interrupt number.
N  \param [in]  priority  Priority to set.
N  \note    The priority cannot be set for every processor exception.
N */
N__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if ((int32_t)(IRQn) >= 0)
N  {
N    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  = ((uint32_t)(((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )]  & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N  else
N  {
N    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] = ((uint32_t)(((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] & ~(0xFFUL << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL))) |
N       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
X       (((priority << (8U - 2)) & (uint32_t)0xFFUL) << ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL)));
N  }
N}
N
N
N/**
N  \brief   Get Interrupt Priority
N  \details Reads the priority of a device specific interrupt or a processor exception.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn  Interrupt number.
N  \return             Interrupt Priority.
N                      Value is aligned automatically to the implemented priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if ((int32_t)(IRQn) >= 0)
N  {
N    return((uint32_t)(((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( (((uint32_t)(int32_t)(IRQn)) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N  else
N  {
N    return((uint32_t)(((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) & (uint32_t)0xFFUL) >> (8U - __NVIC_PRIO_BITS)));
X    return((uint32_t)(((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( (((((uint32_t)(int32_t)(IRQn)) & 0x0FUL)-8UL) >> 2UL) )] >> ( ((((uint32_t)(int32_t)(IRQn)) ) & 0x03UL) * 8UL) ) & (uint32_t)0xFFUL) >> (8U - 2)));
N  }
N}
N
N
N/**
N  \brief   Encode Priority
N  \details Encodes the priority for an interrupt with the given priority group,
N           preemptive priority value, and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
N  \param [in]     PriorityGroup  Used priority group.
N  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
N  \param [in]       SubPriority  Subpriority value (starting from 0).
N  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
N */
N__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
Xstatic __inline uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2)) ? (uint32_t)(2) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2));
N
N  return (
N           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
N           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
N         );
N}
N
N
N/**
N  \brief   Decode Priority
N  \details Decodes an interrupt priority value with a given priority group to
N           preemptive priority value and subpriority value.
N           In case of a conflict between priority grouping and available
N           priority bits (__NVIC_PRIO_BITS) the smallest possible priority group is set.
N  \param [in]         Priority   Priority value, which can be retrieved with the function \ref NVIC_GetPriority().
N  \param [in]     PriorityGroup  Used priority group.
N  \param [out] pPreemptPriority  Preemptive priority value (starting from 0).
N  \param [out]     pSubPriority  Subpriority value (starting from 0).
N */
N__STATIC_INLINE void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
Xstatic __inline void NVIC_DecodePriority (uint32_t Priority, uint32_t PriorityGroup, uint32_t* const pPreemptPriority, uint32_t* const pSubPriority)
N{
N  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
N  uint32_t PreemptPriorityBits;
N  uint32_t SubPriorityBits;
N
N  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
X  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(2)) ? (uint32_t)(2) : (uint32_t)(7UL - PriorityGroupTmp);
N  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
X  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(2)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(2));
N
N  *pPreemptPriority = (Priority >> SubPriorityBits) & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL);
N  *pSubPriority     = (Priority                   ) & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL);
N}
N
N
N
N/**
N  \brief   Set Interrupt Vector
N  \details Sets an interrupt vector in SRAM based interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N           Address 0 must be mapped to SRAM.
N  \param [in]   IRQn      Interrupt number
N  \param [in]   vector    Address of interrupt handler function
N */
N__STATIC_INLINE void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
Xstatic __inline void __NVIC_SetVector(IRQn_Type IRQn, uint32_t vector)
N{
N  uint32_t vectors = 0x0U;
N  (* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4)) = vector;
X  (* (int *) (vectors + ((int32_t)IRQn + 16) * 4)) = vector;
N  /* ARM Application Note 321 states that the M0 does not require the architectural barrier */
N}
N
N
N/**
N  \brief   Get Interrupt Vector
N  \details Reads an interrupt vector from interrupt vector table.
N           The interrupt number can be positive to specify a device specific interrupt,
N           or negative to specify a processor exception.
N  \param [in]   IRQn      Interrupt number.
N  \return                 Address of interrupt handler function
N */
N__STATIC_INLINE uint32_t __NVIC_GetVector(IRQn_Type IRQn)
Xstatic __inline uint32_t __NVIC_GetVector(IRQn_Type IRQn)
N{
N  uint32_t vectors = 0x0U;
N  return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + NVIC_USER_IRQ_OFFSET) * 4));
X  return (uint32_t)(* (int *) (vectors + ((int32_t)IRQn + 16) * 4));
N}
N
N
N/**
N  \brief   System Reset
N  \details Initiates a system reset request to reset the MCU.
N */
N__NO_RETURN __STATIC_INLINE void __NVIC_SystemReset(void)
X__declspec(noreturn) static __inline void __NVIC_SystemReset(void)
N{
N  __DSB();                                                          /* Ensure all outstanding memory accesses included
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                          
N                                                                       buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FAUL << 16U) |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2U));
N  __DSB();                                                          /* Ensure completion of memory access */
X  do { __schedule_barrier(); __dsb(0xF); __schedule_barrier(); } while (0U);                                                           
N
N  for(;;)                                                           /* wait until reset */
N  {
N    __NOP();
X    __nop();
N  }
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N/* ##########################  FPU functions  #################################### */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_FpuFunctions FPU Functions
N  \brief    Function that provides FPU type.
N  @{
N */
N
N/**
N  \brief   get FPU type
N  \details returns the FPU type
N  \returns
N   - \b  0: No FPU
N   - \b  1: Single precision FPU
N   - \b  2: Double + Single precision FPU
N */
N__STATIC_INLINE uint32_t SCB_GetFPUType(void)
Xstatic __inline uint32_t SCB_GetFPUType(void)
N{
N    return 0U;           /* No FPU */
N}
N
N
N/*@} end of CMSIS_Core_FpuFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/**
N  \ingroup  CMSIS_Core_FunctionInterface
N  \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N  \brief    Functions that configure the System.
N  @{
N */
N
N#if defined (__Vendor_SysTickConfig) && (__Vendor_SysTickConfig == 0U)
X#if 1L && (0 == 0U)
N
N/**
N  \brief   System Tick Configuration
N  \details Initializes the System Timer and its interrupt, and starts the System Tick Timer.
N           Counter is in free running mode to generate periodic interrupts.
N  \param [in]  ticks  Number of ticks between two interrupts.
N  \return          0  Function succeeded.
N  \return          1  Function failed.
N  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N           must contain a vendor-specific implementation of this function.
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
X  if ((ticks - 1UL) > (0xFFFFFFUL ))
N  {
N    return (1UL);                                                   /* Reload value impossible */
N  }
N
N  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (uint32_t)(ticks - 1UL);                          
N  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
X  __NVIC_SetPriority (SysTick_IRQn, (1UL << 2) - 1UL);  
N  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0UL;                                              
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2U) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1U)   |
N                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL );                          
N  return (0UL);                                                     /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
L 86 ".\Common\RTE\RTOS\..\..\..\Device_desc\TN2115s1.h" 2
N#include "system_TN2115s1.h"                    /*!< TN2115s1 System                                                           */
L 1 ".\Common\RTE\RTOS\..\..\..\Device_desc\system_TN2115s1.h" 1
N/**************************************************************************//**
N * @file     system_ARMCM0.h
N * @brief    CMSIS Device System Header File for
N *           ARMCM0 Device
N * @version  V5.3.1
N * @date     09. July 2018
N ******************************************************************************/
N/*
N * Copyright (c) 2009-2018 Arm Limited. All rights reserved.
N *
N * SPDX-License-Identifier: Apache-2.0
N *
N * Licensed under the Apache License, Version 2.0 (the License); you may
N * not use this file except in compliance with the License.
N * You may obtain a copy of the License at
N *
N * www.apache.org/licenses/LICENSE-2.0
N *
N * Unless required by applicable law or agreed to in writing, software
N * distributed under the License is distributed on an AS IS BASIS, WITHOUT
N * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
N * See the License for the specific language governing permissions and
N * limitations under the License.
N */
N
N#ifndef SYSTEM_TN2115S0_H
N#define SYSTEM_TN2115S0_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
Nextern uint32_t SystemCoreClock;     /*!< System Clock Frequency (Core Clock) */
N
N
N/**
N  \brief Setup the microcontroller system.
N
N   Initialize the System and update the SystemCoreClock variable.
N */
Nextern void SystemInit (void);
N
N
N/**
N  \brief  Update SystemCoreClock variable.
N
N   Updates the SystemCoreClock with current core Clock retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate (void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* SYSTEM_ARMCM0_H */
L 87 ".\Common\RTE\RTOS\..\..\..\Device_desc\TN2115s1.h" 2
N
N#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
S  #define __IM   __I
N#endif
N#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
S  #define __OM   __O
N#endif
N#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
S  #define __IOM  __IO
N#endif
N
N
N/* ========================================  Start of section using anonymous unions  ======================================== */
N#if defined (__CC_ARM)
X#if 1L
N  #pragma push
N  #pragma anon_unions
N#elif defined (__ICCARM__)
S  #pragma language=extended
S#elif defined(__ARMCC_VERSION) && (__ARMCC_VERSION >= 6010050)
S  #pragma clang diagnostic push
S  #pragma clang diagnostic ignored "-Wc11-extensions"
S  #pragma clang diagnostic ignored "-Wreserved-id-macro"
S  #pragma clang diagnostic ignored "-Wgnu-anonymous-struct"
S  #pragma clang diagnostic ignored "-Wnested-anon-types"
S#elif defined (__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined (__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined (__TASKING__)
S  #pragma warning 586
S#elif defined (__CSMC__)
S  /* anonymous unions are enabled by default */
S#else
S  #warning Not supported compiler type
N#endif
N
N
N/* =========================================================================================================================== */
N/* ================                            Device Specific Peripheral Section                             ================ */
N/* =========================================================================================================================== */
N
N
N/** @addtogroup Device_Peripheral_peripherals
N  * @{
N  */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                            WDT                                            ================ */
N/* =========================================================================================================================== */
N
N
N/**
N  * @brief Watchdog Timer (WDT)
N  */
N
Ntypedef struct {                                /*!< (@ 0x40000400) WDT Structure                                              */
N  __IOM uint32_t  CSR;                          /*!< (@ 0x00000000) Watchdog Control and Status Register                       */
X  volatile uint32_t  CSR;                           
N} WDT_Type;                                     /*!< Size = 4 (0x4)                                                            */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                            NFC                                            ================ */
N/* =========================================================================================================================== */
N
N
N/**
N  * @brief NFC System Control (NFC)
N  */
N
Ntypedef struct {                                /*!< (@ 0x40000300) NFC Structure                                              */
N  
N  union {
N    __IOM uint8_t SYSCTRL;                      /*!< (@ 0x00000000) NFC Subsystem Control Register                             */
X    volatile uint8_t SYSCTRL;                       
N    
N    struct {
N      __IM  uint8_t             : 5;
X      volatile const  uint8_t             : 5;
N      __OM  uint8_t PASSTHRUTRG : 1;            /*!< [5..5] Type 4 mode pass-through trigger                                   */
X      volatile  uint8_t PASSTHRUTRG : 1;             
N    } SYSCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED[3];
X  volatile const  uint8_t   RESERVED[3];
N  
N  union {
N    __IOM uint8_t HARVCTRL;                     /*!< (@ 0x00000004) NFC Energy Harvesting Control Register                     */
X    volatile uint8_t HARVCTRL;                      
N    
N    struct {
N      __IOM uint8_t CAPCHTHH    : 3;            /*!< [2..0] Harv2 capacitor switching voltage Hi threshold selection           */
X      volatile uint8_t CAPCHTHH    : 3;             
N      __IOM uint8_t CAPCHTHL    : 3;            /*!< [5..3] Harv2 capacitor switching voltage Lo threshold selection           */
X      volatile uint8_t CAPCHTHL    : 3;             
N      __IOM uint8_t CAPFORCECH  : 1;            /*!< [6..6] Harv2 capacitor force charging                                     */
X      volatile uint8_t CAPFORCECH  : 1;             
N    } HARVCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED1[3];
X  volatile const  uint8_t   RESERVED1[3];
N  
N  union {
N    __IOM uint8_t OPCTRL;                       /*!< (@ 0x00000008) NFC Operation Control Register                             */
X    volatile uint8_t OPCTRL;                        
N    
N    struct {
N      __IOM uint8_t OPERMODE    : 2;            /*!< [1..0] NFC Tag interface operation mode                                   */
X      volatile uint8_t OPERMODE    : 2;             
N    } OPCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED2[3];
X  volatile const  uint8_t   RESERVED2[3];
N  
N  union {
N    __IOM uint8_t POWER;                        /*!< (@ 0x0000000C) System Power and Regulator Control Register                */
X    volatile uint8_t POWER;                         
N    
N    struct {
N      __IOM uint8_t LDO18OPT    : 2;            /*!< [1..0] 1.8V LDO output voltage control                                    */
X      volatile uint8_t LDO18OPT    : 2;             
N      __IOM uint8_t LDO33OPT    : 2;            /*!< [3..2] 3.3V LDO output voltage control                                    */
X      volatile uint8_t LDO33OPT    : 2;             
N      __IOM uint8_t BGOPT       : 3;            /*!< [6..4] Bandgap output voltage control                                     */
X      volatile uint8_t BGOPT       : 3;             
N      __IOM uint8_t AVDD18      : 1;            /*!< [7..7] AVDD18 rise control                                                */
X      volatile uint8_t AVDD18      : 1;             
N    } POWER_b;
N  } ;
N  __IM  uint8_t   RESERVED3[3];
X  volatile const  uint8_t   RESERVED3[3];
N  
N  union {
N    __IOM uint8_t BROWNOUT3V3;                  /*!< (@ 0x00000010) Brownout Control Register                                  */
X    volatile uint8_t BROWNOUT3V3;                   
N    
N    struct {
N      __IM  uint8_t             : 5;
X      volatile const  uint8_t             : 5;
N      __IOM uint8_t BROLVL      : 2;            /*!< [6..5] Brownout Voltage Level                                             */
X      volatile uint8_t BROLVL      : 2;             
N      __IOM uint8_t BROEN       : 1;            /*!< [7..7] Brownout Enable                                                    */
X      volatile uint8_t BROEN       : 1;             
N    } BROWNOUT3V3_b;
N  } ;
N  __IM  uint8_t   RESERVED4[3];
X  volatile const  uint8_t   RESERVED4[3];
N  
N  union {
N    __IOM uint8_t RXCTRL;                       /*!< (@ 0x00000014) NFC RX Control Register                                    */
X    volatile uint8_t RXCTRL;                        
N    
N    struct {
N      __IOM uint8_t RXGAIN      : 1;            /*!< [0..0] RX GAIN x2                                                         */
X      volatile uint8_t RXGAIN      : 1;             
N      __IM  uint8_t             : 1;
X      volatile const  uint8_t             : 1;
N      __IOM uint8_t RXWAKEUPTH  : 3;            /*!< [4..2] RX wakeup threshold control                                        */
X      volatile uint8_t RXWAKEUPTH  : 3;             
N    } RXCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED5[3];
X  volatile const  uint8_t   RESERVED5[3];
N  
N  union {
N    __IOM uint8_t TXCTRL;                       /*!< (@ 0x00000018) NFC TX Control Register                                    */
X    volatile uint8_t TXCTRL;                        
N    
N    struct {
N      __IOM uint8_t TXPOLARITY  : 1;            /*!< [0..0] TX modulation polarity                                             */
X      volatile uint8_t TXPOLARITY  : 1;             
N      __IOM uint8_t TXAMP       : 3;            /*!< [3..1] TX load modulation strength                                        */
X      volatile uint8_t TXAMP       : 3;             
N    } TXCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED6[3];
X  volatile const  uint8_t   RESERVED6[3];
N  
N  union {
N    __IOM uint8_t CAPCURCTRL;                   /*!< (@ 0x0000001C) Capacitor Switch Current Control Register                  */
X    volatile uint8_t CAPCURCTRL;                    
N    
N    struct {
N      __IM  uint8_t             : 5;
X      volatile const  uint8_t             : 5;
N      __IOM uint8_t CAPCUR      : 2;            /*!< [6..5] Capacitor charge current                                           */
X      volatile uint8_t CAPCUR      : 2;             
N      __IOM uint8_t SOFTCUR     : 1;            /*!< [7..7] Enable switch soft start                                           */
X      volatile uint8_t SOFTCUR     : 1;             
N    } CAPCURCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED7[3];
X  volatile const  uint8_t   RESERVED7[3];
N  
N  union {
N    __IOM uint8_t OSC;                          /*!< (@ 0x00000020) OSC Trimming Register                                      */
X    volatile uint8_t OSC;                           
N    
N    struct {
N      __IOM uint8_t OSCTRIM     : 8;            /*!< [7..0] OSC trim value                                                     */
X      volatile uint8_t OSCTRIM     : 8;             
N    } OSC_b;
N  } ;
N  __IM  uint8_t   RESERVED8[3];
X  volatile const  uint8_t   RESERVED8[3];
N  
N  union {
N    __IOM uint8_t NFCRTX;                       /*!< (@ 0x00000024) NFC RTX Register                                           */
X    volatile uint8_t NFCRTX;                        
N    
N    struct {
N      __IOM uint8_t FIELDINT    : 1;            /*!< [0..0] NFC field change interrupt                                         */
X      volatile uint8_t FIELDINT    : 1;             
N      __IOM uint8_t EXT_INTR    : 1;            /*!< [1..1] GPIO Interrupt Flags                                               */
X      volatile uint8_t EXT_INTR    : 1;             
N      __IOM uint8_t CAP_OK_INTR : 1;            /*!< [2..2] Capacitor OK Interrupt Flags                                       */
X      volatile uint8_t CAP_OK_INTR : 1;             
N      __IOM uint8_t CAPEN       : 1;            /*!< [3..3] Enable automatic capacitor charging                                */
X      volatile uint8_t CAPEN       : 1;             
N      __IM  uint8_t TXENDINT    : 1;            /*!< [4..4] NFC TX end interrupt                                               */
X      volatile const  uint8_t TXENDINT    : 1;             
N      __IM  uint8_t RXENDINT    : 1;            /*!< [5..5] NFC RX end interrupt                                               */
X      volatile const  uint8_t RXENDINT    : 1;             
N      __IOM uint8_t TXSTART     : 1;            /*!< [6..6] NFC Start TX                                                       */
X      volatile uint8_t TXSTART     : 1;             
N      __IOM uint8_t CLKRCVSTART : 1;            /*!< [7..7] NFC start clock recovery                                           */
X      volatile uint8_t CLKRCVSTART : 1;             
N    } NFCRTX_b;
N  } ;
N  __IM  uint8_t   RESERVED9[3];
X  volatile const  uint8_t   RESERVED9[3];
N  
N  union {
N    __IOM uint8_t STATUS;                       /*!< (@ 0x00000028) NFC Status Display Register                                */
X    volatile uint8_t STATUS;                        
N    
N    struct {
N      __IOM uint8_t RAMUD       : 1;            /*!< [0..0] RAM Memory update indication                                       */
X      volatile uint8_t RAMUD       : 1;             
N      __IOM uint8_t EEPUD       : 1;            /*!< [1..1] EEPROM update indication                                           */
X      volatile uint8_t EEPUD       : 1;             
N      __IM  uint8_t CAPCHOK     : 1;            /*!< [2..2] Harv2 capacitor charging status                                    */
X      volatile const  uint8_t CAPCHOK     : 1;             
N      __IM  uint8_t             : 1;
X      volatile const  uint8_t             : 1;
N      __IM  uint8_t ECED        : 1;            /*!< [4..4] EEPROM ECED status                                                 */
X      volatile const  uint8_t ECED        : 1;             
N      __IOM uint8_t BUSY        : 1;            /*!< [5..5] EEPROM busy                                                        */
X      volatile uint8_t BUSY        : 1;             
N      __IM  uint8_t RFFIELD     : 1;            /*!< [6..6] NFC field presence                                                 */
X      volatile const  uint8_t RFFIELD     : 1;             
N      __IM  uint8_t RFON        : 1;            /*!< [7..7] NFC interface on/off                                               */
X      volatile const  uint8_t RFON        : 1;             
N    } STATUS_b;
N  } ;
N  __IM  uint8_t   RESERVED10[3];
X  volatile const  uint8_t   RESERVED10[3];
N  
N  union {
N    __IOM uint8_t CLKCALIBVAL;                  /*!< (@ 0x0000002C) Clock Calibration Result Register                          */
X    volatile uint8_t CLKCALIBVAL;                   
N    
N    struct {
N      __IOM uint8_t HALFDUR     : 8;            /*!< [7..0] Calibration Result                                                 */
X      volatile uint8_t HALFDUR     : 8;             
N    } CLKCALIBVAL_b;
N  } ;
N  __IM  uint8_t   RESERVED11[3];
X  volatile const  uint8_t   RESERVED11[3];
N  
N  union {
N    __IOM uint8_t MODULECTRL;                   /*!< (@ 0x00000030) Module Enable Register                                     */
X    volatile uint8_t MODULECTRL;                    
N    
N    struct {
N      __IM  uint8_t             : 5;
X      volatile const  uint8_t             : 5;
N      __IOM uint8_t UARTEN      : 1;            /*!< [5..5] UART Enable                                                        */
X      volatile uint8_t UARTEN      : 1;             
N      __IOM uint8_t SPIEN       : 1;            /*!< [6..6] SPI Enable                                                         */
X      volatile uint8_t SPIEN       : 1;             
N      __IOM uint8_t CLKCALIBEN  : 1;            /*!< [7..7] Clock Calibration Enable                                           */
X      volatile uint8_t CLKCALIBEN  : 1;             
N    } MODULECTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED12[3];
X  volatile const  uint8_t   RESERVED12[3];
N  
N  union {
N    __IOM uint8_t RXGLITCH;                     /*!< (@ 0x00000034) RX De-glitch Control Register                              */
X    volatile uint8_t RXGLITCH;                      
N    
N    struct {
N      __IOM uint8_t GLITCH      : 2;            /*!< [1..0] Glitch Filter                                                      */
X      volatile uint8_t GLITCH      : 2;             
N    } RXGLITCH_b;
N  } ;
N} NFC_Type;                                     /*!< Size = 53 (0x35)                                                          */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                            I2C                                            ================ */
N/* =========================================================================================================================== */
N
N
N/**
N  * @brief I2C interface (I2C)
N  */
N
Ntypedef struct {                                /*!< (@ 0x40000000) I2C Structure                                              */
N  
N  union {
N    __IOM uint8_t ADDR0;                        /*!< (@ 0x00000000) I2C Slave Address 0 Register                               */
X    volatile uint8_t ADDR0;                         
N    
N    struct {
N      __IOM uint8_t GCen        : 1;            /*!< [0..0] General call enable                                                */
X      volatile uint8_t GCen        : 1;             
N      __IOM uint8_t ADDR0       : 7;            /*!< [7..1] Address 0                                                          */
X      volatile uint8_t ADDR0       : 7;             
N    } ADDR0_b;
N  } ;
N  __IM  uint8_t   RESERVED[3];
X  volatile const  uint8_t   RESERVED[3];
N  
N  union {
N    __IOM uint8_t ADDR1;                        /*!< (@ 0x00000004) I2C Slave Address 1 Register                               */
X    volatile uint8_t ADDR1;                         
N    
N    struct {
N      __IOM uint8_t GCen        : 1;            /*!< [0..0] General call enable                                                */
X      volatile uint8_t GCen        : 1;             
N      __IOM uint8_t ADDR1       : 7;            /*!< [7..1] Address 0                                                          */
X      volatile uint8_t ADDR1       : 7;             
N    } ADDR1_b;
N  } ;
N  __IM  uint8_t   RESERVED1[7];
X  volatile const  uint8_t   RESERVED1[7];
N  
N  union {
N    __IOM uint8_t DATA;                         /*!< (@ 0x0000000C) I2C RTX Data Register                                      */
X    volatile uint8_t DATA;                          
N    
N    struct {
N      __IOM uint8_t DATA        : 8;            /*!< [7..0] Data to receive or transmit                                        */
X      volatile uint8_t DATA        : 8;             
N    } DATA_b;
N  } ;
N  __IM  uint8_t   RESERVED2[3];
X  volatile const  uint8_t   RESERVED2[3];
N  
N  union {
N    __IOM uint8_t CTRL;                         /*!< (@ 0x00000010) I2C CTRL Register                                          */
X    volatile uint8_t CTRL;                          
N    
N    struct {
N      __IM  uint8_t             : 2;
X      volatile const  uint8_t             : 2;
N      __IOM uint8_t AAK         : 1;            /*!< [2..2] Acknowlegement control                                             */
X      volatile uint8_t AAK         : 1;             
N      __IOM uint8_t IFLG        : 1;            /*!< [3..3] Interrupt flag                                                     */
X      volatile uint8_t IFLG        : 1;             
N      __IM  uint8_t             : 2;
X      volatile const  uint8_t             : 2;
N      __IOM uint8_t ENAB        : 1;            /*!< [6..6] I2C Enable                                                         */
X      volatile uint8_t ENAB        : 1;             
N      __IOM uint8_t IEN         : 1;            /*!< [7..7] Interrupt enable                                                   */
X      volatile uint8_t IEN         : 1;             
N    } CTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED3[7];
X  volatile const  uint8_t   RESERVED3[7];
N  
N  union {
N    __IOM uint8_t STATUS;                       /*!< (@ 0x00000018) I2C Status Register                                        */
X    volatile uint8_t STATUS;                        
N    
N    struct {
N      __IM  uint8_t STAT        : 8;            /*!< [7..0] Status display                                                     */
X      volatile const  uint8_t STAT        : 8;             
N    } STATUS_b;
N  } ;
N  __IM  uint8_t   RESERVED4[3];
X  volatile const  uint8_t   RESERVED4[3];
N  
N  union {
N    __IOM uint8_t RESET;                        /*!< (@ 0x0000001C) I2C Reset Register                                         */
X    volatile uint8_t RESET;                         
N    
N    struct {
N      __IOM uint8_t SRST        : 8;            /*!< [7..0] Write any value to reset                                           */
X      volatile uint8_t SRST        : 8;             
N    } RESET_b;
N  } ;
N} I2C_Type;                                     /*!< Size = 29 (0x1d)                                                          */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                            SPI                                            ================ */
N/* =========================================================================================================================== */
N
N
N/**
N  * @brief SPI interface (SPI)
N  */
N
Ntypedef struct {                                /*!< (@ 0x40000100) SPI Structure                                              */
N  
N  union {
N    __IOM uint8_t INTENCTRL;                    /*!< (@ 0x00000000) SPI Interrupt Control Register                             */
X    volatile uint8_t INTENCTRL;                     
N    
N    struct {
N      __IOM uint8_t RXINTEN     : 1;            /*!< [0..0] SPI RX overflow interrupt control                                  */
X      volatile uint8_t RXINTEN     : 1;             
N      __IOM uint8_t TXINTEN     : 1;            /*!< [1..1] SPI TX underflow interrupt control                                 */
X      volatile uint8_t TXINTEN     : 1;             
N    } INTENCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED[3];
X  volatile const  uint8_t   RESERVED[3];
N  
N  union {
N    __IOM uint8_t RTXCTRL;                      /*!< (@ 0x00000004) SPI RTX Control Register                                   */
X    volatile uint8_t RTXCTRL;                       
N    
N    struct {
N      __IOM uint8_t RXEN        : 1;            /*!< [0..0] SPI RX control                                                     */
X      volatile uint8_t RXEN        : 1;             
N      __IOM uint8_t TXEN        : 1;            /*!< [1..1] SPI TX control                                                     */
X      volatile uint8_t TXEN        : 1;             
N    } RTXCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED1[3];
X  volatile const  uint8_t   RESERVED1[3];
N  __IOM uint8_t   TXFIFO;                       /*!< (@ 0x00000008) SPI TX FIFO Register                                       */
X  volatile uint8_t   TXFIFO;                        
N  __IM  uint8_t   RESERVED2[3];
X  volatile const  uint8_t   RESERVED2[3];
N  __IOM uint8_t   RXFIFO;                       /*!< (@ 0x0000000C) SPI TX FIFO Register                                       */
X  volatile uint8_t   RXFIFO;                        
N  __IM  uint8_t   RESERVED3[3];
X  volatile const  uint8_t   RESERVED3[3];
N  
N  union {
N    __IOM uint8_t TXFIFOWMCTRL;                 /*!< (@ 0x00000010) SPI TX FIFO Watermark Control Register                     */
X    volatile uint8_t TXFIFOWMCTRL;                  
N    
N    struct {
N      __IOM uint8_t TXFIFOWM    : 3;            /*!< [2..0] SPI TX FIFO underflow watermark control                            */
X      volatile uint8_t TXFIFOWM    : 3;             
N    } TXFIFOWMCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED4[3];
X  volatile const  uint8_t   RESERVED4[3];
N  
N  union {
N    __IOM uint8_t RXFIFOWMCTRL;                 /*!< (@ 0x00000014) SPI RX FIFO Watermark Control Register                     */
X    volatile uint8_t RXFIFOWMCTRL;                  
N    
N    struct {
N      __IOM uint8_t RXFIFOWM    : 3;            /*!< [2..0] SPI RX FIFO overflow watermark control                             */
X      volatile uint8_t RXFIFOWM    : 3;             
N    } RXFIFOWMCTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED5[3];
X  volatile const  uint8_t   RESERVED5[3];
N  
N  union {
N    __IOM uint8_t RTXINT;                       /*!< (@ 0x00000018) SPI RTX INT Flags Register                                 */
X    volatile uint8_t RTXINT;                        
N    
N    struct {
N      __IOM uint8_t RXINTFLAG   : 1;            /*!< [0..0] SPI RX interrupt flag                                              */
X      volatile uint8_t RXINTFLAG   : 1;             
N      __IOM uint8_t TXINTFLAG   : 1;            /*!< [1..1] SPI TX interrupt flag                                              */
X      volatile uint8_t TXINTFLAG   : 1;             
N    } RTXINT_b;
N  } ;
N  __IM  uint8_t   RESERVED6[3];
X  volatile const  uint8_t   RESERVED6[3];
N  
N  union {
N    __IOM uint8_t FIFORST;                      /*!< (@ 0x0000001C) SPI RTX FIFO Reset Register                                */
X    volatile uint8_t FIFORST;                       
N    
N    struct {
N      __IOM uint8_t RXFIFORST   : 1;            /*!< [0..0] SPI RX FIFO reset                                                  */
X      volatile uint8_t RXFIFORST   : 1;             
N      __IOM uint8_t TXFIFORST   : 1;            /*!< [1..1] SPI TX FIFO reset                                                  */
X      volatile uint8_t TXFIFORST   : 1;             
N    } FIFORST_b;
N  } ;
N} SPI_Type;                                     /*!< Size = 29 (0x1d)                                                          */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                           TIM32                                           ================ */
N/* =========================================================================================================================== */
N
N
N/**
N  * @brief General Purpose 32bit Timer (TIM32)
N  */
N
Ntypedef struct {                                /*!< (@ 0x40000404) TIM32 Structure                                            */
N  
N  union {
N    __IOM uint8_t CTRL;                         /*!< (@ 0x00000000) TIM32 Control Register                                     */
X    volatile uint8_t CTRL;                          
N    
N    struct {
N      __IOM uint8_t TIM32EN     : 1;            /*!< [0..0] TIM32 enable control                                               */
X      volatile uint8_t TIM32EN     : 1;             
N      __IOM uint8_t TIM32INTEN  : 1;            /*!< [1..1] TIM32 interrupt enable control                                     */
X      volatile uint8_t TIM32INTEN  : 1;             
N      __IOM uint8_t TIM32DIV    : 2;            /*!< [3..2] TIM32 clock divider                                                */
X      volatile uint8_t TIM32DIV    : 2;             
N      __IM  uint8_t             : 3;
X      volatile const  uint8_t             : 3;
N      __IOM uint8_t TIM32INTFLAG : 1;           /*!< [7..7] TIM32 interrupt flag                                               */
X      volatile uint8_t TIM32INTFLAG : 1;            
N    } CTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED[3];
X  volatile const  uint8_t   RESERVED[3];
N  
N  union {
N    __IOM uint32_t CNT;                         /*!< (@ 0x00000004) TIM32 Counter Register                                     */
X    volatile uint32_t CNT;                          
N    
N    struct {
N      __IOM uint32_t COUNTER    : 32;           /*!< [31..0] TIM32 counter value                                               */
X      volatile uint32_t COUNTER    : 32;            
N    } CNT_b;
N  } ;
N  
N  union {
N    __IOM uint32_t RELOAD;                      /*!< (@ 0x00000008) TIM32 Reload Register                                      */
X    volatile uint32_t RELOAD;                       
N    
N    struct {
N      __IOM uint32_t RELOAD     : 32;           /*!< [31..0] TIM32 counter reload value                                        */
X      volatile uint32_t RELOAD     : 32;            
N    } RELOAD_b;
N  } ;
N} TIM32_Type;                                   /*!< Size = 12 (0xc)                                                           */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                           UART                                            ================ */
N/* =========================================================================================================================== */
N
N
N/**
N  * @brief UART interface (UART)
N  */
N
Ntypedef struct {                                /*!< (@ 0x40000200) UART Structure                                             */
N  
N  union {
N    __IOM uint8_t DATA;                         /*!< (@ 0x00000000) UART RX/TX Data Register                                   */
X    volatile uint8_t DATA;                          
N    
N    struct {
N      __IOM uint8_t DATA        : 8;            /*!< [7..0] Data to be txed or data rxed                                       */
X      volatile uint8_t DATA        : 8;             
N    } DATA_b;
N  } ;
N  __IM  uint8_t   RESERVED[3];
X  volatile const  uint8_t   RESERVED[3];
N  
N  union {
N    __IOM uint8_t STATUS;                       /*!< (@ 0x00000004) UART Status Register                                       */
X    volatile uint8_t STATUS;                        
N    
N    struct {
N      __IM  uint8_t TX_FULL_FLAG : 1;           /*!< [0..0] TX buffer full                                                     */
X      volatile const  uint8_t TX_FULL_FLAG : 1;            
N      __IM  uint8_t RX_FULL_FLAG : 1;           /*!< [1..1] RX buffer full                                                     */
X      volatile const  uint8_t RX_FULL_FLAG : 1;            
N      __IOM uint8_t TX_OVFL_FLAG : 1;           /*!< [2..2] TX buffer overflow                                                 */
X      volatile uint8_t TX_OVFL_FLAG : 1;            
N      __IOM uint8_t RX_OVFL_FLAG : 1;           /*!< [3..3] RX buffer overflow                                                 */
X      volatile uint8_t RX_OVFL_FLAG : 1;            
N    } STATUS_b;
N  } ;
N  __IM  uint8_t   RESERVED1[3];
X  volatile const  uint8_t   RESERVED1[3];
N  
N  union {
N    __IOM uint8_t CTRL;                         /*!< (@ 0x00000008) UART Control Register                                      */
X    volatile uint8_t CTRL;                          
N    
N    struct {
N      __IOM uint8_t TX_EN       : 1;            /*!< [0..0] TX enable                                                          */
X      volatile uint8_t TX_EN       : 1;             
N      __IOM uint8_t RX_EN       : 1;            /*!< [1..1] RX enable                                                          */
X      volatile uint8_t RX_EN       : 1;             
N      __IOM uint8_t TX_INT      : 1;            /*!< [2..2] TX interrupt enable                                                */
X      volatile uint8_t TX_INT      : 1;             
N      __IOM uint8_t RX_INT      : 1;            /*!< [3..3] RX interrupt enable                                                */
X      volatile uint8_t RX_INT      : 1;             
N      __IOM uint8_t TX_OVFL_INT : 1;            /*!< [4..4] TX buffer overflow interrupt enable                                */
X      volatile uint8_t TX_OVFL_INT : 1;             
N      __IOM uint8_t RX_OVFL_INT : 1;            /*!< [5..5] RX buffer overflow interrupt enable                                */
X      volatile uint8_t RX_OVFL_INT : 1;             
N    } CTRL_b;
N  } ;
N  __IM  uint8_t   RESERVED2[3];
X  volatile const  uint8_t   RESERVED2[3];
N  
N  union {
N    __IOM uint8_t INTFLAG;                      /*!< (@ 0x0000000C) UART Interrupt Flag Register                               */
X    volatile uint8_t INTFLAG;                       
N    
N    struct {
N      __IOM uint8_t TX_INT_FLAG : 1;            /*!< [0..0] TX interrupt flag                                                  */
X      volatile uint8_t TX_INT_FLAG : 1;             
N      __IOM uint8_t RX_INT_FLAG : 1;            /*!< [1..1] RX interrupt flag                                                  */
X      volatile uint8_t RX_INT_FLAG : 1;             
N      __IOM uint8_t TX_OVFL_INT_FLAG : 1;       /*!< [2..2] TX buffer overflow interrupt flag                                  */
X      volatile uint8_t TX_OVFL_INT_FLAG : 1;        
N      __IOM uint8_t RX_OVFL_INT_FLAG : 1;       /*!< [3..3] RX buffer overflow interrupt flag                                  */
X      volatile uint8_t RX_OVFL_INT_FLAG : 1;        
N    } INTFLAG_b;
N  } ;
N  __IM  uint8_t   RESERVED3[3];
X  volatile const  uint8_t   RESERVED3[3];
N  
N  union {
N    __IOM uint8_t BAUDM;                        /*!< (@ 0x00000010) UART Baudrate MSB Register                                 */
X    volatile uint8_t BAUDM;                         
N    
N    struct {
N      __IOM uint8_t MSB         : 8;            /*!< [7..0] Baudrate control MSB                                               */
X      volatile uint8_t MSB         : 8;             
N    } BAUDM_b;
N  } ;
N  __IM  uint8_t   RESERVED4[3];
X  volatile const  uint8_t   RESERVED4[3];
N  
N  union {
N    __IOM uint8_t BAUDL;                        /*!< (@ 0x00000014) UART Baudrate LSB Register                                 */
X    volatile uint8_t BAUDL;                         
N    
N    struct {
N      __IOM uint8_t LSB         : 8;            /*!< [7..0] Baudrate control LSB                                               */
X      volatile uint8_t LSB         : 8;             
N    } BAUDL_b;
N  } ;
N  __IM  uint8_t   RESERVED5[3];
X  volatile const  uint8_t   RESERVED5[3];
N  
N  union {
N    __IOM uint8_t BAUDF;                        /*!< (@ 0x00000018) UART Baudrate Fraction Register                            */
X    volatile uint8_t BAUDF;                         
N    
N    struct {
N      __IOM uint8_t FRC         : 8;            /*!< [7..0] Baudrate control Fraction                                          */
X      volatile uint8_t FRC         : 8;             
N    } BAUDF_b;
N  } ;
N} UART_Type;                                    /*!< Size = 25 (0x19)                                                          */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                           GPIO                                            ================ */
N/* =========================================================================================================================== */
N
N
N/**
N  * @brief GPIO (GPIO)
N  */
N
Ntypedef struct {                                /*!< (@ 0x40000500) GPIO Structure                                             */
N  
N  union {
N    __IOM uint16_t GPFUNC0;                     /*!< (@ 0x00000000) GPIO Function Control Register 0                           */
X    volatile uint16_t GPFUNC0;                      
N    
N    struct {
N      __IOM uint16_t FUNC       : 13;           /*!< [12..0] Function control                                                  */
X      volatile uint16_t FUNC       : 13;            
N    } GPFUNC0_b;
N  } ;
N  __IM  uint16_t  RESERVED;
X  volatile const  uint16_t  RESERVED;
N  
N  union {
N    __IOM uint16_t GPFUNC1;                     /*!< (@ 0x00000004) GPIO Function Control Register 1                           */
X    volatile uint16_t GPFUNC1;                      
N    
N    struct {
N      __IOM uint16_t FUNC       : 13;           /*!< [12..0] Function control                                                  */
X      volatile uint16_t FUNC       : 13;            
N    } GPFUNC1_b;
N  } ;
N  __IM  uint16_t  RESERVED1;
X  volatile const  uint16_t  RESERVED1;
N  
N  union {
N    __IOM uint16_t GPOUT;                       /*!< (@ 0x00000008) GPIO Output Value Register                                 */
X    volatile uint16_t GPOUT;                        
N    
N    struct {
N      __IOM uint16_t OUT        : 13;           /*!< [12..0] Output Value                                                      */
X      volatile uint16_t OUT        : 13;            
N    } GPOUT_b;
N  } ;
N  __IM  uint16_t  RESERVED2;
X  volatile const  uint16_t  RESERVED2;
N  
N  union {
N    __IOM uint16_t GPIN;                        /*!< (@ 0x0000000C) GPIO Input Value Register                                  */
X    volatile uint16_t GPIN;                         
N    
N    struct {
N      __IM  uint16_t IN         : 13;           /*!< [12..0] Input Value                                                       */
X      volatile const  uint16_t IN         : 13;            
N    } GPIN_b;
N  } ;
N} GPIO_Type;                                    /*!< Size = 14 (0xe)                                                           */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                           FLASH                                           ================ */
N/* =========================================================================================================================== */
N
N
N/**
N  * @brief FLASH (FLASH)
N  */
N
Ntypedef struct {                                /*!< (@ 0x40000600) FLASH Structure                                            */
N  
N  union {
N    __IOM uint32_t FLASHKEY;                    /*!< (@ 0x00000000) FLASH Lock KEY Register                                    */
X    volatile uint32_t FLASHKEY;                     
N    
N    struct {
N      __IOM uint32_t KEY        : 32;           /*!< [31..0] The lock key                                                      */
X      volatile uint32_t KEY        : 32;            
N    } FLASHKEY_b;
N  } ;
N} FLASH_Type;                                   /*!< Size = 4 (0x4)                                                            */
N
N
N/** @} */ /* End of group Device_Peripheral_peripherals */
N
N
N/* =========================================================================================================================== */
N/* ================                          Device Specific Peripheral Address Map                           ================ */
N/* =========================================================================================================================== */
N
N
N/** @addtogroup Device_Peripheral_peripheralAddr
N  * @{
N  */
N
N#define WDT_BASE                    0x40000400UL
N#define NFC_BASE                    0x40000300UL
N#define I2C_BASE                    0x40000000UL
N#define SPI_BASE                    0x40000100UL
N#define TIM32_BASE                  0x40000404UL
N#define UART_BASE                   0x40000200UL
N#define GPIO_BASE                   0x40000500UL
N#define FLASH_BASE                  0x40000600UL
N
N/** @} */ /* End of group Device_Peripheral_peripheralAddr */
N
N
N/* =========================================================================================================================== */
N/* ================                                  Peripheral declaration                                   ================ */
N/* =========================================================================================================================== */
N
N
N/** @addtogroup Device_Peripheral_declaration
N  * @{
N  */
N
N#define WDT                         ((WDT_Type*)               WDT_BASE)
N#define NFC                         ((NFC_Type*)               NFC_BASE)
N#define I2C                         ((I2C_Type*)               I2C_BASE)
N#define SPI                         ((SPI_Type*)               SPI_BASE)
N#define TIM32                       ((TIM32_Type*)             TIM32_BASE)
N#define UART                        ((UART_Type*)              UART_BASE)
N#define GPIO                        ((GPIO_Type*)              GPIO_BASE)
N#define FLASH                       ((FLASH_Type*)             FLASH_BASE)
N
N/** @} */ /* End of group Device_Peripheral_declaration */
N
N
N/* =========================================  End of section using anonymous unions  ========================================= */
N#if defined (__CC_ARM)
X#if 1L
N  #pragma pop
N#elif defined (__ICCARM__)
S  /* leave anonymous unions enabled */
S#elif (__ARMCC_VERSION >= 6010050)
S  #pragma clang diagnostic pop
S#elif defined (__GNUC__)
S  /* anonymous unions are enabled by default */
S#elif defined (__TMS470__)
S  /* anonymous unions are enabled by default */
S#elif defined (__TASKING__)
S  #pragma warning restore
S#elif defined (__CSMC__)
S  /* anonymous unions are enabled by default */
N#endif
N
N
N/* =========================================================================================================================== */
N/* ================                                Pos/Mask Peripheral Section                                ================ */
N/* =========================================================================================================================== */
N
N
N/** @addtogroup PosMask_peripherals
N  * @{
N  */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                            WDT                                            ================ */
N/* =========================================================================================================================== */
N
N/* ==========================================================  CSR  ========================================================== */
N
N
N/* =========================================================================================================================== */
N/* ================                                            NFC                                            ================ */
N/* =========================================================================================================================== */
N
N/* ========================================================  SYSCTRL  ======================================================== */
N#define NFC_SYSCTRL_PASSTHRUTRG_Pos       (5UL)                     /*!< NFC SYSCTRL: PASSTHRUTRG (Bit 5)                      */
N#define NFC_SYSCTRL_PASSTHRUTRG_Msk       (0x20UL)                  /*!< NFC SYSCTRL: PASSTHRUTRG (Bitfield-Mask: 0x01)        */
N/* =======================================================  HARVCTRL  ======================================================== */
N#define NFC_HARVCTRL_CAPCHTHH_Pos         (0UL)                     /*!< NFC HARVCTRL: CAPCHTHH (Bit 0)                        */
N#define NFC_HARVCTRL_CAPCHTHH_Msk         (0x7UL)                   /*!< NFC HARVCTRL: CAPCHTHH (Bitfield-Mask: 0x07)          */
N#define NFC_HARVCTRL_CAPCHTHL_Pos         (3UL)                     /*!< NFC HARVCTRL: CAPCHTHL (Bit 3)                        */
N#define NFC_HARVCTRL_CAPCHTHL_Msk         (0x38UL)                  /*!< NFC HARVCTRL: CAPCHTHL (Bitfield-Mask: 0x07)          */
N#define NFC_HARVCTRL_CAPFORCECH_Pos       (6UL)                     /*!< NFC HARVCTRL: CAPFORCECH (Bit 6)                      */
N#define NFC_HARVCTRL_CAPFORCECH_Msk       (0x40UL)                  /*!< NFC HARVCTRL: CAPFORCECH (Bitfield-Mask: 0x01)        */
N/* ========================================================  OPCTRL  ========================================================= */
N#define NFC_OPCTRL_OPERMODE_Pos           (0UL)                     /*!< NFC OPCTRL: OPERMODE (Bit 0)                          */
N#define NFC_OPCTRL_OPERMODE_Msk           (0x3UL)                   /*!< NFC OPCTRL: OPERMODE (Bitfield-Mask: 0x03)            */
N/* =========================================================  POWER  ========================================================= */
N#define NFC_POWER_LDO18OPT_Pos            (0UL)                     /*!< NFC POWER: LDO18OPT (Bit 0)                           */
N#define NFC_POWER_LDO18OPT_Msk            (0x3UL)                   /*!< NFC POWER: LDO18OPT (Bitfield-Mask: 0x03)             */
N#define NFC_POWER_LDO33OPT_Pos            (2UL)                     /*!< NFC POWER: LDO33OPT (Bit 2)                           */
N#define NFC_POWER_LDO33OPT_Msk            (0xcUL)                   /*!< NFC POWER: LDO33OPT (Bitfield-Mask: 0x03)             */
N#define NFC_POWER_BGOPT_Pos               (4UL)                     /*!< NFC POWER: BGOPT (Bit 4)                              */
N#define NFC_POWER_BGOPT_Msk               (0x70UL)                  /*!< NFC POWER: BGOPT (Bitfield-Mask: 0x07)                */
N#define NFC_POWER_AVDD18_Pos              (7UL)                     /*!< NFC POWER: AVDD18 (Bit 7)                             */
N#define NFC_POWER_AVDD18_Msk              (0x80UL)                  /*!< NFC POWER: AVDD18 (Bitfield-Mask: 0x01)               */
N/* ======================================================  BROWNOUT3V3  ====================================================== */
N#define NFC_BROWNOUT3V3_BROEN_Pos         (7UL)                     /*!< NFC BROWNOUT3V3: BROEN (Bit 7)                        */
N#define NFC_BROWNOUT3V3_BROEN_Msk         (0x80UL)                  /*!< NFC BROWNOUT3V3: BROEN (Bitfield-Mask: 0x01)          */
N#define NFC_BROWNOUT3V3_BROLVL_Pos        (5UL)                     /*!< NFC BROWNOUT3V3: BROLVL (Bit 5)                       */
N#define NFC_BROWNOUT3V3_BROLVL_Msk        (0x60UL)                  /*!< NFC BROWNOUT3V3: BROLVL (Bitfield-Mask: 0x03)         */
N/* ========================================================  RXCTRL  ========================================================= */
N#define NFC_RXCTRL_RXGAIN_Pos             (0UL)                     /*!< NFC RXCTRL: RXGAIN (Bit 0)                            */
N#define NFC_RXCTRL_RXGAIN_Msk             (0x1UL)                   /*!< NFC RXCTRL: RXGAIN (Bitfield-Mask: 0x01)              */
N#define NFC_RXCTRL_RXWAKEUPTH_Pos         (2UL)                     /*!< NFC RXCTRL: RXWAKEUPTH (Bit 2)                        */
N#define NFC_RXCTRL_RXWAKEUPTH_Msk         (0x1cUL)                  /*!< NFC RXCTRL: RXWAKEUPTH (Bitfield-Mask: 0x07)          */
N/* ========================================================  TXCTRL  ========================================================= */
N#define NFC_TXCTRL_TXPOLARITY_Pos         (0UL)                     /*!< NFC TXCTRL: TXPOLARITY (Bit 0)                        */
N#define NFC_TXCTRL_TXPOLARITY_Msk         (0x1UL)                   /*!< NFC TXCTRL: TXPOLARITY (Bitfield-Mask: 0x01)          */
N#define NFC_TXCTRL_TXAMP_Pos              (1UL)                     /*!< NFC TXCTRL: TXAMP (Bit 1)                             */
N#define NFC_TXCTRL_TXAMP_Msk              (0xeUL)                   /*!< NFC TXCTRL: TXAMP (Bitfield-Mask: 0x07)               */
N/* ======================================================  CAPCURCTRL  ======================================================= */
N#define NFC_CAPCURCTRL_SOFTCUR_Pos        (7UL)                     /*!< NFC CAPCURCTRL: SOFTCUR (Bit 7)                       */
N#define NFC_CAPCURCTRL_SOFTCUR_Msk        (0x80UL)                  /*!< NFC CAPCURCTRL: SOFTCUR (Bitfield-Mask: 0x01)         */
N#define NFC_CAPCURCTRL_CAPCUR_Pos         (5UL)                     /*!< NFC CAPCURCTRL: CAPCUR (Bit 5)                        */
N#define NFC_CAPCURCTRL_CAPCUR_Msk         (0x60UL)                  /*!< NFC CAPCURCTRL: CAPCUR (Bitfield-Mask: 0x03)          */
N/* ==========================================================  OSC  ========================================================== */
N#define NFC_OSC_OSCTRIM_Pos               (0UL)                     /*!< NFC OSC: OSCTRIM (Bit 0)                              */
N#define NFC_OSC_OSCTRIM_Msk               (0xffUL)                  /*!< NFC OSC: OSCTRIM (Bitfield-Mask: 0xff)                */
N/* ========================================================  NFCRTX  ========================================================= */
N#define NFC_NFCRTX_FIELDINT_Pos           (0UL)                     /*!< NFC NFCRTX: FIELDINT (Bit 0)                          */
N#define NFC_NFCRTX_FIELDINT_Msk           (0x1UL)                   /*!< NFC NFCRTX: FIELDINT (Bitfield-Mask: 0x01)            */
N#define NFC_NFCRTX_EXT_INTR_Pos           (1UL)                     /*!< NFC NFCRTX: EXT_INTR (Bit 1)                          */
N#define NFC_NFCRTX_EXT_INTR_Msk           (0x2UL)                   /*!< NFC NFCRTX: EXT_INTR (Bitfield-Mask: 0x01)            */
N#define NFC_NFCRTX_CAP_OK_INTR_Pos        (2UL)                     /*!< NFC NFCRTX: CAP_OK_INTR (Bit 2)                       */
N#define NFC_NFCRTX_CAP_OK_INTR_Msk        (0x4UL)                   /*!< NFC NFCRTX: CAP_OK_INTR (Bitfield-Mask: 0x01)         */
N#define NFC_NFCRTX_CAPEN_Pos              (3UL)                     /*!< NFC NFCRTX: CAPEN (Bit 3)                             */
N#define NFC_NFCRTX_CAPEN_Msk              (0x8UL)                   /*!< NFC NFCRTX: CAPEN (Bitfield-Mask: 0x01)               */
N#define NFC_NFCRTX_TXENDINT_Pos           (4UL)                     /*!< NFC NFCRTX: TXENDINT (Bit 4)                          */
N#define NFC_NFCRTX_TXENDINT_Msk           (0x10UL)                  /*!< NFC NFCRTX: TXENDINT (Bitfield-Mask: 0x01)            */
N#define NFC_NFCRTX_RXENDINT_Pos           (5UL)                     /*!< NFC NFCRTX: RXENDINT (Bit 5)                          */
N#define NFC_NFCRTX_RXENDINT_Msk           (0x20UL)                  /*!< NFC NFCRTX: RXENDINT (Bitfield-Mask: 0x01)            */
N#define NFC_NFCRTX_TXSTART_Pos            (6UL)                     /*!< NFC NFCRTX: TXSTART (Bit 6)                           */
N#define NFC_NFCRTX_TXSTART_Msk            (0x40UL)                  /*!< NFC NFCRTX: TXSTART (Bitfield-Mask: 0x01)             */
N#define NFC_NFCRTX_CLKRCVSTART_Pos        (7UL)                     /*!< NFC NFCRTX: CLKRCVSTART (Bit 7)                       */
N#define NFC_NFCRTX_CLKRCVSTART_Msk        (0x80UL)                  /*!< NFC NFCRTX: CLKRCVSTART (Bitfield-Mask: 0x01)         */
N/* ======================================================  CLKCALIBVAL  ====================================================== */
N#define NFC_CLKCALIBVAL_HALFDUR_Pos       (0UL)                     /*!< NFC CLKCALIBVAL: HALFDUR (Bit 0)                      */
N#define NFC_CLKCALIBVAL_HALFDUR_Msk       (0xffUL)                  /*!< NFC CLKCALIBVAL: HALFDUR (Bitfield-Mask: 0xff)        */
N/* ======================================================  MODULECTRL  ======================================================= */
N#define NFC_MODULECTRL_UARTEN_Pos         (5UL)                     /*!< NFC MODULECTRL: UARTEN (Bit 5)                        */
N#define NFC_MODULECTRL_UARTEN_Msk         (0x20UL)                  /*!< NFC MODULECTRL: UARTEN (Bitfield-Mask: 0x01)          */
N#define NFC_MODULECTRL_SPIEN_Pos          (6UL)                     /*!< NFC MODULECTRL: SPIEN (Bit 6)                         */
N#define NFC_MODULECTRL_SPIEN_Msk          (0x40UL)                  /*!< NFC MODULECTRL: SPIEN (Bitfield-Mask: 0x01)           */
N#define NFC_MODULECTRL_CLKCALIBEN_Pos     (7UL)                     /*!< NFC MODULECTRL: CLKCALIBEN (Bit 7)                    */
N#define NFC_MODULECTRL_CLKCALIBEN_Msk     (0x80UL)                  /*!< NFC MODULECTRL: CLKCALIBEN (Bitfield-Mask: 0x01)      */
N/* =======================================================  RXGLITCH  ======================================================== */
N#define NFC_RXGLITCH_GLITCH_Pos           (0UL)                     /*!< NFC RXGLITCH: GLITCH (Bit 0)                          */
N#define NFC_RXGLITCH_GLITCH_Msk           (0x3UL)                   /*!< NFC RXGLITCH: GLITCH (Bitfield-Mask: 0x03)            */
N/* ========================================================  STATUS  ========================================================= */
N#define NFC_STATUS_RAMUD_Pos              (0UL)                     /*!< NFC STATUS: RAMUD (Bit 0)                             */
N#define NFC_STATUS_RAMUD_Msk              (0x1UL)                   /*!< NFC STATUS: RAMUD (Bitfield-Mask: 0x01)               */
N#define NFC_STATUS_EEPUD_Pos              (1UL)                     /*!< NFC STATUS: EEPUD (Bit 1)                             */
N#define NFC_STATUS_EEPUD_Msk              (0x2UL)                   /*!< NFC STATUS: EEPUD (Bitfield-Mask: 0x01)               */
N#define NFC_STATUS_CAPCHOK_Pos            (2UL)                     /*!< NFC STATUS: CAPCHOK (Bit 2)                           */
N#define NFC_STATUS_CAPCHOK_Msk            (0x4UL)                   /*!< NFC STATUS: CAPCHOK (Bitfield-Mask: 0x01)             */
N#define NFC_STATUS_ECED_Pos               (4UL)                     /*!< NFC STATUS: ECED (Bit 4)                              */
N#define NFC_STATUS_ECED_Msk               (0x10UL)                  /*!< NFC STATUS: ECED (Bitfield-Mask: 0x01)                */
N#define NFC_STATUS_BUSY_Pos               (5UL)                     /*!< NFC STATUS: BUSY (Bit 5)                              */
N#define NFC_STATUS_BUSY_Msk               (0x20UL)                  /*!< NFC STATUS: BUSY (Bitfield-Mask: 0x01)                */
N#define NFC_STATUS_RFFIELD_Pos            (6UL)                     /*!< NFC STATUS: RFFIELD (Bit 6)                           */
N#define NFC_STATUS_RFFIELD_Msk            (0x40UL)                  /*!< NFC STATUS: RFFIELD (Bitfield-Mask: 0x01)             */
N#define NFC_STATUS_RFON_Pos               (7UL)                     /*!< NFC STATUS: RFON (Bit 7)                              */
N#define NFC_STATUS_RFON_Msk               (0x80UL)                  /*!< NFC STATUS: RFON (Bitfield-Mask: 0x01)                */
N
N
N/* =========================================================================================================================== */
N/* ================                                            I2C                                            ================ */
N/* =========================================================================================================================== */
N
N/* =========================================================  ADDR0  ========================================================= */
N#define I2C_ADDR0_GCen_Pos                (0UL)                     /*!< I2C ADDR0: GCen (Bit 0)                               */
N#define I2C_ADDR0_GCen_Msk                (0x1UL)                   /*!< I2C ADDR0: GCen (Bitfield-Mask: 0x01)                 */
N#define I2C_ADDR0_ADDR0_Pos               (1UL)                     /*!< I2C ADDR0: ADDR0 (Bit 1)                              */
N#define I2C_ADDR0_ADDR0_Msk               (0xfeUL)                  /*!< I2C ADDR0: ADDR0 (Bitfield-Mask: 0x7f)                */
N/* =========================================================  ADDR1  ========================================================= */
N#define I2C_ADDR1_GCen_Pos                (0UL)                     /*!< I2C ADDR1: GCen (Bit 0)                               */
N#define I2C_ADDR1_GCen_Msk                (0x1UL)                   /*!< I2C ADDR1: GCen (Bitfield-Mask: 0x01)                 */
N#define I2C_ADDR1_ADDR1_Pos               (1UL)                     /*!< I2C ADDR1: ADDR1 (Bit 1)                              */
N#define I2C_ADDR1_ADDR1_Msk               (0xfeUL)                  /*!< I2C ADDR1: ADDR1 (Bitfield-Mask: 0x7f)                */
N/* =========================================================  DATA  ========================================================== */
N#define I2C_DATA_DATA_Pos                 (0UL)                     /*!< I2C DATA: DATA (Bit 0)                                */
N#define I2C_DATA_DATA_Msk                 (0xffUL)                  /*!< I2C DATA: DATA (Bitfield-Mask: 0xff)                  */
N/* =========================================================  CTRL  ========================================================== */
N#define I2C_CTRL_AAK_Pos                  (2UL)                     /*!< I2C CTRL: AAK (Bit 2)                                 */
N#define I2C_CTRL_AAK_Msk                  (0x4UL)                   /*!< I2C CTRL: AAK (Bitfield-Mask: 0x01)                   */
N#define I2C_CTRL_IFLG_Pos                 (3UL)                     /*!< I2C CTRL: IFLG (Bit 3)                                */
N#define I2C_CTRL_IFLG_Msk                 (0x8UL)                   /*!< I2C CTRL: IFLG (Bitfield-Mask: 0x01)                  */
N#define I2C_CTRL_ENAB_Pos                 (6UL)                     /*!< I2C CTRL: ENAB (Bit 6)                                */
N#define I2C_CTRL_ENAB_Msk                 (0x40UL)                  /*!< I2C CTRL: ENAB (Bitfield-Mask: 0x01)                  */
N#define I2C_CTRL_IEN_Pos                  (7UL)                     /*!< I2C CTRL: IEN (Bit 7)                                 */
N#define I2C_CTRL_IEN_Msk                  (0x80UL)                  /*!< I2C CTRL: IEN (Bitfield-Mask: 0x01)                   */
N/* ========================================================  STATUS  ========================================================= */
N#define I2C_STATUS_STAT_Pos               (0UL)                     /*!< I2C STATUS: STAT (Bit 0)                              */
N#define I2C_STATUS_STAT_Msk               (0xffUL)                  /*!< I2C STATUS: STAT (Bitfield-Mask: 0xff)                */
N/* =========================================================  RESET  ========================================================= */
N#define I2C_RESET_SRST_Pos                (0UL)                     /*!< I2C RESET: SRST (Bit 0)                               */
N#define I2C_RESET_SRST_Msk                (0xffUL)                  /*!< I2C RESET: SRST (Bitfield-Mask: 0xff)                 */
N
N
N/* =========================================================================================================================== */
N/* ================                                            SPI                                            ================ */
N/* =========================================================================================================================== */
N
N/* =======================================================  INTENCTRL  ======================================================= */
N#define SPI_INTENCTRL_RXINTEN_Pos         (0UL)                     /*!< SPI INTENCTRL: RXINTEN (Bit 0)                        */
N#define SPI_INTENCTRL_RXINTEN_Msk         (0x1UL)                   /*!< SPI INTENCTRL: RXINTEN (Bitfield-Mask: 0x01)          */
N#define SPI_INTENCTRL_TXINTEN_Pos         (1UL)                     /*!< SPI INTENCTRL: TXINTEN (Bit 1)                        */
N#define SPI_INTENCTRL_TXINTEN_Msk         (0x2UL)                   /*!< SPI INTENCTRL: TXINTEN (Bitfield-Mask: 0x01)          */
N/* ========================================================  RTXCTRL  ======================================================== */
N#define SPI_RTXCTRL_RXEN_Pos              (0UL)                     /*!< SPI RTXCTRL: RXEN (Bit 0)                             */
N#define SPI_RTXCTRL_RXEN_Msk              (0x1UL)                   /*!< SPI RTXCTRL: RXEN (Bitfield-Mask: 0x01)               */
N#define SPI_RTXCTRL_TXEN_Pos              (1UL)                     /*!< SPI RTXCTRL: TXEN (Bit 1)                             */
N#define SPI_RTXCTRL_TXEN_Msk              (0x2UL)                   /*!< SPI RTXCTRL: TXEN (Bitfield-Mask: 0x01)               */
N/* ========================================================  TXFIFO  ========================================================= */
N/* ========================================================  RXFIFO  ========================================================= */
N/* =====================================================  TXFIFOWMCTRL  ====================================================== */
N#define SPI_TXFIFOWMCTRL_TXFIFOWM_Pos     (0UL)                     /*!< SPI TXFIFOWMCTRL: TXFIFOWM (Bit 0)                    */
N#define SPI_TXFIFOWMCTRL_TXFIFOWM_Msk     (0x7UL)                   /*!< SPI TXFIFOWMCTRL: TXFIFOWM (Bitfield-Mask: 0x07)      */
N/* =====================================================  RXFIFOWMCTRL  ====================================================== */
N#define SPI_RXFIFOWMCTRL_RXFIFOWM_Pos     (0UL)                     /*!< SPI RXFIFOWMCTRL: RXFIFOWM (Bit 0)                    */
N#define SPI_RXFIFOWMCTRL_RXFIFOWM_Msk     (0x7UL)                   /*!< SPI RXFIFOWMCTRL: RXFIFOWM (Bitfield-Mask: 0x07)      */
N/* ========================================================  RTXINT  ========================================================= */
N#define SPI_RTXINT_RXINTFLAG_Pos          (0UL)                     /*!< SPI RTXINT: RXINTFLAG (Bit 0)                         */
N#define SPI_RTXINT_RXINTFLAG_Msk          (0x1UL)                   /*!< SPI RTXINT: RXINTFLAG (Bitfield-Mask: 0x01)           */
N#define SPI_RTXINT_TXINTFLAG_Pos          (1UL)                     /*!< SPI RTXINT: TXINTFLAG (Bit 1)                         */
N#define SPI_RTXINT_TXINTFLAG_Msk          (0x2UL)                   /*!< SPI RTXINT: TXINTFLAG (Bitfield-Mask: 0x01)           */
N/* ========================================================  FIFORST  ======================================================== */
N#define SPI_FIFORST_RXFIFORST_Pos         (0UL)                     /*!< SPI FIFORST: RXFIFORST (Bit 0)                        */
N#define SPI_FIFORST_RXFIFORST_Msk         (0x1UL)                   /*!< SPI FIFORST: RXFIFORST (Bitfield-Mask: 0x01)          */
N#define SPI_FIFORST_TXFIFORST_Pos         (1UL)                     /*!< SPI FIFORST: TXFIFORST (Bit 1)                        */
N#define SPI_FIFORST_TXFIFORST_Msk         (0x2UL)                   /*!< SPI FIFORST: TXFIFORST (Bitfield-Mask: 0x01)          */
N
N
N/* =========================================================================================================================== */
N/* ================                                           TIM32                                           ================ */
N/* =========================================================================================================================== */
N
N/* =========================================================  CTRL  ========================================================== */
N#define TIM32_CTRL_TIM32EN_Pos            (0UL)                     /*!< TIM32 CTRL: TIM32EN (Bit 0)                           */
N#define TIM32_CTRL_TIM32EN_Msk            (0x1UL)                   /*!< TIM32 CTRL: TIM32EN (Bitfield-Mask: 0x01)             */
N#define TIM32_CTRL_TIM32INTEN_Pos         (1UL)                     /*!< TIM32 CTRL: TIM32INTEN (Bit 1)                        */
N#define TIM32_CTRL_TIM32INTEN_Msk         (0x2UL)                   /*!< TIM32 CTRL: TIM32INTEN (Bitfield-Mask: 0x01)          */
N#define TIM32_CTRL_TIM32DIV_Pos           (2UL)                     /*!< TIM32 CTRL: TIM32DIV (Bit 2)                          */
N#define TIM32_CTRL_TIM32DIV_Msk           (0xcUL)                   /*!< TIM32 CTRL: TIM32DIV (Bitfield-Mask: 0x03)            */
N#define TIM32_CTRL_TIM32INTFLAG_Pos       (7UL)                     /*!< TIM32 CTRL: TIM32INTFLAG (Bit 7)                      */
N#define TIM32_CTRL_TIM32INTFLAG_Msk       (0x80UL)                  /*!< TIM32 CTRL: TIM32INTFLAG (Bitfield-Mask: 0x01)        */
N/* ==========================================================  CNT  ========================================================== */
N#define TIM32_CNT_COUNTER_Pos             (0UL)                     /*!< TIM32 CNT: COUNTER (Bit 0)                            */
N#define TIM32_CNT_COUNTER_Msk             (0xffffffffUL)            /*!< TIM32 CNT: COUNTER (Bitfield-Mask: 0xffffffff)        */
N/* ========================================================  RELOAD  ========================================================= */
N#define TIM32_RELOAD_RELOAD_Pos           (0UL)                     /*!< TIM32 RELOAD: RELOAD (Bit 0)                          */
N#define TIM32_RELOAD_RELOAD_Msk           (0xffffffffUL)            /*!< TIM32 RELOAD: RELOAD (Bitfield-Mask: 0xffffffff)      */
N
N
N/* =========================================================================================================================== */
N/* ================                                           UART                                            ================ */
N/* =========================================================================================================================== */
N
N/* =========================================================  DATA  ========================================================== */
N#define UART_DATA_DATA_Pos                (0UL)                     /*!< UART DATA: DATA (Bit 0)                               */
N#define UART_DATA_DATA_Msk                (0xffUL)                  /*!< UART DATA: DATA (Bitfield-Mask: 0xff)                 */
N/* ========================================================  STATUS  ========================================================= */
N#define UART_STATUS_RX_OVFL_FLAG_Pos      (3UL)                     /*!< UART STATUS: RX_OVFL_FLAG (Bit 3)                     */
N#define UART_STATUS_RX_OVFL_FLAG_Msk      (0x8UL)                   /*!< UART STATUS: RX_OVFL_FLAG (Bitfield-Mask: 0x01)       */
N#define UART_STATUS_TX_OVFL_FLAG_Pos      (2UL)                     /*!< UART STATUS: TX_OVFL_FLAG (Bit 2)                     */
N#define UART_STATUS_TX_OVFL_FLAG_Msk      (0x4UL)                   /*!< UART STATUS: TX_OVFL_FLAG (Bitfield-Mask: 0x01)       */
N#define UART_STATUS_RX_FULL_FLAG_Pos      (1UL)                     /*!< UART STATUS: RX_FULL_FLAG (Bit 1)                     */
N#define UART_STATUS_RX_FULL_FLAG_Msk      (0x2UL)                   /*!< UART STATUS: RX_FULL_FLAG (Bitfield-Mask: 0x01)       */
N#define UART_STATUS_TX_FULL_FLAG_Pos      (0UL)                     /*!< UART STATUS: TX_FULL_FLAG (Bit 0)                     */
N#define UART_STATUS_TX_FULL_FLAG_Msk      (0x1UL)                   /*!< UART STATUS: TX_FULL_FLAG (Bitfield-Mask: 0x01)       */
N/* =========================================================  CTRL  ========================================================== */
N#define UART_CTRL_RX_OVFL_INT_Pos         (5UL)                     /*!< UART CTRL: RX_OVFL_INT (Bit 5)                        */
N#define UART_CTRL_RX_OVFL_INT_Msk         (0x20UL)                  /*!< UART CTRL: RX_OVFL_INT (Bitfield-Mask: 0x01)          */
N#define UART_CTRL_TX_OVFL_INT_Pos         (4UL)                     /*!< UART CTRL: TX_OVFL_INT (Bit 4)                        */
N#define UART_CTRL_TX_OVFL_INT_Msk         (0x10UL)                  /*!< UART CTRL: TX_OVFL_INT (Bitfield-Mask: 0x01)          */
N#define UART_CTRL_RX_INT_Pos              (3UL)                     /*!< UART CTRL: RX_INT (Bit 3)                             */
N#define UART_CTRL_RX_INT_Msk              (0x8UL)                   /*!< UART CTRL: RX_INT (Bitfield-Mask: 0x01)               */
N#define UART_CTRL_TX_INT_Pos              (2UL)                     /*!< UART CTRL: TX_INT (Bit 2)                             */
N#define UART_CTRL_TX_INT_Msk              (0x4UL)                   /*!< UART CTRL: TX_INT (Bitfield-Mask: 0x01)               */
N#define UART_CTRL_RX_EN_Pos               (1UL)                     /*!< UART CTRL: RX_EN (Bit 1)                              */
N#define UART_CTRL_RX_EN_Msk               (0x2UL)                   /*!< UART CTRL: RX_EN (Bitfield-Mask: 0x01)                */
N#define UART_CTRL_TX_EN_Pos               (0UL)                     /*!< UART CTRL: TX_EN (Bit 0)                              */
N#define UART_CTRL_TX_EN_Msk               (0x1UL)                   /*!< UART CTRL: TX_EN (Bitfield-Mask: 0x01)                */
N/* ========================================================  INTFLAG  ======================================================== */
N#define UART_INTFLAG_RX_OVFL_INT_FLAG_Pos (3UL)                     /*!< UART INTFLAG: RX_OVFL_INT_FLAG (Bit 3)                */
N#define UART_INTFLAG_RX_OVFL_INT_FLAG_Msk (0x8UL)                   /*!< UART INTFLAG: RX_OVFL_INT_FLAG (Bitfield-Mask: 0x01)  */
N#define UART_INTFLAG_TX_OVFL_INT_FLAG_Pos (2UL)                     /*!< UART INTFLAG: TX_OVFL_INT_FLAG (Bit 2)                */
N#define UART_INTFLAG_TX_OVFL_INT_FLAG_Msk (0x4UL)                   /*!< UART INTFLAG: TX_OVFL_INT_FLAG (Bitfield-Mask: 0x01)  */
N#define UART_INTFLAG_RX_INT_FLAG_Pos      (1UL)                     /*!< UART INTFLAG: RX_INT_FLAG (Bit 1)                     */
N#define UART_INTFLAG_RX_INT_FLAG_Msk      (0x2UL)                   /*!< UART INTFLAG: RX_INT_FLAG (Bitfield-Mask: 0x01)       */
N#define UART_INTFLAG_TX_INT_FLAG_Pos      (0UL)                     /*!< UART INTFLAG: TX_INT_FLAG (Bit 0)                     */
N#define UART_INTFLAG_TX_INT_FLAG_Msk      (0x1UL)                   /*!< UART INTFLAG: TX_INT_FLAG (Bitfield-Mask: 0x01)       */
N/* =========================================================  BAUDM  ========================================================= */
N#define UART_BAUDM_MSB_Pos                (0UL)                     /*!< UART BAUDM: MSB (Bit 0)                               */
N#define UART_BAUDM_MSB_Msk                (0xffUL)                  /*!< UART BAUDM: MSB (Bitfield-Mask: 0xff)                 */
N/* =========================================================  BAUDL  ========================================================= */
N#define UART_BAUDL_LSB_Pos                (0UL)                     /*!< UART BAUDL: LSB (Bit 0)                               */
N#define UART_BAUDL_LSB_Msk                (0xffUL)                  /*!< UART BAUDL: LSB (Bitfield-Mask: 0xff)                 */
N/* =========================================================  BAUDF  ========================================================= */
N#define UART_BAUDF_FRC_Pos                (0UL)                     /*!< UART BAUDF: FRC (Bit 0)                               */
N#define UART_BAUDF_FRC_Msk                (0xffUL)                  /*!< UART BAUDF: FRC (Bitfield-Mask: 0xff)                 */
N
N
N/* =========================================================================================================================== */
N/* ================                                           GPIO                                            ================ */
N/* =========================================================================================================================== */
N
N/* ========================================================  GPFUNC0  ======================================================== */
N#define GPIO_GPFUNC0_FUNC_Pos             (0UL)                     /*!< GPIO GPFUNC0: FUNC (Bit 0)                            */
N#define GPIO_GPFUNC0_FUNC_Msk             (0x1fffUL)                /*!< GPIO GPFUNC0: FUNC (Bitfield-Mask: 0x1fff)            */
N/* ========================================================  GPFUNC1  ======================================================== */
N#define GPIO_GPFUNC1_FUNC_Pos             (0UL)                     /*!< GPIO GPFUNC1: FUNC (Bit 0)                            */
N#define GPIO_GPFUNC1_FUNC_Msk             (0x1fffUL)                /*!< GPIO GPFUNC1: FUNC (Bitfield-Mask: 0x1fff)            */
N/* =========================================================  GPOUT  ========================================================= */
N#define GPIO_GPOUT_OUT_Pos                (0UL)                     /*!< GPIO GPOUT: OUT (Bit 0)                               */
N#define GPIO_GPOUT_OUT_Msk                (0x1fffUL)                /*!< GPIO GPOUT: OUT (Bitfield-Mask: 0x1fff)               */
N/* =========================================================  GPIN  ========================================================== */
N#define GPIO_GPIN_IN_Pos                  (0UL)                     /*!< GPIO GPIN: IN (Bit 0)                                 */
N#define GPIO_GPIN_IN_Msk                  (0x1fffUL)                /*!< GPIO GPIN: IN (Bitfield-Mask: 0x1fff)                 */
N
N
N/* =========================================================================================================================== */
N/* ================                                           FLASH                                           ================ */
N/* =========================================================================================================================== */
N
N/* =======================================================  FLASHKEY  ======================================================== */
N#define FLASH_FLASHKEY_KEY_Pos            (0UL)                     /*!< FLASH FLASHKEY: KEY (Bit 0)                           */
N#define FLASH_FLASHKEY_KEY_Msk            (0xffffffffUL)            /*!< FLASH FLASHKEY: KEY (Bitfield-Mask: 0xffffffff)       */
N
N/** @} */ /* End of group PosMask_peripherals */
N
N
N/* =========================================================================================================================== */
N/* ================                           Enumerated Values Peripheral Section                            ================ */
N/* =========================================================================================================================== */
N
N
N/** @addtogroup EnumValue_peripherals
N  * @{
N  */
N
N
N
N/* =========================================================================================================================== */
N/* ================                                            WDT                                            ================ */
N/* =========================================================================================================================== */
N
N/* ==========================================================  CSR  ========================================================== */
N
N
N/* =========================================================================================================================== */
N/* ================                                            NFC                                            ================ */
N/* =========================================================================================================================== */
N
N/* ========================================================  SYSCTRL  ======================================================== */
N/* =======================================================  HARVCTRL  ======================================================== */
N/* =============================================  NFC HARVCTRL CAPCHTHH [0..2]  ============================================== */
Ntypedef enum {                                  /*!< NFC_HARVCTRL_CAPCHTHH                                                     */
N  NFC_HARVCTRL_CAPCHTHH_2V7            = 0,     /*!< 2V7 : 2.7V                                                                */
N  NFC_HARVCTRL_CAPCHTHH_3V3            = 1,     /*!< 3V3 : 3.3V                                                                */
N  NFC_HARVCTRL_CAPCHTHH_3V9            = 2,     /*!< 3V9 : 3.9V                                                                */
N  NFC_HARVCTRL_CAPCHTHH_4V5            = 3,     /*!< 4V5 : 4.5V                                                                */
N  NFC_HARVCTRL_CAPCHTHH_5V1            = 4,     /*!< 5V1 : 5.1V                                                                */
N  NFC_HARVCTRL_CAPCHTHH_6V3            = 5,     /*!< 6V3 : 6.3V                                                                */
N  NFC_HARVCTRL_CAPCHTHH_7V5            = 6,     /*!< 7V5 : 7.5V                                                                */
N  NFC_HARVCTRL_CAPCHTHH_8V7            = 7,     /*!< 8V7 : 8.7V                                                                */
N} NFC_HARVCTRL_CAPCHTHH_Enum;
N
N/* =============================================  NFC HARVCTRL CAPCHTHL [3..5]  ============================================== */
Ntypedef enum {                                  /*!< NFC_HARVCTRL_CAPCHTHL                                                     */
N  NFC_HARVCTRL_CAPCHTHL_2V4            = 0,     /*!< 2V4 : 2.4V                                                                */
N  NFC_HARVCTRL_CAPCHTHL_3V0            = 1,     /*!< 3V0 : 3.0V                                                                */
N  NFC_HARVCTRL_CAPCHTHL_3V6            = 2,     /*!< 3V6 : 3.6V                                                                */
N  NFC_HARVCTRL_CAPCHTHL_4V2            = 3,     /*!< 4V2 : 4.2V                                                                */
N  NFC_HARVCTRL_CAPCHTHL_4V8            = 4,     /*!< 4V8 : 4.8V                                                                */
N  NFC_HARVCTRL_CAPCHTHL_6V0            = 5,     /*!< 6V0 : 6.0V                                                                */
N  NFC_HARVCTRL_CAPCHTHL_7V2            = 6,     /*!< 7V2 : 7.2V                                                                */
N  NFC_HARVCTRL_CAPCHTHL_OFF            = 7,     /*!< OFF : OFF                                                                 */
N} NFC_HARVCTRL_CAPCHTHL_Enum;
N
N/* ============================================  NFC HARVCTRL CAPFORCECH [6..6]  ============================================= */
Ntypedef enum {                                  /*!< NFC_HARVCTRL_CAPFORCECH                                                   */
N  NFC_HARVCTRL_CAPFORCECH_OFF          = 0,     /*!< OFF : No force charging                                                   */
N  NFC_HARVCTRL_CAPFORCECH_ON           = 1,     /*!< ON : Force charging                                                       */
N} NFC_HARVCTRL_CAPFORCECH_Enum;
N
N/* ========================================================  OPCTRL  ========================================================= */
N/* ==============================================  NFC OPCTRL OPERMODE [0..1]  =============================================== */
Ntypedef enum {                                  /*!< NFC_OPCTRL_OPERMODE                                                       */
N  NFC_OPCTRL_OPERMODE_NORF             = 0,     /*!< NORF : NFC disabled                                                       */
N  NFC_OPCTRL_OPERMODE_NOEEP            = 1,     /*!< NOEEP : NFC no EEPROM access                                              */
N  NFC_OPCTRL_OPERMODE_EEPRO            = 2,     /*!< EEPRO : NFC EEPROM read-only                                              */
N  NFC_OPCTRL_OPERMODE_EEPRW            = 3,     /*!< EEPRW : NFC EEPROM read-write                                             */
N} NFC_OPCTRL_OPERMODE_Enum;
N
N/* =========================================================  POWER  ========================================================= */
N/* ===============================================  NFC POWER LDO18OPT [0..1]  =============================================== */
Ntypedef enum {                                  /*!< NFC_POWER_LDO18OPT                                                        */
N  NFC_POWER_LDO18OPT_1V5               = 0,     /*!< 1V5 : 1.588V                                                              */
N  NFC_POWER_LDO18OPT_1V6               = 1,     /*!< 1V6 : 1.6875V                                                             */
N  NFC_POWER_LDO18OPT_1V8               = 2,     /*!< 1V8 : 1.8V                                                                */
N  NFC_POWER_LDO18OPT_1V9               = 3,     /*!< 1V9 : 1.928V                                                              */
N} NFC_POWER_LDO18OPT_Enum;
N
N/* ===============================================  NFC POWER LDO33OPT [2..3]  =============================================== */
Ntypedef enum {                                  /*!< NFC_POWER_LDO33OPT                                                        */
N  NFC_POWER_LDO33OPT_2V7               = 0,     /*!< 2V7 : 2.7V                                                                */
N  NFC_POWER_LDO33OPT_3V                = 1,     /*!< 3V : 3V                                                                   */
N  NFC_POWER_LDO33OPT_3V3               = 2,     /*!< 3V3 : 3.375V                                                              */
N  NFC_POWER_LDO33OPT_3V8               = 3,     /*!< 3V8 : 3.857V                                                              */
N} NFC_POWER_LDO33OPT_Enum;
N
N/* ================================================  NFC POWER BGOPT [4..6]  ================================================= */
Ntypedef enum {                                  /*!< NFC_POWER_BGOPT                                                           */
N  NFC_POWER_BGOPT_750                  = 0,     /*!< 750 : 750mV                                                               */
N  NFC_POWER_BGOPT_714                  = 1,     /*!< 714 : 714mV                                                               */
N  NFC_POWER_BGOPT_677                  = 2,     /*!< 677 : 677mV                                                               */
N  NFC_POWER_BGOPT_640                  = 3,     /*!< 640 : 640mV                                                               */
N  NFC_POWER_BGOPT_604                  = 4,     /*!< 604 : 604mV                                                               */
N  NFC_POWER_BGOPT_567                  = 5,     /*!< 567 : 567mV                                                               */
N  NFC_POWER_BGOPT_531                  = 6,     /*!< 531 : 531mV                                                               */
N  NFC_POWER_BGOPT_494                  = 7,     /*!< 494 : 494mV                                                               */
N} NFC_POWER_BGOPT_Enum;
N
N/* ================================================  NFC POWER AVDD18 [7..7]  ================================================ */
Ntypedef enum {                                  /*!< NFC_POWER_AVDD18                                                          */
N  NFC_POWER_AVDD18_RISE                = 0,     /*!< RISE : Rise up AVDD18 upon powerup                                        */
N  NFC_POWER_AVDD18_NORISE              = 1,     /*!< NORISE : Do not rise up AVDD18 upon powerup                               */
N} NFC_POWER_AVDD18_Enum;
N
N/* ======================================================  BROWNOUT3V3  ====================================================== */
N/* =============================================  NFC BROWNOUT3V3 BROLVL [5..6]  ============================================= */
Ntypedef enum {                                  /*!< NFC_BROWNOUT3V3_BROLVL                                                    */
N  NFC_BROWNOUT3V3_BROLVL_2V3           = 0,     /*!< 2V3 : 2.3V                                                                */
N  NFC_BROWNOUT3V3_BROLVL_2V5           = 1,     /*!< 2V5 : 2.5V                                                                */
N  NFC_BROWNOUT3V3_BROLVL_2V7           = 2,     /*!< 2V7 : 2.7V                                                                */
N  NFC_BROWNOUT3V3_BROLVL_2V9           = 3,     /*!< 2V9 : 2.9V                                                                */
N} NFC_BROWNOUT3V3_BROLVL_Enum;
N
N/* ========================================================  RXCTRL  ========================================================= */
N/* ===============================================  NFC RXCTRL RXGAIN [0..0]  ================================================ */
Ntypedef enum {                                  /*!< NFC_RXCTRL_RXGAIN                                                         */
N  NFC_RXCTRL_RXGAIN_X2                 = 1,     /*!< X2 : X2 gain                                                              */
N  NFC_RXCTRL_RXGAIN_X1                 = 0,     /*!< X1 : X1 gain                                                              */
N} NFC_RXCTRL_RXGAIN_Enum;
N
N/* =============================================  NFC RXCTRL RXWAKEUPTH [2..4]  ============================================== */
Ntypedef enum {                                  /*!< NFC_RXCTRL_RXWAKEUPTH                                                     */
N  NFC_RXCTRL_RXWAKEUPTH_25             = 0,     /*!< 25 : 25mV                                                                 */
N  NFC_RXCTRL_RXWAKEUPTH_50             = 1,     /*!< 50 : 50mV                                                                 */
N  NFC_RXCTRL_RXWAKEUPTH_75             = 2,     /*!< 75 : 75mV                                                                 */
N  NFC_RXCTRL_RXWAKEUPTH_100            = 3,     /*!< 100 : 100mV                                                               */
N  NFC_RXCTRL_RXWAKEUPTH_125            = 4,     /*!< 125 : 125mV                                                               */
N  NFC_RXCTRL_RXWAKEUPTH_150            = 5,     /*!< 150 : 150mV                                                               */
N  NFC_RXCTRL_RXWAKEUPTH_175            = 6,     /*!< 175 : 175mV                                                               */
N  NFC_RXCTRL_RXWAKEUPTH_200            = 7,     /*!< 200 : 200mV                                                               */
N} NFC_RXCTRL_RXWAKEUPTH_Enum;
N
N/* ========================================================  TXCTRL  ========================================================= */
N/* =============================================  NFC TXCTRL TXPOLARITY [0..0]  ============================================== */
Ntypedef enum {                                  /*!< NFC_TXCTRL_TXPOLARITY                                                     */
N  NFC_TXCTRL_TXPOLARITY_NORMAL         = 0,     /*!< NORMAL : Normal polarity                                                  */
N  NFC_TXCTRL_TXPOLARITY_INV            = 1,     /*!< INV : Inverse polarity                                                    */
N} NFC_TXCTRL_TXPOLARITY_Enum;
N
N/* ======================================================  CAPCURCTRL  ======================================================= */
N/* =============================================  NFC CAPCURCTRL SOFTCUR [7..7]  ============================================= */
Ntypedef enum {                                  /*!< NFC_CAPCURCTRL_SOFTCUR                                                    */
N  NFC_CAPCURCTRL_SOFTCUR_ON            = 1,     /*!< ON : Enable                                                               */
N  NFC_CAPCURCTRL_SOFTCUR_OFF           = 0,     /*!< OFF : Disable                                                             */
N} NFC_CAPCURCTRL_SOFTCUR_Enum;
N
N/* =============================================  NFC CAPCURCTRL CAPCUR [5..6]  ============================================== */
Ntypedef enum {                                  /*!< NFC_CAPCURCTRL_CAPCUR                                                     */
N  NFC_CAPCURCTRL_CAPCUR_X1             = 0,     /*!< X1 : Normal current                                                       */
N  NFC_CAPCURCTRL_CAPCUR_X05            = 1,     /*!< X05 : Half current                                                        */
N  NFC_CAPCURCTRL_CAPCUR_X2             = 2,     /*!< X2 : Double current                                                       */
N} NFC_CAPCURCTRL_CAPCUR_Enum;
N
N/* ==========================================================  OSC  ========================================================== */
N/* ========================================================  NFCRTX  ========================================================= */
N/* ======================================================  CLKCALIBVAL  ====================================================== */
N/* ======================================================  MODULECTRL  ======================================================= */
N/* =======================================================  RXGLITCH  ======================================================== */
N/* ==============================================  NFC RXGLITCH GLITCH [0..1]  =============================================== */
Ntypedef enum {                                  /*!< NFC_RXGLITCH_GLITCH                                                       */
N  NFC_RXGLITCH_GLITCH_OFF              = 0,     /*!< OFF : Filter off                                                          */
N  NFC_RXGLITCH_GLITCH_2CLKS            = 1,     /*!< 2CLKS : 2 clocks                                                          */
N  NFC_RXGLITCH_GLITCH_4CLKS            = 2,     /*!< 4CLKS : 4 clocks                                                          */
N  NFC_RXGLITCH_GLITCH_6CLKS            = 3,     /*!< 6CLKS : 6 clocks                                                          */
N} NFC_RXGLITCH_GLITCH_Enum;
N
N/* ========================================================  STATUS  ========================================================= */
N/* ================================================  NFC STATUS RAMUD [0..0]  ================================================ */
Ntypedef enum {                                  /*!< NFC_STATUS_RAMUD                                                          */
N  NFC_STATUS_RAMUD_NOUD                = 0,     /*!< NOUD : No RAM update from NFC                                             */
N  NFC_STATUS_RAMUD_UD                  = 1,     /*!< UD : RAM updated from NFC                                                 */
N} NFC_STATUS_RAMUD_Enum;
N
N/* ================================================  NFC STATUS EEPUD [1..1]  ================================================ */
Ntypedef enum {                                  /*!< NFC_STATUS_EEPUD                                                          */
N  NFC_STATUS_EEPUD_NOUD                = 0,     /*!< NOUD : No EEP update from NFC                                             */
N  NFC_STATUS_EEPUD_UD                  = 1,     /*!< UD : EEP updated from NFC                                                 */
N} NFC_STATUS_EEPUD_Enum;
N
N/* ===============================================  NFC STATUS CAPCHOK [2..2]  =============================================== */
Ntypedef enum {                                  /*!< NFC_STATUS_CAPCHOK                                                        */
N  NFC_STATUS_CAPCHOK_NFULL             = 0,     /*!< NFULL : Capacitor not full                                                */
N  NFC_STATUS_CAPCHOK_FULL              = 1,     /*!< FULL : Capacitor full                                                     */
N} NFC_STATUS_CAPCHOK_Enum;
N
N/* ================================================  NFC STATUS BUSY [5..5]  ================================================= */
Ntypedef enum {                                  /*!< NFC_STATUS_BUSY                                                           */
N  NFC_STATUS_BUSY_NBUSY                = 0,     /*!< NBUSY : EEPROM not busy                                                   */
N  NFC_STATUS_BUSY_BUSY                 = 1,     /*!< BUSY : EEPROM busy                                                        */
N} NFC_STATUS_BUSY_Enum;
N
N/* ===============================================  NFC STATUS RFFIELD [6..6]  =============================================== */
Ntypedef enum {                                  /*!< NFC_STATUS_RFFIELD                                                        */
N  NFC_STATUS_RFFIELD_OFF               = 0,     /*!< OFF : No RF field                                                         */
N  NFC_STATUS_RFFIELD_ON                = 1,     /*!< ON : RF field is present                                                  */
N} NFC_STATUS_RFFIELD_Enum;
N
N/* ================================================  NFC STATUS RFON [7..7]  ================================================= */
Ntypedef enum {                                  /*!< NFC_STATUS_RFON                                                           */
N  NFC_STATUS_RFON_OFF                  = 0,     /*!< OFF : RF off                                                              */
N  NFC_STATUS_RFON_ON                   = 1,     /*!< ON : RF on                                                                */
N} NFC_STATUS_RFON_Enum;
N
N
N
N/* =========================================================================================================================== */
N/* ================                                            I2C                                            ================ */
N/* =========================================================================================================================== */
N
N/* =========================================================  ADDR0  ========================================================= */
N/* =================================================  I2C ADDR0 GCen [0..0]  ================================================= */
Ntypedef enum {                                  /*!< I2C_ADDR0_GCen                                                            */
N  I2C_ADDR0_GCen_ON                    = 1,     /*!< ON : General call enabled                                                 */
N  I2C_ADDR0_GCen_OFF                   = 0,     /*!< OFF : General call disabled                                               */
N} I2C_ADDR0_GCen_Enum;
N
N/* =========================================================  ADDR1  ========================================================= */
N/* =================================================  I2C ADDR1 GCen [0..0]  ================================================= */
Ntypedef enum {                                  /*!< I2C_ADDR1_GCen                                                            */
N  I2C_ADDR1_GCen_ON                    = 1,     /*!< ON : General call enabled                                                 */
N  I2C_ADDR1_GCen_OFF                   = 0,     /*!< OFF : General call disabled                                               */
N} I2C_ADDR1_GCen_Enum;
N
N/* =========================================================  DATA  ========================================================== */
N/* =========================================================  CTRL  ========================================================== */
N/* ==================================================  I2C CTRL AAK [2..2]  ================================================== */
Ntypedef enum {                                  /*!< I2C_CTRL_AAK                                                              */
N  I2C_CTRL_AAK_ACK                     = 1,     /*!< ACK : Enable ACK                                                          */
N  I2C_CTRL_AAK_NACK                    = 0,     /*!< NACK : Enable NACK                                                        */
N} I2C_CTRL_AAK_Enum;
N
N/* =================================================  I2C CTRL IFLG [3..3]  ================================================== */
Ntypedef enum {                                  /*!< I2C_CTRL_IFLG                                                             */
N  I2C_CTRL_IFLG_SET                    = 1,     /*!< SET : Interrupt set                                                       */
N  I2C_CTRL_IFLG_CLR                    = 0,     /*!< CLR : Interrupt clear                                                     */
N} I2C_CTRL_IFLG_Enum;
N
N/* =================================================  I2C CTRL ENAB [6..6]  ================================================== */
Ntypedef enum {                                  /*!< I2C_CTRL_ENAB                                                             */
N  I2C_CTRL_ENAB_ON                     = 1,     /*!< ON : Enabled                                                              */
N  I2C_CTRL_ENAB_OFF                    = 0,     /*!< OFF : Disabled                                                            */
N} I2C_CTRL_ENAB_Enum;
N
N/* ==================================================  I2C CTRL IEN [7..7]  ================================================== */
Ntypedef enum {                                  /*!< I2C_CTRL_IEN                                                              */
N  I2C_CTRL_IEN_ON                      = 1,     /*!< ON : Enabled                                                              */
N  I2C_CTRL_IEN_OFF                     = 0,     /*!< OFF : Disabled                                                            */
N} I2C_CTRL_IEN_Enum;
N
N/* ========================================================  STATUS  ========================================================= */
N/* ================================================  I2C STATUS STAT [0..7]  ================================================= */
Ntypedef enum {                                  /*!< I2C_STATUS_STAT                                                           */
N  I2C_STATUS_STAT_ERR                  = 0,     /*!< ERR : Bus Error                                                           */
N  I2C_STATUS_STAT_M_ST_TX              = 8,     /*!< M_ST_TX : Start Txed                                                      */
N  I2C_STATUS_STAT_M_ReST_TX            = 16,    /*!< M_ReST_TX : Restart Txed                                                  */
N  I2C_STATUS_STAT_M_ADRWTX_ACK         = 24,    /*!< M_ADRWTX_ACK : Address+W TXed and ACKed                                   */
N  I2C_STATUS_STAT_M_ADRWTX             = 32,    /*!< M_ADRWTX : Address+W TXed                                                 */
N  I2C_STATUS_STAT_M_TX_ACK             = 40,    /*!< M_TX_ACK : Data Txed and ACKed                                            */
N  I2C_STATUS_STAT_M_TX                 = 48,    /*!< M_TX : Data Txed                                                          */
N  I2C_STATUS_STAT_M_ADRRTX_ACK         = 64,    /*!< M_ADRRTX_ACK : Address+R TXed and ACKed                                   */
N  I2C_STATUS_STAT_M_ADRRTX             = 72,    /*!< M_ADRRTX : Address+R TXed                                                 */
N  I2C_STATUS_STAT_M_RX_ACK             = 80,    /*!< M_RX_ACK : Data RXed and ACKed                                            */
N  I2C_STATUS_STAT_M_RX_NACK            = 88,    /*!< M_RX_NACK : Data RXed and NACKed                                          */
N  I2C_STATUS_STAT_S_ADRW_ACK           = 96,    /*!< S_ADRW_ACK : Address+W RXed and ACKed                                     */
N  I2C_STATUS_STAT_S_GC_ACK             = 112,   /*!< S_GC_ACK : General call RXed and ACKed                                    */
N  I2C_STATUS_STAT_S_RX_ACK             = 128,   /*!< S_RX_ACK : Data RXed and ACKed                                            */
N  I2C_STATUS_STAT_S_RX_NACK            = 136,   /*!< S_RX_NACK : Data RXed and NACKed                                          */
N  I2C_STATUS_STAT_S_ReST               = 160,   /*!< S_ReST : Stop or Restart RXed                                             */
N  I2C_STATUS_STAT_S_ADRR_ACK           = 168,   /*!< S_ADRR_ACK : Address+R RXed and ACKed                                     */
N  I2C_STATUS_STAT_S_TX_ACK             = 184,   /*!< S_TX_ACK : Data TXed and ACKed                                            */
N  I2C_STATUS_STAT_S_TX                 = 192,   /*!< S_TX : Data TXed                                                          */
N  I2C_STATUS_STAT_S_TX_NACK            = 200,   /*!< S_TX_NACK : Data TXed and NACKed                                          */
N} I2C_STATUS_STAT_Enum;
N
N/* =========================================================  RESET  ========================================================= */
N
N
N/* =========================================================================================================================== */
N/* ================                                            SPI                                            ================ */
N/* =========================================================================================================================== */
N
N/* =======================================================  INTENCTRL  ======================================================= */
N/* =============================================  SPI INTENCTRL RXINTEN [0..0]  ============================================== */
Ntypedef enum {                                  /*!< SPI_INTENCTRL_RXINTEN                                                     */
N  SPI_INTENCTRL_RXINTEN_ON             = 1,     /*!< ON : Enabled                                                              */
N  SPI_INTENCTRL_RXINTEN_OFF            = 0,     /*!< OFF : Disabled                                                            */
N} SPI_INTENCTRL_RXINTEN_Enum;
N
N/* =============================================  SPI INTENCTRL TXINTEN [1..1]  ============================================== */
Ntypedef enum {                                  /*!< SPI_INTENCTRL_TXINTEN                                                     */
N  SPI_INTENCTRL_TXINTEN_ON             = 1,     /*!< ON : Enabled                                                              */
N  SPI_INTENCTRL_TXINTEN_OFF            = 0,     /*!< OFF : Disabled                                                            */
N} SPI_INTENCTRL_TXINTEN_Enum;
N
N/* ========================================================  RTXCTRL  ======================================================== */
N/* ================================================  SPI RTXCTRL RXEN [0..0]  ================================================ */
Ntypedef enum {                                  /*!< SPI_RTXCTRL_RXEN                                                          */
N  SPI_RTXCTRL_RXEN_ON                  = 1,     /*!< ON : Enabled                                                              */
N  SPI_RTXCTRL_RXEN_OFF                 = 0,     /*!< OFF : Disabled                                                            */
N} SPI_RTXCTRL_RXEN_Enum;
N
N/* ================================================  SPI RTXCTRL TXEN [1..1]  ================================================ */
Ntypedef enum {                                  /*!< SPI_RTXCTRL_TXEN                                                          */
N  SPI_RTXCTRL_TXEN_ON                  = 1,     /*!< ON : Enabled                                                              */
N  SPI_RTXCTRL_TXEN_OFF                 = 0,     /*!< OFF : Disabled                                                            */
N} SPI_RTXCTRL_TXEN_Enum;
N
N/* ========================================================  TXFIFO  ========================================================= */
N/* ========================================================  RXFIFO  ========================================================= */
N/* =====================================================  TXFIFOWMCTRL  ====================================================== */
N/* =====================================================  RXFIFOWMCTRL  ====================================================== */
N/* ========================================================  RTXINT  ========================================================= */
N/* ==============================================  SPI RTXINT RXINTFLAG [0..0]  ============================================== */
Ntypedef enum {                                  /*!< SPI_RTXINT_RXINTFLAG                                                      */
N  SPI_RTXINT_RXINTFLAG_ON              = 1,     /*!< ON : Interrupt pending                                                    */
N  SPI_RTXINT_RXINTFLAG_OFF             = 0,     /*!< OFF : No interrupt                                                        */
N} SPI_RTXINT_RXINTFLAG_Enum;
N
N/* ==============================================  SPI RTXINT TXINTFLAG [1..1]  ============================================== */
Ntypedef enum {                                  /*!< SPI_RTXINT_TXINTFLAG                                                      */
N  SPI_RTXINT_TXINTFLAG_ON              = 1,     /*!< ON : Interrupt pending                                                    */
N  SPI_RTXINT_TXINTFLAG_OFF             = 0,     /*!< OFF : No interrupt                                                        */
N} SPI_RTXINT_TXINTFLAG_Enum;
N
N/* ========================================================  FIFORST  ======================================================== */
N/* =============================================  SPI FIFORST RXFIFORST [0..0]  ============================================== */
Ntypedef enum {                                  /*!< SPI_FIFORST_RXFIFORST                                                     */
N  SPI_FIFORST_RXFIFORST_ON             = 1,     /*!< ON : Reset                                                                */
N  SPI_FIFORST_RXFIFORST_OFF            = 0,     /*!< OFF : Do not reset                                                        */
N} SPI_FIFORST_RXFIFORST_Enum;
N
N/* =============================================  SPI FIFORST TXFIFORST [1..1]  ============================================== */
Ntypedef enum {                                  /*!< SPI_FIFORST_TXFIFORST                                                     */
N  SPI_FIFORST_TXFIFORST_ON             = 1,     /*!< ON : Reset                                                                */
N  SPI_FIFORST_TXFIFORST_OFF            = 0,     /*!< OFF : Do not reset                                                        */
N} SPI_FIFORST_TXFIFORST_Enum;
N
N
N
N/* =========================================================================================================================== */
N/* ================                                           TIM32                                           ================ */
N/* =========================================================================================================================== */
N
N/* =========================================================  CTRL  ========================================================== */
N/* ===============================================  TIM32 CTRL TIM32EN [0..0]  =============================================== */
Ntypedef enum {                                  /*!< TIM32_CTRL_TIM32EN                                                        */
N  TIM32_CTRL_TIM32EN_ON                = 1,     /*!< ON : Enabled                                                              */
N  TIM32_CTRL_TIM32EN_OFF               = 0,     /*!< OFF : Disabled                                                            */
N} TIM32_CTRL_TIM32EN_Enum;
N
N/* =============================================  TIM32 CTRL TIM32INTEN [1..1]  ============================================== */
Ntypedef enum {                                  /*!< TIM32_CTRL_TIM32INTEN                                                     */
N  TIM32_CTRL_TIM32INTEN_ON             = 1,     /*!< ON : Enabled                                                              */
N  TIM32_CTRL_TIM32INTEN_OFF            = 0,     /*!< OFF : Disabled                                                            */
N} TIM32_CTRL_TIM32INTEN_Enum;
N
N/* ==============================================  TIM32 CTRL TIM32DIV [2..3]  =============================================== */
Ntypedef enum {                                  /*!< TIM32_CTRL_TIM32DIV                                                       */
N  TIM32_CTRL_TIM32DIV_1                = 0,     /*!< 1 : /1                                                                    */
N  TIM32_CTRL_TIM32DIV_2                = 1,     /*!< 2 : /2                                                                    */
N} TIM32_CTRL_TIM32DIV_Enum;
N
N/* ============================================  TIM32 CTRL TIM32INTFLAG [7..7]  ============================================= */
Ntypedef enum {                                  /*!< TIM32_CTRL_TIM32INTFLAG                                                   */
N  TIM32_CTRL_TIM32INTFLAG_INT_PEND     = 1,     /*!< INT_PEND : Interrupt pending                                              */
N  TIM32_CTRL_TIM32INTFLAG_NOINT        = 0,     /*!< NOINT : No interrupt                                                      */
N} TIM32_CTRL_TIM32INTFLAG_Enum;
N
N/* ==========================================================  CNT  ========================================================== */
N/* ========================================================  RELOAD  ========================================================= */
N
N
N/* =========================================================================================================================== */
N/* ================                                           UART                                            ================ */
N/* =========================================================================================================================== */
N
N/* =========================================================  DATA  ========================================================== */
N/* ========================================================  STATUS  ========================================================= */
N/* =========================================================  CTRL  ========================================================== */
N/* ========================================================  INTFLAG  ======================================================== */
N/* =========================================================  BAUDM  ========================================================= */
N/* =========================================================  BAUDL  ========================================================= */
N/* =========================================================  BAUDF  ========================================================= */
N
N
N/* =========================================================================================================================== */
N/* ================                                           GPIO                                            ================ */
N/* =========================================================================================================================== */
N
N/* ========================================================  GPFUNC0  ======================================================== */
N/* ========================================================  GPFUNC1  ======================================================== */
N/* =========================================================  GPOUT  ========================================================= */
N/* =========================================================  GPIN  ========================================================== */
N
N
N/* =========================================================================================================================== */
N/* ================                                           FLASH                                           ================ */
N/* =========================================================================================================================== */
N
N/* =======================================================  FLASHKEY  ======================================================== */
N
N/** @} */ /* End of group EnumValue_peripherals */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* TN2115S1_H */
N
N
N/** @} */ /* End of group TN2115s1 */
N
N/** @} */ /* End of group Fusens Micro Ltd. */
L 69 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N#include "TN2115s_oslib.h"
L 1 ".\APP\TN2115s_libs\TN2115s_oslib.h" 1
N#include "macros.h"
L 1 ".\APP\TN2115s_libs\macros.h" 1
N#ifndef __MACROS_H__
N#define __MACROS_H__
N
N/*###################################################################
NSection:
N						Macros
N###################################################################*/
N/*--------Library Global Macros---------*/
N#define SET_BIT(REG, BIT)     ((REG) |= (BIT))
N#define CLEAR_BIT(REG, BIT)   ((REG) &= ~(BIT))
N#define READ_BIT(REG, BIT)    ((REG) & (BIT))
N#define CLEAR_REG(REG)        ((REG) = (0x0))
N#define WRITE_REG(REG, VAL)   ((REG) = (VAL))
N#define READ_REG(REG)         ((REG))
N#define MODIFY_REG(REG, CLEARMASK, SETMASK)  WRITE_REG((REG), (((READ_REG(REG)) & (~(CLEARMASK))) | (SETMASK)))
N#define POSITION_VAL(VAL)     (__CLZ(__RBIT(VAL)))
N
N#define TAG_EEPROM_BASE	  			((uint32_t)0x60000000U)
N#define TAG_RAM_BASE	    			((uint32_t)0x80000000U)
N#define TAG_RSV_BASE						((uint32_t)0x60000800U - sizeof(RSVDATA))
N#define	TAG_ID_BASE							TAG_RSV_BASE
N#define	TAG_RCCAL_BASE					(TAG_RSV_BASE + sizeof(CHIPID))
N#define TAG_REG_EEPROM_BASE			(TAG_RSV_BASE + sizeof(RSVDATA) - 16)
N
N/*--------NFC Macros---------*/
N//TAG state machine
N#define IDLE        0
N#define HALT        1
N#define READY0      2
N#define READY1      3
N#define CLI1_DONE0  4
N#define CLI1_DONE1  5
N#define ACTIVE0     6
N#define ACTIVE1     7
N
N//Harvester Current 
N#define	CUR1X					0x00
N#define CUR0_5X				0x20
N#define CUR2X					0x40
N
N
N/*--------Readout Protection Macros---------*/
N//#define RDP_ACTIVE		0xffffffff
N
N/*--------GPIO Macros---------*/
N#define		 GPIO_PIN_PWRGOOD								(1<<0)
N#define		 GPIO_PIN_BUSY									(1<<1)
N#define		 GPIO_PIN_DATA									(1<<2)
N#define		 GPIO_PIN_SWDIO									(1<<3)
N#define		 GPIO_PIN_SWDCLK								(1<<4)
N#define		 GPIO_PIN_TXD										(1<<5)
N#define		 GPIO_PIN_RXD										(1<<6)
N#define		 GPIO_PIN_SIOTXD								(1<<7)
N#define		 GPIO_PIN_SIORXD								(1<<8)
N#define		 GPIO_PIN_SIOSS									(1<<9)
N#define		 GPIO_PIN_SIOCLK								(1<<10)
N#define		 GPIO_PIN_SIOSCL								(1<<11)
N#define		 GPIO_PIN_SIOSDA								(1<<12)
N
N/*--------HW IIC Macros---------*/
N#define I2C_IDLE					0
N
N#define I2C_RD_RQST				10
N#define I2C_RD_DONE				12
N
N#define I2C_WR_RQST				20
N#define I2C_WR_DONE				22
N
N
N/*###################################################################
NSection:
N						Type Definitions
N###################################################################*/
N/*--------HW IIC---------*/
Ntypedef struct
N{
N	uint8_t *     i2c_rx_buf;
N	uint8_t *     i2c_tx_buf;
N  uint16_t      i2c_rxed_bytes;
N  uint16_t      i2c_txed_bytes;
N	uint16_t			i2c_totx_bytes;
N	uint16_t			max_buf;
N}I2C_RTX;
N
Ntypedef struct
N{
N	bool			isMaster;
X	_Bool			isMaster;
N	uint8_t * i2c_rx_buf;
N	uint8_t		max_buf_len;
N	uint8_t		i2c_addr;
N	
N}I2C_INIT;
N
N/*--------SW SPI---------*/
Ntypedef struct{
N	bool 			isMaster;
X	_Bool 			isMaster;
N	uint8_t		mode;
N	uint16_t	SPIM_MISO_PIN;
N	uint16_t	SPIM_MOSI_PIN;
N	uint16_t 	SPIM_CS_PIN;	
N	uint16_t	SPIM_CLK_PIN;
N	
N}SPI_INIT;
N
N/*--------Reserved data structure---------*/
Ntypedef struct{
N  uint8_t       type[10];
N  uint8_t       year;
N  uint8_t       week;
N	uint8_t       batch_number[5];
N	uint8_t       pad_number;
N  uint8_t       pos_x;
N  uint8_t       pos_y;
N	uint8_t       pad[12];
N}CHIPID;
N
Ntypedef struct{
N	uint32_t std_mem_top;
N	uint32_t usr_rsv_mem_top;
N	uint32_t sys_rsv_mem_top;
N	uint32_t cfg_rsv_mem_top;
N	uint32_t checksum;
N	uint8_t	 pad[28];
N	
N}TAG_MEM_CFG;
N
Ntypedef struct{
N  CHIPID        uid;
N  uint16_t      RC_cal[16];
N  TAG_MEM_CFG   mem_cfg;
N  uint8_t       SYS_cfg[16];
N    
N}RSVDATA;
N
N#define I2C_MEMSIZE_8BIT            (1)
N#define I2C_MEMSIZE_16BIT           (2)
N
Ntypedef struct
N{
N
N	uint16_t pin_scl;
N	uint16_t pin_sda;
N
N} SoftI2C_Typedef;
N/*###################################################################
NSection:
N						RTOS macros
N###################################################################*/
N
N
N
N
N#endif
N
N
L 2 ".\APP\TN2115s_libs\TN2115s_oslib.h" 2
N#ifndef TN2115s_H__
N#define TN2115s_H__
N
N/*###################################################################
NSection:
N						Library Exported User Functions and Variables
N###################################################################*/
N
N/*--------Exported Functions---------*/
N//Global
Nvoid 			init_core_components(void);																				//must be called before calling other library functions
N#define 	osLaunchRTOS()		xTaskCreate( (TaskFunction_t)osSYSCORE_task, "SYSCORE", configMINIMAL_STACK_SIZE, NULL, 11, &SYSCORE_id );\
N														xTaskCreate( (TaskFunction_t)osSYSAUX_task, "SYSAUX", configMINIMAL_STACK_SIZE, NULL, 10, &SYSAUX_id );\
N														vTaskStartScheduler()														
X#define 	osLaunchRTOS()		xTaskCreate( (TaskFunction_t)osSYSCORE_task, "SYSCORE", configMINIMAL_STACK_SIZE, NULL, 11, &SYSCORE_id );														xTaskCreate( (TaskFunction_t)osSYSAUX_task, "SYSAUX", configMINIMAL_STACK_SIZE, NULL, 10, &SYSAUX_id );														vTaskStartScheduler()														
N//NFC																									
Nbool 			NFC_Passthrough_TX(uint8_t data[], uint8_t len);									//function for implementing type4 tx functions. data[]: type4 data to transmit; 
X_Bool 			NFC_Passthrough_TX(uint8_t data[], uint8_t len);									
N																																						//len: number of bytes to transmit. return: true indicates success. false indicates failure.
Nuint8_t 	NFC_Passthrough_RX(uint8_t data[]);																//function for implementing type4 rx functions. data[]: received type4 data.; 
N																																						//return: number of bytes received. 0 indicates that no type4 data received.
Nvoid 			NFC_HARV_AHC(bool onoff);																					//function for controlling automatic NFC energy harvesting. The harvesting will start when NFC is ready. default is enabled.
Xvoid 			NFC_HARV_AHC(_Bool onoff);																					
Nvoid 			NFC_HARV_force_AHC(void);																					//function for forcely enabling AHC regardless of NFC status. 
Nbool 			isNFC_field_on(void);																							//function returns the detection result of NFC field
X_Bool 			isNFC_field_on(void);																							
N//FLASH
Nvoid 			FLASH_lock (bool lock);																						//function for lock/unlock the code rom. always lock the rom when not intending to write
Xvoid 			FLASH_lock (_Bool lock);																						
N//Registers
Nvoid 			reg_update_system(uint8_t reg, uint8_t value);										//function for writing the system register
Nuint8_t 	reg_get_value(uint8_t reg);																				//function for reading the system register
N//IIC 
Nvoid 			I2C_enable(I2C_INIT * i2c_init);																	//HW i2c initiator. a user buffer address could be provided for data rx/tx. 
N																																						//if left zero(NULL), a default internal buffer will be used instead.
N//SoftI2C
Nvoid 			SoftI2C_Init(SoftI2C_Typedef *ops);
Nuint8_t 	i2c_CheckDevice(SoftI2C_Typedef *ops,uint8_t _Address);
Nuint8_t 	i2c_master_send(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint8_t* pBuffer,uint16_t usize);
Nuint8_t 	i2c_master_receive(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint8_t* pBuffer,uint16_t usize);
Nuint8_t 	i2c_mem_write(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint16_t regAddr,uint16_t MemAddressSize,uint8_t* pBuffer,uint16_t usize);
Nuint8_t 	i2c_mem_read(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint16_t regAddr,uint8_t MemAddressSize,uint8_t* pBuffer,uint16_t usize);
N																																						//Only slave is implemented, so isMaster must be set to false.
N//GPIO
Nvoid 			GPIO_SET_FUNC_MODE(uint16_t mask);																//set pin to special function mode
Nvoid 			GPIO_SET_INPUT_MODE(uint16_t mask);																//set pin to input mode
Nvoid 			GPIO_SET_OUTPUT_MODE(uint16_t mask);															//set pin to output mode
Nvoid 			GPIO_SET_TEST_MODE(uint16_t mask);
Nvoid 			GPIO_SET_PIN(uint16_t mask);																			//set pin output to high
Nvoid 			GPIO_CLR_PIN(uint16_t mask);																			//set pin output to low
Nvoid 			GPIO_TOG_PIN(uint16_t mask);
Nbool 			GPIO_GET_PIN(uint16_t mask);																			//get input pin value
X_Bool 			GPIO_GET_PIN(uint16_t mask);																			
Nvoid 			EXTI_EnableRisingTrig(uint16_t mask);
Nvoid 			EXTI_EnableFallingTrig(uint16_t mask);
Nvoid 			EXTI_EnableRFTrig(uint16_t mask);
Nbool 			EXIT_GET_INTFLG(uint16_t mask);
X_Bool 			EXIT_GET_INTFLG(uint16_t mask);
N//UART
Nvoid 			UART_init(uint32_t baud);																					//UART init function. baud: the desired baudrate
Nbool 			UART_tx_byte(uint8_t data);																				//TX one byte. return: true - successful, false - TX is unavailable
X_Bool 			UART_tx_byte(uint8_t data);																				
Nuint8_t 	UART_rx_byte(void);																								//read the RX buffer
Nvoid 			UART_tx_buf_poll(uint8_t * buf, uint8_t len);											//TX a buffer of data using block mode(polling)
Nbool 			UART_tx_buf_int(uint8_t * txbuf, uint8_t len);										//TX a buffer of data using non-block mode(interrupt). return: true - successsful
X_Bool 			UART_tx_buf_int(uint8_t * txbuf, uint8_t len);										
N																																						//false - another buffer is being transmitted.
Nvoid 			UART_tx_terminate(void);																					//terminate a non-blocking TX buffer transmission session
Nuint8_t 	UART_rx_chk(void);																								//check how many bytes received
Nbool 			UART_rx_get(uint8_t * rx_buf);																	  //get all received bytes
X_Bool 			UART_rx_get(uint8_t * rx_buf);																	  
N
N//SPI (Software master only now, slave mode is coming shortly)
Nvoid 			SPI_init(SPI_INIT * spi_init);																		// SPI initialization. isMaster: master/slave mode (only support master now)
N																																						// mode: SPI working mode(polarity/phase)
N																																						// Only mater is implemented, so isMaster must be set to true.
Nuint8_t 	SPIM_rtx_byte(uint8_t tx_data);																		// SPI tx and rx a byte of data
Nvoid 			SPIM_tx_byte(uint8_t tx_data);																		// SPI tx a byte
Nuint8_t 	SPIM_rx_byte(uint8_t rx_data);																		// SPI rx a byte
Nuint8_t * SPIM_rtx_buf(uint8_t tx_data[], uint8_t rx_data[], uint16_t len);	// SPI tx and rx a buffer of data
Nvoid 			SPIM_tx_buf(uint8_t tx_data[], uint16_t len);											// SPI tx a buffer of data
Nuint8_t * SPIM_rx_buf(uint8_t rx_data[], uint16_t len);											// SPI rx a buffer of data
N//bool 			SPIS_tx_buf(uint8_t * txbuf, uint8_t len);											
N//uint8_t 	SPIS_rx_chk(void);
N//bool 			SPIS_rx_get(uint8_t * rx_buf);
N
N//OTA update utility
Nvoid enter_OTA(void);																												// enter bootloader for NFC OTA
N
N/*--------Callbacks: Implemented in the user's code-------*/ 
N// NFC
Nvoid 			NFC_RX_Callback(void);																	//optional, called each time after a command is received
Nvoid 			NFC_TX_Callback(void);																	//optional, called each time after a response finished transmitting
Nvoid 			NFC_FIELD_OFF_Callback(void);														//optional, called each time the NFC field turns down
Nvoid 			NFC_FIELD_ON_Callback(void);														//optional, called each time the NFC field turns up
N// IIC(support is on the way)
Nbool 			I2C_SLV_RD_RQST_Callback(I2C_RTX *);										//required, called each time a data read request is received on the IIC. user must provide the data to be read in the I2C_RTX structure
X_Bool 			I2C_SLV_RD_RQST_Callback(I2C_RTX *);										
Nvoid 			I2C_SLV_WR_DONE_Callback(I2C_RTX *);										//required, called each time a write is done. the received data is stored in the I2C_RTX structure
N/*--------Exported Variables------------------*/
N// NFC variables
Nextern uint8_t	 							nfc_a_tag_state;										// Tag current state machine status
Nextern uint8_t *  						nfc_mem;													// Tag EEPROM in 8bit
Nextern uint32_t * 						nfc_mem_32;											// Tag EEPROM in 32bit
N/*--------Configurator Variables: Implemented in the user's code------------*/ 
N// Default HW Configuration
Nextern uint8_t *							def_sreg;										// optional, default register values. Config using: const uint8_t def_sreg[16] __attribute__((at(TAG_REG_EEPROM_BASE))) = {};
Nextern const 	uint8_t 				def_tag[32];								// optional, default tag content. Config using: const uint8_t def_tag[32] __attribute__((at(TAG_EEPROM_BASE))) = {};
Nextern uint8_t								*tag_in_ram;							// set the tag memory location. when equal to zero, tag locate in eeprom(false). Set to ram location to place memory in ram.
N// Readout Protection
Nextern const uint32_t 				rdp_word0;									// optional, by default RP is disabled.  								 
Nextern const uint32_t 				rdp_word1;									// optional, by default RP is disabled. 
Nextern const uint32_t 				rdp_word2;									// optional, by default RP is disabled. 
Nextern const uint32_t 				rdp_word3;									// optional, by default RP is disabled. 
N// RC OSC Constants
Nextern uint16_t * rc_setting_frq;													// required by UART and system timer 			
N// System Information
Nextern RSVDATA * sysinfo;																	// System reserved information
N
N/*###################################################################
NSection:
N						Library Exported Internal Functions and Variables
N###################################################################*/
N
Nvoid 			osSYSCORE_task(void);
Nvoid 			osSYSAUX_task(void);
Nint32_t 	osTick_Setup (uint32_t freq);
Nvoid 			vApplicationIdleHook(void);
N#endif
L 70 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\FreeRTOS.h" 2
N	
N/* Must be defaulted before configUSE_NEWLIB_REENTRANT is used below. */
N#ifndef configUSE_NEWLIB_REENTRANT
N	#define configUSE_NEWLIB_REENTRANT 0
N#endif
N
N/* Required if struct _reent is used. */
N#if ( configUSE_NEWLIB_REENTRANT == 1 )
X#if ( 0 == 1 )
S	#include <reent.h>
N#endif
N/*
N * Check all the required application specific macros have been defined.
N * These macros are application specific and (as downloaded) are defined
N * within FreeRTOSConfig.h.
N */
N
N#ifndef configMINIMAL_STACK_SIZE
S	#error Missing definition:  configMINIMAL_STACK_SIZE must be defined in FreeRTOSConfig.h.  configMINIMAL_STACK_SIZE defines the size (in words) of the stack allocated to the idle task.  Refer to the demo project provided for your port for a suitable value.
N#endif
N
N#ifndef configMAX_PRIORITIES
S	#error Missing definition:  configMAX_PRIORITIES must be defined in FreeRTOSConfig.h.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#if configMAX_PRIORITIES < 1
X#if 12 < 1
S	#error configMAX_PRIORITIES must be defined to be greater than or equal to 1.
N#endif
N
N#ifndef configUSE_PREEMPTION
S	#error Missing definition:  configUSE_PREEMPTION must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_IDLE_HOOK
S	#error Missing definition:  configUSE_IDLE_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_TICK_HOOK
S	#error Missing definition:  configUSE_TICK_HOOK must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_16_BIT_TICKS
S	#error Missing definition:  configUSE_16_BIT_TICKS must be defined in FreeRTOSConfig.h as either 1 or 0.  See the Configuration section of the FreeRTOS API documentation for details.
N#endif
N
N#ifndef configUSE_CO_ROUTINES
N	#define configUSE_CO_ROUTINES 0
N#endif
N
N#ifndef INCLUDE_vTaskPrioritySet
S	#define INCLUDE_vTaskPrioritySet 0
N#endif
N
N#ifndef INCLUDE_uxTaskPriorityGet
S	#define INCLUDE_uxTaskPriorityGet 0
N#endif
N
N#ifndef INCLUDE_vTaskDelete
S	#define INCLUDE_vTaskDelete 0
N#endif
N
N#ifndef INCLUDE_vTaskSuspend
S	#define INCLUDE_vTaskSuspend 0
N#endif
N
N#ifndef INCLUDE_vTaskDelayUntil
S	#define INCLUDE_vTaskDelayUntil 0
N#endif
N
N#ifndef INCLUDE_vTaskDelay
S	#define INCLUDE_vTaskDelay 0
N#endif
N
N#ifndef INCLUDE_xTaskGetIdleTaskHandle
N	#define INCLUDE_xTaskGetIdleTaskHandle 0
N#endif
N
N#ifndef INCLUDE_xTaskAbortDelay
N	#define INCLUDE_xTaskAbortDelay 0
N#endif
N
N#ifndef INCLUDE_xQueueGetMutexHolder
N	#define INCLUDE_xQueueGetMutexHolder 0
N#endif
N
N#ifndef INCLUDE_xSemaphoreGetMutexHolder
S	#define INCLUDE_xSemaphoreGetMutexHolder INCLUDE_xQueueGetMutexHolder
N#endif
N
N#ifndef INCLUDE_xTaskGetHandle
N	#define INCLUDE_xTaskGetHandle 0
N#endif
N
N#ifndef INCLUDE_uxTaskGetStackHighWaterMark
S	#define INCLUDE_uxTaskGetStackHighWaterMark 0
N#endif
N
N#ifndef INCLUDE_eTaskGetState
S	#define INCLUDE_eTaskGetState 0
N#endif
N
N#ifndef INCLUDE_xTaskResumeFromISR
N	#define INCLUDE_xTaskResumeFromISR 1
N#endif
N
N#ifndef INCLUDE_xTimerPendFunctionCall
S	#define INCLUDE_xTimerPendFunctionCall 0
N#endif
N
N#ifndef INCLUDE_xTaskGetSchedulerState
S	#define INCLUDE_xTaskGetSchedulerState 0
N#endif
N
N#ifndef INCLUDE_xTaskGetCurrentTaskHandle
S	#define INCLUDE_xTaskGetCurrentTaskHandle 0
N#endif
N
N#if configUSE_CO_ROUTINES != 0
X#if 0 != 0
S	#ifndef configMAX_CO_ROUTINE_PRIORITIES
S		#error configMAX_CO_ROUTINE_PRIORITIES must be greater than or equal to 1.
S	#endif
N#endif
N
N#ifndef configUSE_DAEMON_TASK_STARTUP_HOOK
S	#define configUSE_DAEMON_TASK_STARTUP_HOOK 0
N#endif
N
N#ifndef configUSE_APPLICATION_TASK_TAG
N	#define configUSE_APPLICATION_TASK_TAG 0
N#endif
N
N#ifndef configNUM_THREAD_LOCAL_STORAGE_POINTERS
N	#define configNUM_THREAD_LOCAL_STORAGE_POINTERS 0
N#endif
N
N#ifndef configUSE_RECURSIVE_MUTEXES
S	#define configUSE_RECURSIVE_MUTEXES 0
N#endif
N
N#ifndef configUSE_MUTEXES
S	#define configUSE_MUTEXES 0
N#endif
N
N#ifndef configUSE_TIMERS
S	#define configUSE_TIMERS 0
N#endif
N
N#ifndef configUSE_COUNTING_SEMAPHORES
S	#define configUSE_COUNTING_SEMAPHORES 0
N#endif
N
N#ifndef configUSE_ALTERNATIVE_API
N	#define configUSE_ALTERNATIVE_API 0
N#endif
N
N#ifndef portCRITICAL_NESTING_IN_TCB
N	#define portCRITICAL_NESTING_IN_TCB 0
N#endif
N
N#ifndef configMAX_TASK_NAME_LEN
N	#define configMAX_TASK_NAME_LEN 16
N#endif
N
N#ifndef configIDLE_SHOULD_YIELD
S	#define configIDLE_SHOULD_YIELD		1
N#endif
N
N#if configMAX_TASK_NAME_LEN < 1
X#if 16 < 1
S	#error configMAX_TASK_NAME_LEN must be set to a minimum of 1 in FreeRTOSConfig.h
N#endif
N
N#ifndef configASSERT
N	#define configASSERT( x )
N	#define configASSERT_DEFINED 0
N#else
S	#define configASSERT_DEFINED 1
N#endif
N
N/* The timers module relies on xTaskGetSchedulerState(). */
N#if configUSE_TIMERS == 1
X#if 0 == 1
S
S	#ifndef configTIMER_TASK_PRIORITY
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_PRIORITY must also be defined.
S	#endif /* configTIMER_TASK_PRIORITY */
S
S	#ifndef configTIMER_QUEUE_LENGTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_QUEUE_LENGTH must also be defined.
S	#endif /* configTIMER_QUEUE_LENGTH */
S
S	#ifndef configTIMER_TASK_STACK_DEPTH
S		#error If configUSE_TIMERS is set to 1 then configTIMER_TASK_STACK_DEPTH must also be defined.
S	#endif /* configTIMER_TASK_STACK_DEPTH */
S
N#endif /* configUSE_TIMERS */
N
N#ifndef portSET_INTERRUPT_MASK_FROM_ISR
S	#define portSET_INTERRUPT_MASK_FROM_ISR() 0
N#endif
N
N#ifndef portCLEAR_INTERRUPT_MASK_FROM_ISR
S	#define portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedStatusValue ) ( void ) uxSavedStatusValue
N#endif
N
N#ifndef portCLEAN_UP_TCB
N	#define portCLEAN_UP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef portPRE_TASK_DELETE_HOOK
N	#define portPRE_TASK_DELETE_HOOK( pvTaskToDelete, pxYieldPending )
N#endif
N
N#ifndef portSETUP_TCB
N	#define portSETUP_TCB( pxTCB ) ( void ) pxTCB
N#endif
N
N#ifndef configQUEUE_REGISTRY_SIZE
S	#define configQUEUE_REGISTRY_SIZE 0U
N#endif
N
N#if ( configQUEUE_REGISTRY_SIZE < 1 )
X#if ( 0 < 1 )
N	#define vQueueAddToRegistry( xQueue, pcName )
N	#define vQueueUnregisterQueue( xQueue )
N	#define pcQueueGetName( xQueue )
N#endif
N
N#ifndef portPOINTER_SIZE_TYPE
N	#define portPOINTER_SIZE_TYPE uint32_t
N#endif
N
N/* Remove any unused trace macros. */
N#ifndef traceSTART
N	/* Used to perform any necessary initialisation - for example, open a file
N	into which trace is to be written. */
N	#define traceSTART()
N#endif
N
N#ifndef traceEND
N	/* Use to close a trace, for example close a file into which trace has been
N	written. */
N	#define traceEND()
N#endif
N
N#ifndef traceTASK_SWITCHED_IN
N	/* Called after a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the selected task. */
N	#define traceTASK_SWITCHED_IN()
N#endif
N
N#ifndef traceINCREASE_TICK_COUNT
N	/* Called before stepping the tick count after waking from tickless idle
N	sleep. */
N	#define traceINCREASE_TICK_COUNT( x )
N#endif
N
N#ifndef traceLOW_POWER_IDLE_BEGIN
N	/* Called immediately before entering tickless idle. */
N	#define traceLOW_POWER_IDLE_BEGIN()
N#endif
N
N#ifndef	traceLOW_POWER_IDLE_END
N	/* Called when returning to the Idle task after a tickless idle. */
N	#define traceLOW_POWER_IDLE_END()
N#endif
N
N#ifndef traceTASK_SWITCHED_OUT
N	/* Called before a task has been selected to run.  pxCurrentTCB holds a pointer
N	to the task control block of the task being switched out. */
N	#define traceTASK_SWITCHED_OUT()
N#endif
N
N#ifndef traceTASK_PRIORITY_INHERIT
N	/* Called when a task attempts to take a mutex that is already held by a
N	lower priority task.  pxTCBOfMutexHolder is a pointer to the TCB of the task
N	that holds the mutex.  uxInheritedPriority is the priority the mutex holder
N	will inherit (the priority of the task that is attempting to obtain the
N	muted. */
N	#define traceTASK_PRIORITY_INHERIT( pxTCBOfMutexHolder, uxInheritedPriority )
N#endif
N
N#ifndef traceTASK_PRIORITY_DISINHERIT
N	/* Called when a task releases a mutex, the holding of which had resulted in
N	the task inheriting the priority of a higher priority task.
N	pxTCBOfMutexHolder is a pointer to the TCB of the task that is releasing the
N	mutex.  uxOriginalPriority is the task's configured (base) priority. */
N	#define traceTASK_PRIORITY_DISINHERIT( pxTCBOfMutexHolder, uxOriginalPriority )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_RECEIVE
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_PEEK
N	/* Task is about to block because it cannot read from a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the read was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the read. */
N	#define traceBLOCKING_ON_QUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceBLOCKING_ON_QUEUE_SEND
N	/* Task is about to block because it cannot write to a
N	queue/mutex/semaphore.  pxQueue is a pointer to the queue/mutex/semaphore
N	upon which the write was attempted.  pxCurrentTCB points to the TCB of the
N	task that attempted the write. */
N	#define traceBLOCKING_ON_QUEUE_SEND( pxQueue )
N#endif
N
N#ifndef configCHECK_FOR_STACK_OVERFLOW
S	#define configCHECK_FOR_STACK_OVERFLOW 0
N#endif
N
N#ifndef configRECORD_STACK_HIGH_ADDRESS
N	#define configRECORD_STACK_HIGH_ADDRESS 0
N#endif
N
N#ifndef configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H
N	#define configINCLUDE_FREERTOS_TASK_C_ADDITIONS_H 0
N#endif
N
N/* The following event macros are embedded in the kernel API calls. */
N
N#ifndef traceMOVED_TASK_TO_READY_STATE
N	#define traceMOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef tracePOST_MOVED_TASK_TO_READY_STATE
N	#define tracePOST_MOVED_TASK_TO_READY_STATE( pxTCB )
N#endif
N
N#ifndef traceQUEUE_CREATE
N	#define traceQUEUE_CREATE( pxNewQueue )
N#endif
N
N#ifndef traceQUEUE_CREATE_FAILED
N	#define traceQUEUE_CREATE_FAILED( ucQueueType )
N#endif
N
N#ifndef traceCREATE_MUTEX
N	#define traceCREATE_MUTEX( pxNewQueue )
N#endif
N
N#ifndef traceCREATE_MUTEX_FAILED
N	#define traceCREATE_MUTEX_FAILED()
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE
N	#define traceGIVE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceGIVE_MUTEX_RECURSIVE_FAILED
N	#define traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE
N	#define traceTAKE_MUTEX_RECURSIVE( pxMutex )
N#endif
N
N#ifndef traceTAKE_MUTEX_RECURSIVE_FAILED
N	#define traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex )
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE
N	#define traceCREATE_COUNTING_SEMAPHORE()
N#endif
N
N#ifndef traceCREATE_COUNTING_SEMAPHORE_FAILED
N	#define traceCREATE_COUNTING_SEMAPHORE_FAILED()
N#endif
N
N#ifndef traceQUEUE_SEND
N	#define traceQUEUE_SEND( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FAILED
N	#define traceQUEUE_SEND_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE
N	#define traceQUEUE_RECEIVE( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK
N	#define traceQUEUE_PEEK( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FAILED
N	#define traceQUEUE_PEEK_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR
N	#define traceQUEUE_PEEK_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FAILED
N	#define traceQUEUE_RECEIVE_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR
N	#define traceQUEUE_SEND_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_SEND_FROM_ISR_FAILED
N	#define traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR
N	#define traceQUEUE_RECEIVE_FROM_ISR( pxQueue )
N#endif
N
N#ifndef traceQUEUE_RECEIVE_FROM_ISR_FAILED
N	#define traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_PEEK_FROM_ISR_FAILED
N	#define traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue )
N#endif
N
N#ifndef traceQUEUE_DELETE
N	#define traceQUEUE_DELETE( pxQueue )
N#endif
N
N#ifndef traceTASK_CREATE
N	#define traceTASK_CREATE( pxNewTCB )
N#endif
N
N#ifndef traceTASK_CREATE_FAILED
N	#define traceTASK_CREATE_FAILED()
N#endif
N
N#ifndef traceTASK_DELETE
N	#define traceTASK_DELETE( pxTaskToDelete )
N#endif
N
N#ifndef traceTASK_DELAY_UNTIL
N	#define traceTASK_DELAY_UNTIL( x )
N#endif
N
N#ifndef traceTASK_DELAY
N	#define traceTASK_DELAY()
N#endif
N
N#ifndef traceTASK_PRIORITY_SET
N	#define traceTASK_PRIORITY_SET( pxTask, uxNewPriority )
N#endif
N
N#ifndef traceTASK_SUSPEND
N	#define traceTASK_SUSPEND( pxTaskToSuspend )
N#endif
N
N#ifndef traceTASK_RESUME
N	#define traceTASK_RESUME( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_RESUME_FROM_ISR
N	#define traceTASK_RESUME_FROM_ISR( pxTaskToResume )
N#endif
N
N#ifndef traceTASK_INCREMENT_TICK
N	#define traceTASK_INCREMENT_TICK( xTickCount )
N#endif
N
N#ifndef traceTIMER_CREATE
N	#define traceTIMER_CREATE( pxNewTimer )
N#endif
N
N#ifndef traceTIMER_CREATE_FAILED
N	#define traceTIMER_CREATE_FAILED()
N#endif
N
N#ifndef traceTIMER_COMMAND_SEND
N	#define traceTIMER_COMMAND_SEND( xTimer, xMessageID, xMessageValueValue, xReturn )
N#endif
N
N#ifndef traceTIMER_EXPIRED
N	#define traceTIMER_EXPIRED( pxTimer )
N#endif
N
N#ifndef traceTIMER_COMMAND_RECEIVED
N	#define traceTIMER_COMMAND_RECEIVED( pxTimer, xMessageID, xMessageValue )
N#endif
N
N#ifndef traceMALLOC
N    #define traceMALLOC( pvAddress, uiSize )
N#endif
N
N#ifndef traceFREE
N    #define traceFREE( pvAddress, uiSize )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE
N	#define traceEVENT_GROUP_CREATE( xEventGroup )
N#endif
N
N#ifndef traceEVENT_GROUP_CREATE_FAILED
N	#define traceEVENT_GROUP_CREATE_FAILED()
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_BLOCK
N	#define traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_SYNC_END
N	#define traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_BLOCK
N	#define traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor )
N#endif
N
N#ifndef traceEVENT_GROUP_WAIT_BITS_END
N	#define traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred ) ( void ) xTimeoutOccurred
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS
N	#define traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_CLEAR_BITS_FROM_ISR
N	#define traceEVENT_GROUP_CLEAR_BITS_FROM_ISR( xEventGroup, uxBitsToClear )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS
N	#define traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_SET_BITS_FROM_ISR
N	#define traceEVENT_GROUP_SET_BITS_FROM_ISR( xEventGroup, uxBitsToSet )
N#endif
N
N#ifndef traceEVENT_GROUP_DELETE
N	#define traceEVENT_GROUP_DELETE( xEventGroup )
N#endif
N
N#ifndef tracePEND_FUNC_CALL
N	#define tracePEND_FUNC_CALL(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef tracePEND_FUNC_CALL_FROM_ISR
N	#define tracePEND_FUNC_CALL_FROM_ISR(xFunctionToPend, pvParameter1, ulParameter2, ret)
N#endif
N
N#ifndef traceQUEUE_REGISTRY_ADD
N	#define traceQUEUE_REGISTRY_ADD(xQueue, pcQueueName)
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE_BLOCK
N	#define traceTASK_NOTIFY_TAKE_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_TAKE
N	#define traceTASK_NOTIFY_TAKE()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT_BLOCK
N	#define traceTASK_NOTIFY_WAIT_BLOCK()
N#endif
N
N#ifndef traceTASK_NOTIFY_WAIT
N	#define traceTASK_NOTIFY_WAIT()
N#endif
N
N#ifndef traceTASK_NOTIFY
N	#define traceTASK_NOTIFY()
N#endif
N
N#ifndef traceTASK_NOTIFY_FROM_ISR
N	#define traceTASK_NOTIFY_FROM_ISR()
N#endif
N
N#ifndef traceTASK_NOTIFY_GIVE_FROM_ISR
N	#define traceTASK_NOTIFY_GIVE_FROM_ISR()
N#endif
N
N#ifndef traceSTREAM_BUFFER_CREATE_FAILED
N	#define traceSTREAM_BUFFER_CREATE_FAILED( xIsMessageBuffer )
N#endif
N
N#ifndef traceSTREAM_BUFFER_CREATE_STATIC_FAILED
N	#define traceSTREAM_BUFFER_CREATE_STATIC_FAILED( xReturn, xIsMessageBuffer )
N#endif
N
N#ifndef traceSTREAM_BUFFER_CREATE
N	#define traceSTREAM_BUFFER_CREATE( pxStreamBuffer, xIsMessageBuffer )
N#endif
N
N#ifndef traceSTREAM_BUFFER_DELETE
N	#define traceSTREAM_BUFFER_DELETE( xStreamBuffer )
N#endif
N
N#ifndef traceSTREAM_BUFFER_RESET
N	#define traceSTREAM_BUFFER_RESET( xStreamBuffer )
N#endif
N
N#ifndef traceBLOCKING_ON_STREAM_BUFFER_SEND
N	#define traceBLOCKING_ON_STREAM_BUFFER_SEND( xStreamBuffer )
N#endif
N
N#ifndef traceSTREAM_BUFFER_SEND
N	#define traceSTREAM_BUFFER_SEND( xStreamBuffer, xBytesSent )
N#endif
N
N#ifndef traceSTREAM_BUFFER_SEND_FAILED
N	#define traceSTREAM_BUFFER_SEND_FAILED( xStreamBuffer )
N#endif
N
N#ifndef traceSTREAM_BUFFER_SEND_FROM_ISR
N	#define traceSTREAM_BUFFER_SEND_FROM_ISR( xStreamBuffer, xBytesSent )
N#endif
N
N#ifndef traceBLOCKING_ON_STREAM_BUFFER_RECEIVE
N	#define traceBLOCKING_ON_STREAM_BUFFER_RECEIVE( xStreamBuffer )
N#endif
N
N#ifndef traceSTREAM_BUFFER_RECEIVE
N	#define traceSTREAM_BUFFER_RECEIVE( xStreamBuffer, xReceivedLength )
N#endif
N
N#ifndef traceSTREAM_BUFFER_RECEIVE_FAILED
N	#define traceSTREAM_BUFFER_RECEIVE_FAILED( xStreamBuffer )
N#endif
N
N#ifndef traceSTREAM_BUFFER_RECEIVE_FROM_ISR
N	#define traceSTREAM_BUFFER_RECEIVE_FROM_ISR( xStreamBuffer, xReceivedLength )
N#endif
N
N#ifndef configGENERATE_RUN_TIME_STATS
N	#define configGENERATE_RUN_TIME_STATS 0
N#endif
N
N#if ( configGENERATE_RUN_TIME_STATS == 1 )
X#if ( 0 == 1 )
S
S	#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
S		#error If configGENERATE_RUN_TIME_STATS is defined then portCONFIGURE_TIMER_FOR_RUN_TIME_STATS must also be defined.  portCONFIGURE_TIMER_FOR_RUN_TIME_STATS should call a port layer function to setup a peripheral timer/counter that can then be used as the run time counter time base.
S	#endif /* portCONFIGURE_TIMER_FOR_RUN_TIME_STATS */
S
S	#ifndef portGET_RUN_TIME_COUNTER_VALUE
S		#ifndef portALT_GET_RUN_TIME_COUNTER_VALUE
S			#error If configGENERATE_RUN_TIME_STATS is defined then either portGET_RUN_TIME_COUNTER_VALUE or portALT_GET_RUN_TIME_COUNTER_VALUE must also be defined.  See the examples provided and the FreeRTOS web site for more information.
S		#endif /* portALT_GET_RUN_TIME_COUNTER_VALUE */
S	#endif /* portGET_RUN_TIME_COUNTER_VALUE */
S
N#endif /* configGENERATE_RUN_TIME_STATS */
N
N#ifndef portCONFIGURE_TIMER_FOR_RUN_TIME_STATS
N	#define portCONFIGURE_TIMER_FOR_RUN_TIME_STATS()
N#endif
N
N#ifndef configUSE_MALLOC_FAILED_HOOK
S	#define configUSE_MALLOC_FAILED_HOOK 0
N#endif
N
N#ifndef portPRIVILEGE_BIT
N	#define portPRIVILEGE_BIT ( ( UBaseType_t ) 0x00 )
N#endif
N
N#ifndef portYIELD_WITHIN_API
N	#define portYIELD_WITHIN_API portYIELD
N#endif
N
N#ifndef portSUPPRESS_TICKS_AND_SLEEP
N	#define portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime )
N#endif
N
N#ifndef configEXPECTED_IDLE_TIME_BEFORE_SLEEP
N	#define configEXPECTED_IDLE_TIME_BEFORE_SLEEP 2
N#endif
N
N#if configEXPECTED_IDLE_TIME_BEFORE_SLEEP < 2
X#if 2 < 2
S	#error configEXPECTED_IDLE_TIME_BEFORE_SLEEP must not be less than 2
N#endif
N
N#ifndef configUSE_TICKLESS_IDLE
N	#define configUSE_TICKLESS_IDLE 0
N#endif
N
N#ifndef configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING
N	#define configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPRE_SLEEP_PROCESSING
N	#define configPRE_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configPOST_SLEEP_PROCESSING
N	#define configPOST_SLEEP_PROCESSING( x )
N#endif
N
N#ifndef configUSE_QUEUE_SETS
N	#define configUSE_QUEUE_SETS 0
N#endif
N
N#ifndef portTASK_USES_FLOATING_POINT
N	#define portTASK_USES_FLOATING_POINT()
N#endif
N
N#ifndef portTASK_CALLS_SECURE_FUNCTIONS
N	#define portTASK_CALLS_SECURE_FUNCTIONS()
N#endif
N
N#ifndef configUSE_TIME_SLICING
S	#define configUSE_TIME_SLICING 1
N#endif
N
N#ifndef configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS
N	#define configINCLUDE_APPLICATION_DEFINED_PRIVILEGED_FUNCTIONS 0
N#endif
N
N#ifndef configUSE_STATS_FORMATTING_FUNCTIONS
N	#define configUSE_STATS_FORMATTING_FUNCTIONS 0
N#endif
N
N#ifndef portASSERT_IF_INTERRUPT_PRIORITY_INVALID
N	#define portASSERT_IF_INTERRUPT_PRIORITY_INVALID()
N#endif
N
N#ifndef configUSE_TRACE_FACILITY
S	#define configUSE_TRACE_FACILITY 0
N#endif
N
N#ifndef mtCOVERAGE_TEST_MARKER
N	#define mtCOVERAGE_TEST_MARKER()
N#endif
N
N#ifndef mtCOVERAGE_TEST_DELAY
N	#define mtCOVERAGE_TEST_DELAY()
N#endif
N
N#ifndef portASSERT_IF_IN_ISR
N	#define portASSERT_IF_IN_ISR()
N#endif
N
N#ifndef configUSE_PORT_OPTIMISED_TASK_SELECTION
S	#define configUSE_PORT_OPTIMISED_TASK_SELECTION 0
N#endif
N
N#ifndef configAPPLICATION_ALLOCATED_HEAP
S	#define configAPPLICATION_ALLOCATED_HEAP 0
N#endif
N
N#ifndef configUSE_TASK_NOTIFICATIONS
S	#define configUSE_TASK_NOTIFICATIONS 1
N#endif
N
N#ifndef portTICK_TYPE_IS_ATOMIC
S	#define portTICK_TYPE_IS_ATOMIC 0
N#endif
N
N#ifndef configSUPPORT_STATIC_ALLOCATION
S	/* Defaults to 0 for backward compatibility. */
S	#define configSUPPORT_STATIC_ALLOCATION 0
N#endif
N
N#ifndef configSUPPORT_DYNAMIC_ALLOCATION
S	/* Defaults to 1 for backward compatibility. */
S	#define configSUPPORT_DYNAMIC_ALLOCATION 1
N#endif
N
N#ifndef configSTACK_DEPTH_TYPE
N	/* Defaults to uint16_t for backward compatibility, but can be overridden
N	in FreeRTOSConfig.h if uint16_t is too restrictive. */
N	#define configSTACK_DEPTH_TYPE uint16_t
N#endif
N
N/* Sanity check the configuration. */
N#if( configUSE_TICKLESS_IDLE != 0 )
X#if( 0 != 0 )
S	#if( INCLUDE_vTaskSuspend != 1 )
S		#error INCLUDE_vTaskSuspend must be set to 1 if configUSE_TICKLESS_IDLE is not set to 0
S	#endif /* INCLUDE_vTaskSuspend */
N#endif /* configUSE_TICKLESS_IDLE */
N
N#if( ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 0 ) )
X#if( ( 1 == 0 ) && ( 1 == 0 ) )
S	#error configSUPPORT_STATIC_ALLOCATION and configSUPPORT_DYNAMIC_ALLOCATION cannot both be 0, but can both be 1.
N#endif
N
N#if( ( configUSE_RECURSIVE_MUTEXES == 1 ) && ( configUSE_MUTEXES != 1 ) )
X#if( ( 0 == 1 ) && ( 1 != 1 ) )
S	#error configUSE_MUTEXES must be set to 1 to use recursive mutexes
N#endif
N
N#ifndef configINITIAL_TICK_COUNT
N	#define configINITIAL_TICK_COUNT 0
N#endif
N
N#if( portTICK_TYPE_IS_ATOMIC == 0 )
X#if( 1 == 0 )
S	/* Either variables of tick type cannot be read atomically, or
S	portTICK_TYPE_IS_ATOMIC was not set - map the critical sections used when
S	the tick count is returned to the standard critical section macros. */
S	#define portTICK_TYPE_ENTER_CRITICAL() portENTER_CRITICAL()
S	#define portTICK_TYPE_EXIT_CRITICAL() portEXIT_CRITICAL()
S	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
S	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( ( x ) )
N#else
N	/* The tick type can be read atomically, so critical sections used when the
N	tick count is returned can be defined away. */
N	#define portTICK_TYPE_ENTER_CRITICAL()
N	#define portTICK_TYPE_EXIT_CRITICAL()
N	#define portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR() 0
N	#define portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( x ) ( void ) x
N#endif
N
N/* Definitions to allow backward compatibility with FreeRTOS versions prior to
NV8 if desired. */
N#ifndef configENABLE_BACKWARD_COMPATIBILITY
N	#define configENABLE_BACKWARD_COMPATIBILITY 1
N#endif
N
N#ifndef configPRINTF
N	/* configPRINTF() was not defined, so define it away to nothing.  To use
N	configPRINTF() then define it as follows (where MyPrintFunction() is
N	provided by the application writer):
N
N	void MyPrintFunction(const char *pcFormat, ... );
N	#define configPRINTF( X )   MyPrintFunction X
N
N	Then call like a standard printf() function, but placing brackets around
N	all parameters so they are passed as a single parameter.  For example:
N	configPRINTF( ("Value = %d", MyVariable) ); */
N	#define configPRINTF( X )
N#endif
N
N#ifndef configMAX
N	/* The application writer has not provided their own MAX macro, so define
N	the following generic implementation. */
N	#define configMAX( a, b ) ( ( ( a ) > ( b ) ) ? ( a ) : ( b ) )
N#endif
N
N#ifndef configMIN
N	/* The application writer has not provided their own MAX macro, so define
N	the following generic implementation. */
N	#define configMIN( a, b ) ( ( ( a ) < ( b ) ) ? ( a ) : ( b ) )
N#endif
N
N#if configENABLE_BACKWARD_COMPATIBILITY == 1
X#if 1 == 1
N	#define eTaskStateGet eTaskGetState
N	#define portTickType TickType_t
N	#define xTaskHandle TaskHandle_t
N	#define xQueueHandle QueueHandle_t
N	#define xSemaphoreHandle SemaphoreHandle_t
N	#define xQueueSetHandle QueueSetHandle_t
N	#define xQueueSetMemberHandle QueueSetMemberHandle_t
N	#define xTimeOutType TimeOut_t
N	#define xMemoryRegion MemoryRegion_t
N	#define xTaskParameters TaskParameters_t
N	#define xTaskStatusType	TaskStatus_t
N	#define xTimerHandle TimerHandle_t
N	#define xCoRoutineHandle CoRoutineHandle_t
N	#define pdTASK_HOOK_CODE TaskHookFunction_t
N	#define portTICK_RATE_MS portTICK_PERIOD_MS
N	#define pcTaskGetTaskName pcTaskGetName
N	#define pcTimerGetTimerName pcTimerGetName
N	#define pcQueueGetQueueName pcQueueGetName
N	#define vTaskGetTaskInfo vTaskGetInfo
N
N	/* Backward compatibility within the scheduler code only - these definitions
N	are not really required but are included for completeness. */
N	#define tmrTIMER_CALLBACK TimerCallbackFunction_t
N	#define pdTASK_CODE TaskFunction_t
N	#define xListItem ListItem_t
N	#define xList List_t
N#endif /* configENABLE_BACKWARD_COMPATIBILITY */
N
N#if( configUSE_ALTERNATIVE_API != 0 )
X#if( 0 != 0 )
S	#error The alternative API was deprecated some time ago, and was removed in FreeRTOS V9.0 0
N#endif
N
N/* Set configUSE_TASK_FPU_SUPPORT to 0 to omit floating point support even
Nif floating point hardware is otherwise supported by the FreeRTOS port in use.
NThis constant is not supported by all FreeRTOS ports that include floating
Npoint support. */
N#ifndef configUSE_TASK_FPU_SUPPORT
N	#define configUSE_TASK_FPU_SUPPORT 1
N#endif
N
N/*
N * In line with software engineering best practice, FreeRTOS implements a strict
N * data hiding policy, so the real structures used by FreeRTOS to maintain the
N * state of tasks, queues, semaphores, etc. are not accessible to the application
N * code.  However, if the application writer wants to statically allocate such
N * an object then the size of the object needs to be know.  Dummy structures
N * that are guaranteed to have the same size and alignment requirements of the
N * real objects are used for this purpose.  The dummy list and list item
N * structures below are used for inclusion in such a dummy structure.
N */
Nstruct xSTATIC_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 4 ];
N};
Ntypedef struct xSTATIC_LIST_ITEM StaticListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Nstruct xSTATIC_MINI_LIST_ITEM
N{
N	TickType_t xDummy1;
N	void *pvDummy2[ 2 ];
N};
Ntypedef struct xSTATIC_MINI_LIST_ITEM StaticMiniListItem_t;
N
N/* See the comments above the struct xSTATIC_LIST_ITEM definition. */
Ntypedef struct xSTATIC_LIST
N{
N	UBaseType_t uxDummy1;
N	void *pvDummy2;
N	StaticMiniListItem_t xDummy3;
N} StaticList_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Task structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a task then
N * the size of the task object needs to be know.  The StaticTask_t structure
N * below is provided for this purpose.  Its sizes and alignment requirements are
N * guaranteed to match those of the genuine structure, no matter which
N * architecture is being used, and no matter how the values in FreeRTOSConfig.h
N * are set.  Its contents are somewhat obfuscated in the hope users will
N * recognise that it would be unwise to make direct use of the structure members.
N */
Ntypedef struct xSTATIC_TCB
N{
N	void				*pxDummy1;
N	#if ( portUSING_MPU_WRAPPERS == 1 )
X	#if ( 0 == 1 )
S		xMPU_SETTINGS	xDummy2;
N	#endif
N	StaticListItem_t	xDummy3[ 2 ];
N	UBaseType_t			uxDummy5;
N	void				*pxDummy6;
N	uint8_t				ucDummy7[ configMAX_TASK_NAME_LEN ];
X	uint8_t				ucDummy7[ 16 ];
N	#if ( ( portSTACK_GROWTH > 0 ) || ( configRECORD_STACK_HIGH_ADDRESS == 1 ) )
X	#if ( ( ( -1 ) > 0 ) || ( 0 == 1 ) )
S		void			*pxDummy8;
N	#endif
N	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy9;
N	#endif
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t		uxDummy10[ 2 ];
N	#endif
N	#if ( configUSE_MUTEXES == 1 )
X	#if ( 1 == 1 )
N		UBaseType_t		uxDummy12[ 2 ];
N	#endif
N	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
X	#if ( 0 == 1 )
S		void			*pxDummy14;
N	#endif
N	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X	#if( 0 > 0 )
S		void			*pvDummy15[ configNUM_THREAD_LOCAL_STORAGE_POINTERS ];
N	#endif
N	#if ( configGENERATE_RUN_TIME_STATS == 1 )
X	#if ( 0 == 1 )
S		uint32_t		ulDummy16;
N	#endif
N	#if ( configUSE_NEWLIB_REENTRANT == 1 )
X	#if ( 0 == 1 )
S		struct	_reent	xDummy17;
N	#endif
N	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
X	#if ( 1 == 1 )
N		uint32_t 		ulDummy18;
N		uint8_t 		ucDummy19;
N	#endif
N	#if( ( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) || ( portUSING_MPU_WRAPPERS == 1 ) )
X	#if( ( ( 1 == 1 ) && ( 1 == 1 ) ) || ( 0 == 1 ) )
N		uint8_t			uxDummy20;
N	#endif
N
N	#if( INCLUDE_xTaskAbortDelay == 1 )
X	#if( 0 == 1 )
S		uint8_t ucDummy21;
N	#endif
N
N} StaticTask_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the Queue structure used internally by
N * FreeRTOS is not accessible to application code.  However, if the application
N * writer wants to statically allocate the memory required to create a queue
N * then the size of the queue object needs to be know.  The StaticQueue_t
N * structure below is provided for this purpose.  Its sizes and alignment
N * requirements are guaranteed to match those of the genuine structure, no
N * matter which architecture is being used, and no matter how the values in
N * FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in the hope
N * users will recognise that it would be unwise to make direct use of the
N * structure members.
N */
Ntypedef struct xSTATIC_QUEUE
N{
N	void *pvDummy1[ 3 ];
N
N	union
N	{
N		void *pvDummy2;
N		UBaseType_t uxDummy2;
N	} u;
N
N	StaticList_t xDummy3[ 2 ];
N	UBaseType_t uxDummy4[ 3 ];
N	uint8_t ucDummy5[ 2 ];
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 1 == 1 ) && ( 1 == 1 ) )
N		uint8_t ucDummy6;
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		void *pvDummy7;
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t uxDummy8;
S		uint8_t ucDummy9;
N	#endif
N
N} StaticQueue_t;
Ntypedef StaticQueue_t StaticSemaphore_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the event group structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create an event group then the size of the event group object needs to be
N * know.  The StaticEventGroup_t structure below is provided for this purpose.
N * Its sizes and alignment requirements are guaranteed to match those of the
N * genuine structure, no matter which architecture is being used, and no matter
N * how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
N * obfuscated in the hope users will recognise that it would be unwise to make
N * direct use of the structure members.
N */
Ntypedef struct xSTATIC_EVENT_GROUP
N{
N	TickType_t xDummy1;
N	StaticList_t xDummy2;
N
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 0 == 1 )
S		UBaseType_t uxDummy3;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 1 == 1 ) && ( 1 == 1 ) )
N			uint8_t ucDummy4;
N	#endif
N
N} StaticEventGroup_t;
N
N/*
N * In line with software engineering best practice, especially when supplying a
N * library that is likely to change in future versions, FreeRTOS implements a
N * strict data hiding policy.  This means the software timer structure used
N * internally by FreeRTOS is not accessible to application code.  However, if
N * the application writer wants to statically allocate the memory required to
N * create a software timer then the size of the queue object needs to be know.
N * The StaticTimer_t structure below is provided for this purpose.  Its sizes
N * and alignment requirements are guaranteed to match those of the genuine
N * structure, no matter which architecture is being used, and no matter how the
N * values in FreeRTOSConfig.h are set.  Its contents are somewhat obfuscated in
N * the hope users will recognise that it would be unwise to make direct use of
N * the structure members.
N */
Ntypedef struct xSTATIC_TIMER
N{
N	void				*pvDummy1;
N	StaticListItem_t	xDummy2;
N	TickType_t			xDummy3;
N	UBaseType_t			uxDummy4;
N	void 				*pvDummy5[ 2 ];
N	#if( configUSE_TRACE_FACILITY == 1 )
X	#if( 0 == 1 )
S		UBaseType_t		uxDummy6;
N	#endif
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 1 == 1 ) && ( 1 == 1 ) )
N		uint8_t 		ucDummy7;
N	#endif
N
N} StaticTimer_t;
N
N/*
N* In line with software engineering best practice, especially when supplying a
N* library that is likely to change in future versions, FreeRTOS implements a
N* strict data hiding policy.  This means the stream buffer structure used
N* internally by FreeRTOS is not accessible to application code.  However, if
N* the application writer wants to statically allocate the memory required to
N* create a stream buffer then the size of the stream buffer object needs to be
N* know.  The StaticStreamBuffer_t structure below is provided for this purpose.
N* Its size and alignment requirements are guaranteed to match those of the
N* genuine structure, no matter which architecture is being used, and no matter
N* how the values in FreeRTOSConfig.h are set.  Its contents are somewhat
N* obfuscated in the hope users will recognise that it would be unwise to make
N* direct use of the structure members.
N*/
Ntypedef struct xSTATIC_STREAM_BUFFER
N{
N	size_t uxDummy1[ 4 ];
N	void * pvDummy2[ 3 ];
N	uint8_t ucDummy3;
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t uxDummy4;
N	#endif
N} StaticStreamBuffer_t;
N
N/* Message buffers are built on stream buffers. */
Ntypedef StaticStreamBuffer_t StaticMessageBuffer_t;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* INC_FREERTOS_H */
N
L 37 "Common\CMSIS-FreeRTOS\10.0.1\Source\queue.c" 2
N#include "task.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\task.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N
N#ifndef INC_TASK_H
N#define INC_TASK_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h must appear in source files before include task.h"
N#endif
N
N#include "list.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\list.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N/*
N * This is the list implementation used by the scheduler.  While it is tailored
N * heavily for the schedulers needs, it is also available for use by
N * application code.
N *
N * list_ts can only store pointers to list_item_ts.  Each ListItem_t contains a
N * numeric value (xItemValue).  Most of the time the lists are sorted in
N * descending item value order.
N *
N * Lists are created already containing one list item.  The value of this
N * item is the maximum possible that can be stored, it is therefore always at
N * the end of the list and acts as a marker.  The list member pxHead always
N * points to this marker - even though it is at the tail of the list.  This
N * is because the tail contains a wrap back pointer to the true head of
N * the list.
N *
N * In addition to it's value, each list item contains a pointer to the next
N * item in the list (pxNext), a pointer to the list it is in (pxContainer)
N * and a pointer to back to the object that contains it.  These later two
N * pointers are included for efficiency of list manipulation.  There is
N * effectively a two way link between the object containing the list item and
N * the list item itself.
N *
N *
N * \page ListIntroduction List Implementation
N * \ingroup FreeRTOSIntro
N */
N
N#ifndef INC_FREERTOS_H
S	#error FreeRTOS.h must be included before list.h
N#endif
N
N#ifndef LIST_H
N#define LIST_H
N
N/*
N * The list structure members are modified from within interrupts, and therefore
N * by rights should be declared volatile.  However, they are only modified in a
N * functionally atomic way (within critical sections of with the scheduler
N * suspended) and are either passed by reference into a function or indexed via
N * a volatile variable.  Therefore, in all use cases tested so far, the volatile
N * qualifier can be omitted in order to provide a moderate performance
N * improvement without adversely affecting functional behaviour.  The assembly
N * instructions generated by the IAR, ARM and GCC compilers when the respective
N * compiler's options were set for maximum optimisation has been inspected and
N * deemed to be as intended.  That said, as compiler technology advances, and
N * especially if aggressive cross module optimisation is used (a use case that
N * has not been exercised to any great extend) then it is feasible that the
N * volatile qualifier will be needed for correct optimisation.  It is expected
N * that a compiler removing essential code because, without the volatile
N * qualifier on the list structure members and with aggressive cross module
N * optimisation, the compiler deemed the code unnecessary will result in
N * complete and obvious failure of the scheduler.  If this is ever experienced
N * then the volatile qualifier can be inserted in the relevant places within the
N * list structures by simply defining configLIST_VOLATILE to volatile in
N * FreeRTOSConfig.h (as per the example at the bottom of this comment block).
N * If configLIST_VOLATILE is not defined then the preprocessor directives below
N * will simply #define configLIST_VOLATILE away completely.
N *
N * To use volatile list structure members then add the following line to
N * FreeRTOSConfig.h (without the quotes):
N * "#define configLIST_VOLATILE volatile"
N */
N#ifndef configLIST_VOLATILE
N	#define configLIST_VOLATILE
N#endif /* configSUPPORT_CROSS_MODULE_OPTIMISATION */
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/* Macros that can be used to place known values within the list structures,
Nthen check that the known values do not get corrupted during the execution of
Nthe application.   These may catch the list data structures being overwritten in
Nmemory.  They will not catch data errors caused by incorrect configuration or
Nuse of FreeRTOS.*/
N#if( configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES == 0 )
X#if( 0 == 0 )
N	/* Define the macros to do nothing. */
N	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE
N	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE
N	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE
N	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )
N	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )
N	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )
N	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )
N	#define listTEST_LIST_INTEGRITY( pxList )
N#else
S	/* Define macros that add new members into the list structures. */
S	#define listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue1;
S	#define listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE				TickType_t xListItemIntegrityValue2;
S	#define listFIRST_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue1;
S	#define listSECOND_LIST_INTEGRITY_CHECK_VALUE					TickType_t xListIntegrityValue2;
S
S	/* Define macros that set the new structure members to known values. */
S	#define listSET_FIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )		( pxItem )->xListItemIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem )	( pxItem )->xListItemIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_1_VALUE( pxList )		( pxList )->xListIntegrityValue1 = pdINTEGRITY_CHECK_VALUE
S	#define listSET_LIST_INTEGRITY_CHECK_2_VALUE( pxList )		( pxList )->xListIntegrityValue2 = pdINTEGRITY_CHECK_VALUE
S
S	/* Define macros that will assert if one of the structure members does not
S	contain its expected value. */
S	#define listTEST_LIST_ITEM_INTEGRITY( pxItem )		configASSERT( ( ( pxItem )->xListItemIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxItem )->xListItemIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
S	#define listTEST_LIST_INTEGRITY( pxList )			configASSERT( ( ( pxList )->xListIntegrityValue1 == pdINTEGRITY_CHECK_VALUE ) && ( ( pxList )->xListIntegrityValue2 == pdINTEGRITY_CHECK_VALUE ) )
N#endif /* configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES */
N
N
N/*
N * Definition of the only type of object that a list can contain.
N */
Nstruct xLIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;			/*< The value being listed.  In most cases this is used to sort the list in descending order. */
X	 TickType_t xItemValue;			 
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;		/*< Pointer to the next ListItem_t in the list. */
X	struct xLIST_ITEM *  pxNext;		 
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;	/*< Pointer to the previous ListItem_t in the list. */
X	struct xLIST_ITEM *  pxPrevious;	 
N	void * pvOwner;										/*< Pointer to the object (normally a TCB) that contains the list item.  There is therefore a two way link between the object containing the list item and the list item itself. */
N	void * configLIST_VOLATILE pvContainer;				/*< Pointer to the list in which this list item is placed (if any). */
X	void *  pvContainer;				 
N	listSECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N};
Ntypedef struct xLIST_ITEM ListItem_t;					/* For some reason lint wants this as two separate definitions. */
N
Nstruct xMINI_LIST_ITEM
N{
N	listFIRST_LIST_ITEM_INTEGRITY_CHECK_VALUE			/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X				 
N	configLIST_VOLATILE TickType_t xItemValue;
X	 TickType_t xItemValue;
N	struct xLIST_ITEM * configLIST_VOLATILE pxNext;
X	struct xLIST_ITEM *  pxNext;
N	struct xLIST_ITEM * configLIST_VOLATILE pxPrevious;
X	struct xLIST_ITEM *  pxPrevious;
N};
Ntypedef struct xMINI_LIST_ITEM MiniListItem_t;
N
N/*
N * Definition of the type of queue used by the scheduler.
N */
Ntypedef struct xLIST
N{
N	listFIRST_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N	volatile UBaseType_t uxNumberOfItems;
N	ListItem_t * configLIST_VOLATILE pxIndex;			/*< Used to walk through the list.  Points to the last item returned by a call to listGET_OWNER_OF_NEXT_ENTRY (). */
X	ListItem_t *  pxIndex;			 
N	MiniListItem_t xListEnd;							/*< List item that contains the maximum possible item value meaning it is always at the end of the list and is therefore used as a marker. */
N	listSECOND_LIST_INTEGRITY_CHECK_VALUE				/*< Set to a known value if configUSE_LIST_DATA_INTEGRITY_CHECK_BYTES is set to 1. */
X					 
N} List_t;
N
N/*
N * Access macro to set the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_OWNER( pxListItem, pxOwner )		( ( pxListItem )->pvOwner = ( void * ) ( pxOwner ) )
N
N/*
N * Access macro to get the owner of a list item.  The owner of a list item
N * is the object (usually a TCB) that contains the list item.
N *
N * \page listSET_LIST_ITEM_OWNER listSET_LIST_ITEM_OWNER
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_OWNER( pxListItem )	( ( pxListItem )->pvOwner )
N
N/*
N * Access macro to set the value of the list item.  In most cases the value is
N * used to sort the list in descending order.
N *
N * \page listSET_LIST_ITEM_VALUE listSET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listSET_LIST_ITEM_VALUE( pxListItem, xValue )	( ( pxListItem )->xItemValue = ( xValue ) )
N
N/*
N * Access macro to retrieve the value of the list item.  The value can
N * represent anything - for example the priority of a task, or the time at
N * which a task should be unblocked.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_LIST_ITEM_VALUE( pxListItem )	( ( pxListItem )->xItemValue )
N
N/*
N * Access macro to retrieve the value of the list item at the head of a given
N * list.
N *
N * \page listGET_LIST_ITEM_VALUE listGET_LIST_ITEM_VALUE
N * \ingroup LinkedList
N */
N#define listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext->xItemValue )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_HEAD_ENTRY listGET_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_HEAD_ENTRY( pxList )	( ( ( pxList )->xListEnd ).pxNext )
N
N/*
N * Return the list item at the head of the list.
N *
N * \page listGET_NEXT listGET_NEXT
N * \ingroup LinkedList
N */
N#define listGET_NEXT( pxListItem )	( ( pxListItem )->pxNext )
N
N/*
N * Return the list item that marks the end of the list
N *
N * \page listGET_END_MARKER listGET_END_MARKER
N * \ingroup LinkedList
N */
N#define listGET_END_MARKER( pxList )	( ( ListItem_t const * ) ( &( ( pxList )->xListEnd ) ) )
N
N/*
N * Access macro to determine if a list contains any items.  The macro will
N * only have the value true if the list is empty.
N *
N * \page listLIST_IS_EMPTY listLIST_IS_EMPTY
N * \ingroup LinkedList
N */
N#define listLIST_IS_EMPTY( pxList )	( ( BaseType_t ) ( ( pxList )->uxNumberOfItems == ( UBaseType_t ) 0 ) )
N
N/*
N * Access macro to return the number of items in the list.
N */
N#define listCURRENT_LIST_LENGTH( pxList )	( ( pxList )->uxNumberOfItems )
N
N/*
N * Access function to obtain the owner of the next entry in a list.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list
N * and returns that entry's pxOwner parameter.  Using multiple calls to this
N * function it is therefore possible to move through every item contained in
N * a list.
N *
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxTCB pxTCB is set to the address of the owner of the next list item.
N * @param pxList The list from which the next item owner is to be returned.
N *
N * \page listGET_OWNER_OF_NEXT_ENTRY listGET_OWNER_OF_NEXT_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										\
N{																							\
NList_t * const pxConstList = ( pxList );													\
N	/* Increment the index to the next item and return the item, ensuring */				\
N	/* we don't return the marker used at the end of the list.  */							\
N	( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							\
N	if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )	\
N	{																						\
N		( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;						\
N	}																						\
N	( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											\
N}
X#define listGET_OWNER_OF_NEXT_ENTRY( pxTCB, pxList )										{																							List_t * const pxConstList = ( pxList );														 					 								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;								if( ( void * ) ( pxConstList )->pxIndex == ( void * ) &( ( pxConstList )->xListEnd ) )		{																								( pxConstList )->pxIndex = ( pxConstList )->pxIndex->pxNext;							}																							( pxTCB ) = ( pxConstList )->pxIndex->pvOwner;											}
N
N
N/*
N * Access function to obtain the owner of the first entry in a list.  Lists
N * are normally sorted in ascending item value order.
N *
N * This function returns the pxOwner member of the first item in the list.
N * The pxOwner parameter of a list item is a pointer to the object that owns
N * the list item.  In the scheduler this is normally a task control block.
N * The pxOwner parameter effectively creates a two way link between the list
N * item and its owner.
N *
N * @param pxList The list from which the owner of the head item is to be
N * returned.
N *
N * \page listGET_OWNER_OF_HEAD_ENTRY listGET_OWNER_OF_HEAD_ENTRY
N * \ingroup LinkedList
N */
N#define listGET_OWNER_OF_HEAD_ENTRY( pxList )  ( (&( ( pxList )->xListEnd ))->pxNext->pvOwner )
N
N/*
N * Check to see if a list item is within a list.  The list item maintains a
N * "container" pointer that points to the list it is in.  All this macro does
N * is check to see if the container and the list match.
N *
N * @param pxList The list we want to know if the list item is within.
N * @param pxListItem The list item we want to know if is in the list.
N * @return pdTRUE if the list item is in the list, otherwise pdFALSE.
N */
N#define listIS_CONTAINED_WITHIN( pxList, pxListItem ) ( ( BaseType_t ) ( ( pxListItem )->pvContainer == ( void * ) ( pxList ) ) )
N
N/*
N * Return the list a list item is contained within (referenced from).
N *
N * @param pxListItem The list item being queried.
N * @return A pointer to the List_t object that references the pxListItem
N */
N#define listLIST_ITEM_CONTAINER( pxListItem ) ( ( pxListItem )->pvContainer )
N
N/*
N * This provides a crude means of knowing if a list has been initialised, as
N * pxList->xListEnd.xItemValue is set to portMAX_DELAY by the vListInitialise()
N * function.
N */
N#define listLIST_IS_INITIALISED( pxList ) ( ( pxList )->xListEnd.xItemValue == portMAX_DELAY )
N
N/*
N * Must be called before a list is used!  This initialises all the members
N * of the list structure and inserts the xListEnd item into the list as a
N * marker to the back of the list.
N *
N * @param pxList Pointer to the list being initialised.
N *
N * \page vListInitialise vListInitialise
N * \ingroup LinkedList
N */
Nvoid vListInitialise( List_t * const pxList ) PRIVILEGED_FUNCTION;
Xvoid vListInitialise( List_t * const pxList ) ;
N
N/*
N * Must be called before a list item is used.  This sets the list container to
N * null so the item does not think that it is already contained in a list.
N *
N * @param pxItem Pointer to the list item being initialised.
N *
N * \page vListInitialiseItem vListInitialiseItem
N * \ingroup LinkedList
N */
Nvoid vListInitialiseItem( ListItem_t * const pxItem ) PRIVILEGED_FUNCTION;
Xvoid vListInitialiseItem( ListItem_t * const pxItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted into the list in
N * a position determined by its item value (descending item value order).
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The item that is to be placed in the list.
N *
N * \page vListInsert vListInsert
N * \ingroup LinkedList
N */
Nvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Insert a list item into a list.  The item will be inserted in a position
N * such that it will be the last item within the list returned by multiple
N * calls to listGET_OWNER_OF_NEXT_ENTRY.
N *
N * The list member pxIndex is used to walk through a list.  Calling
N * listGET_OWNER_OF_NEXT_ENTRY increments pxIndex to the next item in the list.
N * Placing an item in a list using vListInsertEnd effectively places the item
N * in the list position pointed to by pxIndex.  This means that every other
N * item within the list will be returned by listGET_OWNER_OF_NEXT_ENTRY before
N * the pxIndex parameter again points to the item being inserted.
N *
N * @param pxList The list into which the item is to be inserted.
N *
N * @param pxNewListItem The list item to be inserted into the list.
N *
N * \page vListInsertEnd vListInsertEnd
N * \ingroup LinkedList
N */
Nvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) PRIVILEGED_FUNCTION;
Xvoid vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem ) ;
N
N/*
N * Remove an item from a list.  The list item has a pointer to the list that
N * it is in, so only the list item need be passed into the function.
N *
N * @param uxListRemove The item to be removed.  The item will remove itself from
N * the list pointed to by it's pxContainer parameter.
N *
N * @return The number of items that remain in the list after the list item has
N * been removed.
N *
N * \page uxListRemove uxListRemove
N * \ingroup LinkedList
N */
NUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) PRIVILEGED_FUNCTION;
XUBaseType_t uxListRemove( ListItem_t * const pxItemToRemove ) ;
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 37 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\task.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*-----------------------------------------------------------
N * MACROS AND DEFINITIONS
N *----------------------------------------------------------*/
N
N#define tskKERNEL_VERSION_NUMBER "V10.0.1"
N#define tskKERNEL_VERSION_MAJOR 10
N#define tskKERNEL_VERSION_MINOR 0
N#define tskKERNEL_VERSION_BUILD 1
N
N/**
N * task. h
N *
N * Type by which tasks are referenced.  For example, a call to xTaskCreate
N * returns (via a pointer parameter) an TaskHandle_t variable that can then
N * be used as a parameter to vTaskDelete to delete the task.
N *
N * \defgroup TaskHandle_t TaskHandle_t
N * \ingroup Tasks
N */
Ntypedef void * TaskHandle_t;
N
N/*
N * Defines the prototype to which the application task hook function must
N * conform.
N */
Ntypedef BaseType_t (*TaskHookFunction_t)( void * );
N
N/* Task states returned by eTaskGetState. */
Ntypedef enum
N{
N	eRunning = 0,	/* A task is querying the state of itself, so must be running. */
N	eReady,			/* The task being queried is in a read or pending ready list. */
N	eBlocked,		/* The task being queried is in the Blocked state. */
N	eSuspended,		/* The task being queried is in the Suspended state, or is in the Blocked state with an infinite time out. */
N	eDeleted,		/* The task being queried has been deleted, but its TCB has not yet been freed. */
N	eInvalid			/* Used as an 'invalid state' value. */
N} eTaskState;
N
N/* Actions that can be performed when vTaskNotify() is called. */
Ntypedef enum
N{
N	eNoAction = 0,				/* Notify the task without updating its notify value. */
N	eSetBits,					/* Set bits in the task's notification value. */
N	eIncrement,					/* Increment the task's notification value. */
N	eSetValueWithOverwrite,		/* Set the task's notification value to a specific value even if the previous value has not yet been read by the task. */
N	eSetValueWithoutOverwrite	/* Set the task's notification value if the previous value has been read by the task. */
N} eNotifyAction;
N
N/*
N * Used internally only.
N */
Ntypedef struct xTIME_OUT
N{
N	BaseType_t xOverflowCount;
N	TickType_t xTimeOnEntering;
N} TimeOut_t;
N
N/*
N * Defines the memory ranges allocated to the task when an MPU is used.
N */
Ntypedef struct xMEMORY_REGION
N{
N	void *pvBaseAddress;
N	uint32_t ulLengthInBytes;
N	uint32_t ulParameters;
N} MemoryRegion_t;
N
N/*
N * Parameters required to create an MPU protected task.
N */
Ntypedef struct xTASK_PARAMETERS
N{
N	TaskFunction_t pvTaskCode;
N	const char * const pcName;	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	uint16_t usStackDepth;
N	void *pvParameters;
N	UBaseType_t uxPriority;
N	StackType_t *puxStackBuffer;
N	MemoryRegion_t xRegions[ portNUM_CONFIGURABLE_REGIONS ];
X	MemoryRegion_t xRegions[ 1 ];
N	#if ( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
X	#if ( ( 0 == 1 ) && ( 1 == 1 ) )
S		StaticTask_t * const pxTaskBuffer;
N	#endif
N} TaskParameters_t;
N
N/* Used with the uxTaskGetSystemState() function to return the state of each task
Nin the system. */
Ntypedef struct xTASK_STATUS
N{
N	TaskHandle_t xHandle;			/* The handle of the task to which the rest of the information in the structure relates. */
N	const char *pcTaskName;			/* A pointer to the task's name.  This value will be invalid if the task was deleted since the structure was populated! */ /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N	UBaseType_t xTaskNumber;		/* A number unique to the task. */
N	eTaskState eCurrentState;		/* The state in which the task existed when the structure was populated. */
N	UBaseType_t uxCurrentPriority;	/* The priority at which the task was running (may be inherited) when the structure was populated. */
N	UBaseType_t uxBasePriority;		/* The priority to which the task will return if the task's current priority has been inherited to avoid unbounded priority inversion when obtaining a mutex.  Only valid if configUSE_MUTEXES is defined as 1 in FreeRTOSConfig.h. */
N	uint32_t ulRunTimeCounter;		/* The total run time allocated to the task so far, as defined by the run time stats clock.  See http://www.freertos.org/rtos-run-time-stats.html.  Only valid when configGENERATE_RUN_TIME_STATS is defined as 1 in FreeRTOSConfig.h. */
N	StackType_t *pxStackBase;		/* Points to the lowest address of the task's stack area. */
N	uint16_t usStackHighWaterMark;	/* The minimum amount of stack space that has remained for the task since the task was created.  The closer this value is to zero the closer the task has come to overflowing its stack. */
N} TaskStatus_t;
N
N/* Possible return values for eTaskConfirmSleepModeStatus(). */
Ntypedef enum
N{
N	eAbortSleep = 0,		/* A task has been made ready or a context switch pended since portSUPPORESS_TICKS_AND_SLEEP() was called - abort entering a sleep mode. */
N	eStandardSleep,			/* Enter a sleep mode that will not last any longer than the expected idle time. */
N	eNoTasksWaitingTimeout	/* No tasks are waiting for a timeout so it is safe to enter a sleep mode that can only be exited by an external interrupt. */
N} eSleepModeStatus;
N
N/**
N * Defines the priority used by the idle task.  This must not be modified.
N *
N * \ingroup TaskUtils
N */
N#define tskIDLE_PRIORITY			( ( UBaseType_t ) 0U )
N
N/**
N * task. h
N *
N * Macro for forcing a context switch.
N *
N * \defgroup taskYIELD taskYIELD
N * \ingroup SchedulerControl
N */
N#define taskYIELD()					portYIELD()
N
N/**
N * task. h
N *
N * Macro to mark the start of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskENTER_CRITICAL taskENTER_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskENTER_CRITICAL()		portENTER_CRITICAL()
N#define taskENTER_CRITICAL_FROM_ISR() portSET_INTERRUPT_MASK_FROM_ISR()
N
N/**
N * task. h
N *
N * Macro to mark the end of a critical code region.  Preemptive context
N * switches cannot occur when in a critical region.
N *
N * NOTE: This may alter the stack (depending on the portable implementation)
N * so must be used with care!
N *
N * \defgroup taskEXIT_CRITICAL taskEXIT_CRITICAL
N * \ingroup SchedulerControl
N */
N#define taskEXIT_CRITICAL()			portEXIT_CRITICAL()
N#define taskEXIT_CRITICAL_FROM_ISR( x ) portCLEAR_INTERRUPT_MASK_FROM_ISR( x )
N/**
N * task. h
N *
N * Macro to disable all maskable interrupts.
N *
N * \defgroup taskDISABLE_INTERRUPTS taskDISABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskDISABLE_INTERRUPTS()	portDISABLE_INTERRUPTS()
N
N/**
N * task. h
N *
N * Macro to enable microcontroller interrupts.
N *
N * \defgroup taskENABLE_INTERRUPTS taskENABLE_INTERRUPTS
N * \ingroup SchedulerControl
N */
N#define taskENABLE_INTERRUPTS()		portENABLE_INTERRUPTS()
N
N/* Definitions returned by xTaskGetSchedulerState().  taskSCHEDULER_SUSPENDED is
N0 to generate more optimal code when configASSERT() is defined as the constant
Nis used in assert() statements. */
N#define taskSCHEDULER_SUSPENDED		( ( BaseType_t ) 0 )
N#define taskSCHEDULER_NOT_STARTED	( ( BaseType_t ) 1 )
N#define taskSCHEDULER_RUNNING		( ( BaseType_t ) 2 )
N
N
N/*-----------------------------------------------------------
N * TASK CREATION API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreate(
N							  TaskFunction_t pvTaskCode,
N							  const char * const pcName,
N							  configSTACK_DEPTH_TYPE usStackDepth,
N							  void *pvParameters,
N							  UBaseType_t uxPriority,
N							  TaskHandle_t *pvCreatedTask
N						  );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * See xTaskCreateStatic() for a version that does not use any dynamic memory
N * allocation.
N *
N * xTaskCreate() can only be used to create a task that has unrestricted
N * access to the entire microcontroller memory map.  Systems that include MPU
N * support can alternatively create an MPU constrained task using
N * xTaskCreateRestricted().
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  Max length defined by configMAX_TASK_NAME_LEN - default
N * is 16.
N *
N * @param usStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 16 bits wide and usStackDepth is defined as 100, 200 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task should run.  Systems that
N * include MPU support can optionally create tasks in a privileged (system)
N * mode by setting bit portPRIVILEGE_BIT of the priority parameter.  For
N * example, to create a privileged task at priority 2 the uxPriority parameter
N * should be set to ( 2 | portPRIVILEGE_BIT ).
N *
N * @param pvCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N // Task to be created.
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N	 }
N }
N
N // Function that creates a task.
N void vOtherFunction( void )
N {
N static uint8_t ucParameterToPass;
N TaskHandle_t xHandle = NULL;
N
N	 // Create the task, storing the handle.  Note that the passed parameter ucParameterToPass
N	 // must exist for the lifetime of the task, so in this case is declared static.  If it was just an
N	 // an automatic stack variable it might no longer exist, or at least have been corrupted, by the time
N	 // the new task attempts to access it.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, &ucParameterToPass, tskIDLE_PRIORITY, &xHandle );
N     configASSERT( xHandle );
N
N	 // Use the handle to delete the task.
N     if( xHandle != NULL )
N     {
N	     vTaskDelete( xHandle );
N     }
N }
N   </pre>
N * \defgroup xTaskCreate xTaskCreate
N * \ingroup Tasks
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
N							const char * const pcName,	/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N							const configSTACK_DEPTH_TYPE usStackDepth,
X							const uint16_t usStackDepth,
N							void * const pvParameters,
N							UBaseType_t uxPriority,
N							TaskHandle_t * const pxCreatedTask ) PRIVILEGED_FUNCTION;
X							TaskHandle_t * const pxCreatedTask ) ;
N#endif
N
N/**
N * task. h
N *<pre>
N TaskHandle_t xTaskCreateStatic( TaskFunction_t pvTaskCode,
N								 const char * const pcName,
N								 uint32_t ulStackDepth,
N								 void *pvParameters,
N								 UBaseType_t uxPriority,
N								 StackType_t *pxStackBuffer,
N								 StaticTask_t *pxTaskBuffer );</pre>
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreate() then both blocks of memory are automatically dynamically
N * allocated inside the xTaskCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a task is created using
N * xTaskCreateStatic() then the application writer must provide the required
N * memory.  xTaskCreateStatic() therefore allows a task to be created without
N * using any dynamic memory allocation.
N *
N * @param pvTaskCode Pointer to the task entry function.  Tasks
N * must be implemented to never return (i.e. continuous loop).
N *
N * @param pcName A descriptive name for the task.  This is mainly used to
N * facilitate debugging.  The maximum length of the string is defined by
N * configMAX_TASK_NAME_LEN in FreeRTOSConfig.h.
N *
N * @param ulStackDepth The size of the task stack specified as the number of
N * variables the stack can hold - not the number of bytes.  For example, if
N * the stack is 32-bits wide and ulStackDepth is defined as 100 then 400 bytes
N * will be allocated for stack storage.
N *
N * @param pvParameters Pointer that will be used as the parameter for the task
N * being created.
N *
N * @param uxPriority The priority at which the task will run.
N *
N * @param pxStackBuffer Must point to a StackType_t array that has at least
N * ulStackDepth indexes - the array will then be used as the task's stack,
N * removing the need for the stack to be allocated dynamically.
N *
N * @param pxTaskBuffer Must point to a variable of type StaticTask_t, which will
N * then be used to hold the task's data structures, removing the need for the
N * memory to be allocated dynamically.
N *
N * @return If neither pxStackBuffer or pxTaskBuffer are NULL, then the task will
N * be created and pdPASS is returned.  If either pxStackBuffer or pxTaskBuffer
N * are NULL then the task will not be created and
N * errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY is returned.
N *
N * Example usage:
N   <pre>
N
N    // Dimensions the buffer that the task being created will use as its stack.
N    // NOTE:  This is the number of words the stack will hold, not the number of
N    // bytes.  For example, if each stack item is 32-bits, and this is set to 100,
N    // then 400 bytes (100 * 32-bits) will be allocated.
N    #define STACK_SIZE 200
N
N    // Structure that will hold the TCB of the task being created.
N    StaticTask_t xTaskBuffer;
N
N    // Buffer that the task being created will use as its stack.  Note this is
N    // an array of StackType_t variables.  The size of StackType_t is dependent on
N    // the RTOS port.
N    StackType_t xStack[ STACK_SIZE ];
N
N    // Function that implements the task being created.
N    void vTaskCode( void * pvParameters )
N    {
N        // The parameter value is expected to be 1 as 1 is passed in the
N        // pvParameters value in the call to xTaskCreateStatic().
N        configASSERT( ( uint32_t ) pvParameters == 1UL );
N
N        for( ;; )
N        {
N            // Task code goes here.
N        }
N    }
N
N    // Function that creates a task.
N    void vOtherFunction( void )
N    {
N        TaskHandle_t xHandle = NULL;
N
N        // Create the task without using any dynamic memory allocation.
N        xHandle = xTaskCreateStatic(
N                      vTaskCode,       // Function that implements the task.
N                      "NAME",          // Text name for the task.
N                      STACK_SIZE,      // Stack size in words, not bytes.
N                      ( void * ) 1,    // Parameter passed into the task.
N                      tskIDLE_PRIORITY,// Priority at which the task is created.
N                      xStack,          // Array to use as the task's stack.
N                      &xTaskBuffer );  // Variable to hold the task's data structure.
N
N        // puxStackBuffer and pxTaskBuffer were not NULL, so the task will have
N        // been created, and xHandle will be the task's handle.  Use the handle
N        // to suspend the task.
N        vTaskSuspend( xHandle );
N    }
N   </pre>
N * \defgroup xTaskCreateStatic xTaskCreateStatic
N * \ingroup Tasks
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
N									const char * const pcName, /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N									const uint32_t ulStackDepth,
N									void * const pvParameters,
N									UBaseType_t uxPriority,
N									StackType_t * const puxStackBuffer,
N									StaticTask_t * const pxTaskBuffer ) PRIVILEGED_FUNCTION;
X									StaticTask_t * const pxTaskBuffer ) ;
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestricted( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * Only available when configSUPPORT_DYNAMIC_ALLOCATION is set to 1.
N *
N * xTaskCreateRestricted() should only be used in systems that include an MPU
N * implementation.
N *
N * Create a new task and add it to the list of tasks that are ready to run.
N * The function parameters define the memory regions and associated access
N * permissions allocated to the task.
N *
N * See xTaskCreateRestrictedStatic() for a version that does not use any
N * dynamic memory allocation.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
N#if( portUSING_MPU_WRAPPERS == 1 )
X#if( 0 == 1 )
S	BaseType_t xTaskCreateRestricted( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
N#endif
N
N/**
N * task. h
N *<pre>
N BaseType_t xTaskCreateRestrictedStatic( TaskParameters_t *pxTaskDefinition, TaskHandle_t *pxCreatedTask );</pre>
N *
N * Only available when configSUPPORT_STATIC_ALLOCATION is set to 1.
N *
N * xTaskCreateRestrictedStatic() should only be used in systems that include an
N * MPU implementation.
N *
N * Internally, within the FreeRTOS implementation, tasks use two blocks of
N * memory.  The first block is used to hold the task's data structures.  The
N * second block is used by the task as its stack.  If a task is created using
N * xTaskCreateRestricted() then the stack is provided by the application writer,
N * and the memory used to hold the task's data structure is automatically
N * dynamically allocated inside the xTaskCreateRestricted() function.  If a task
N * is created using xTaskCreateRestrictedStatic() then the application writer
N * must provide the memory used to hold the task's data structures too.
N * xTaskCreateRestrictedStatic() therefore allows a memory protected task to be
N * created without using any dynamic memory allocation.
N *
N * @param pxTaskDefinition Pointer to a structure that contains a member
N * for each of the normal xTaskCreate() parameters (see the xTaskCreate() API
N * documentation) plus an optional stack buffer and the memory region
N * definitions.  If configSUPPORT_STATIC_ALLOCATION is set to 1 the structure
N * contains an additional member, which is used to point to a variable of type
N * StaticTask_t - which is then used to hold the task's data structure.
N *
N * @param pxCreatedTask Used to pass back a handle by which the created task
N * can be referenced.
N *
N * @return pdPASS if the task was successfully created and added to a ready
N * list, otherwise an error code defined in the file projdefs.h
N *
N * Example usage:
N   <pre>
N// Create an TaskParameters_t structure that defines the task to be created.
N// The StaticTask_t variable is only included in the structure when
N// configSUPPORT_STATIC_ALLOCATION is set to 1.  The PRIVILEGED_DATA macro can
N// be used to force the variable into the RTOS kernel's privileged data area.
Nstatic PRIVILEGED_DATA StaticTask_t xTaskBuffer;
Nstatic const TaskParameters_t xCheckTaskParameters =
N{
N	vATask,		// pvTaskCode - the function that implements the task.
N	"ATask",	// pcName - just a text name for the task to assist debugging.
N	100,		// usStackDepth	- the stack size DEFINED IN WORDS.
N	NULL,		// pvParameters - passed into the task function as the function parameters.
N	( 1UL | portPRIVILEGE_BIT ),// uxPriority - task priority, set the portPRIVILEGE_BIT if the task should run in a privileged state.
N	cStackBuffer,// puxStackBuffer - the buffer to be used as the task stack.
N
N	// xRegions - Allocate up to three separate memory regions for access by
N	// the task, with appropriate access permissions.  Different processors have
N	// different memory alignment requirements - refer to the FreeRTOS documentation
N	// for full information.
N	{
N		// Base address					Length	Parameters
N        { cReadWriteArray,				32,		portMPU_REGION_READ_WRITE },
N        { cReadOnlyArray,				32,		portMPU_REGION_READ_ONLY },
N        { cPrivilegedOnlyAccessArray,	128,	portMPU_REGION_PRIVILEGED_READ_WRITE }
N	}
N
N	&xTaskBuffer; // Holds the task's data structure.
N};
N
Nint main( void )
N{
NTaskHandle_t xHandle;
N
N	// Create a task from the const structure defined above.  The task handle
N	// is requested (the second parameter is not NULL) but in this case just for
N	// demonstration purposes as its not actually used.
N	xTaskCreateRestricted( &xRegTest1Parameters, &xHandle );
N
N	// Start the scheduler.
N	vTaskStartScheduler();
N
N	// Will only get here if there was insufficient memory to create the idle
N	// and/or timer task.
N	for( ;; );
N}
N   </pre>
N * \defgroup xTaskCreateRestrictedStatic xTaskCreateRestrictedStatic
N * \ingroup Tasks
N */
N#if( ( portUSING_MPU_WRAPPERS == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
X#if( ( 0 == 1 ) && ( 1 == 1 ) )
S	BaseType_t xTaskCreateRestrictedStatic( const TaskParameters_t * const pxTaskDefinition, TaskHandle_t *pxCreatedTask ) PRIVILEGED_FUNCTION;
N#endif
N
N/**
N * task. h
N *<pre>
N void vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions );</pre>
N *
N * Memory regions are assigned to a restricted task when the task is created by
N * a call to xTaskCreateRestricted().  These regions can be redefined using
N * vTaskAllocateMPURegions().
N *
N * @param xTask The handle of the task being updated.
N *
N * @param xRegions A pointer to an MemoryRegion_t structure that contains the
N * new memory region definitions.
N *
N * Example usage:
N   <pre>
N// Define an array of MemoryRegion_t structures that configures an MPU region
N// allowing read/write access for 1024 bytes starting at the beginning of the
N// ucOneKByte array.  The other two of the maximum 3 definable regions are
N// unused so set to zero.
Nstatic const MemoryRegion_t xAltRegions[ portNUM_CONFIGURABLE_REGIONS ] =
N{
N	// Base address		Length		Parameters
N	{ ucOneKByte,		1024,		portMPU_REGION_READ_WRITE },
N	{ 0,				0,			0 },
N	{ 0,				0,			0 }
N};
N
Nvoid vATask( void *pvParameters )
N{
N	// This task was created such that it has access to certain regions of
N	// memory as defined by the MPU configuration.  At some point it is
N	// desired that these MPU regions are replaced with that defined in the
N	// xAltRegions const struct above.  Use a call to vTaskAllocateMPURegions()
N	// for this purpose.  NULL is used as the task handle to indicate that this
N	// function should modify the MPU regions of the calling task.
N	vTaskAllocateMPURegions( NULL, xAltRegions );
N
N	// Now the task can continue its function, but from this point on can only
N	// access its stack and the ucOneKByte array (unless any other statically
N	// defined or shared regions have been declared elsewhere).
N}
N   </pre>
N * \defgroup xTaskCreateRestricted xTaskCreateRestricted
N * \ingroup Tasks
N */
Nvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) PRIVILEGED_FUNCTION;
Xvoid vTaskAllocateMPURegions( TaskHandle_t xTask, const MemoryRegion_t * const pxRegions ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelete( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_vTaskDelete must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Remove a task from the RTOS real time kernel's management.  The task being
N * deleted will be removed from all ready, blocked, suspended and event lists.
N *
N * NOTE:  The idle task is responsible for freeing the kernel allocated
N * memory from tasks that have been deleted.  It is therefore important that
N * the idle task is not starved of microcontroller processing time if your
N * application makes any calls to vTaskDelete ().  Memory allocated by the
N * task code is not automatically freed, and should be freed before the task
N * is deleted.
N *
N * See the demo application file death.c for sample code that utilises
N * vTaskDelete ().
N *
N * @param xTask The handle of the task to be deleted.  Passing NULL will
N * cause the calling task to be deleted.
N *
N * Example usage:
N   <pre>
N void vOtherFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create the task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // Use the handle to delete the task.
N	 vTaskDelete( xHandle );
N }
N   </pre>
N * \defgroup vTaskDelete vTaskDelete
N * \ingroup Tasks
N */
Nvoid vTaskDelete( TaskHandle_t xTaskToDelete ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelete( TaskHandle_t xTaskToDelete ) ;
N
N/*-----------------------------------------------------------
N * TASK CONTROL API
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskDelay( const TickType_t xTicksToDelay );</pre>
N *
N * Delay a task for a given number of ticks.  The actual time that the
N * task remains blocked depends on the tick rate.  The constant
N * portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * INCLUDE_vTaskDelay must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N *
N * vTaskDelay() specifies a time at which the task wishes to unblock relative to
N * the time at which vTaskDelay() is called.  For example, specifying a block
N * period of 100 ticks will cause the task to unblock 100 ticks after
N * vTaskDelay() is called.  vTaskDelay() does not therefore provide a good method
N * of controlling the frequency of a periodic task as the path taken through the
N * code, as well as other task and interrupt activity, will effect the frequency
N * at which vTaskDelay() gets called and therefore the time at which the task
N * next executes.  See vTaskDelayUntil() for an alternative API function designed
N * to facilitate fixed frequency execution.  It does this by specifying an
N * absolute time (rather than a relative time) at which the calling task should
N * unblock.
N *
N * @param xTicksToDelay The amount of time, in tick periods, that
N * the calling task should block.
N *
N * Example usage:
N
N void vTaskFunction( void * pvParameters )
N {
N // Block for 500ms.
N const TickType_t xDelay = 500 / portTICK_PERIOD_MS;
N
N	 for( ;; )
N	 {
N		 // Simply toggle the LED every 500ms, blocking between each toggle.
N		 vToggleLED();
N		 vTaskDelay( xDelay );
N	 }
N }
N
N * \defgroup vTaskDelay vTaskDelay
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelay( const TickType_t xTicksToDelay ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelay( const TickType_t xTicksToDelay ) ;
N
N/**
N * task. h
N * <pre>void vTaskDelayUntil( TickType_t *pxPreviousWakeTime, const TickType_t xTimeIncrement );</pre>
N *
N * INCLUDE_vTaskDelayUntil must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Delay a task until a specified time.  This function can be used by periodic
N * tasks to ensure a constant execution frequency.
N *
N * This function differs from vTaskDelay () in one important aspect:  vTaskDelay () will
N * cause a task to block for the specified number of ticks from the time vTaskDelay () is
N * called.  It is therefore difficult to use vTaskDelay () by itself to generate a fixed
N * execution frequency as the time between a task starting to execute and that task
N * calling vTaskDelay () may not be fixed [the task may take a different path though the
N * code between calls, or may get interrupted or preempted a different number of times
N * each time it executes].
N *
N * Whereas vTaskDelay () specifies a wake time relative to the time at which the function
N * is called, vTaskDelayUntil () specifies the absolute (exact) time at which it wishes to
N * unblock.
N *
N * The constant portTICK_PERIOD_MS can be used to calculate real time from the tick
N * rate - with the resolution of one tick period.
N *
N * @param pxPreviousWakeTime Pointer to a variable that holds the time at which the
N * task was last unblocked.  The variable must be initialised with the current time
N * prior to its first use (see the example below).  Following this the variable is
N * automatically updated within vTaskDelayUntil ().
N *
N * @param xTimeIncrement The cycle time period.  The task will be unblocked at
N * time *pxPreviousWakeTime + xTimeIncrement.  Calling vTaskDelayUntil with the
N * same xTimeIncrement parameter value will cause the task to execute with
N * a fixed interface period.
N *
N * Example usage:
N   <pre>
N // Perform an action every 10 ticks.
N void vTaskFunction( void * pvParameters )
N {
N TickType_t xLastWakeTime;
N const TickType_t xFrequency = 10;
N
N	 // Initialise the xLastWakeTime variable with the current time.
N	 xLastWakeTime = xTaskGetTickCount ();
N	 for( ;; )
N	 {
N		 // Wait for the next cycle.
N		 vTaskDelayUntil( &xLastWakeTime, xFrequency );
N
N		 // Perform action here.
N	 }
N }
N   </pre>
N * \defgroup vTaskDelayUntil vTaskDelayUntil
N * \ingroup TaskCtrl
N */
Nvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) PRIVILEGED_FUNCTION;
Xvoid vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskAbortDelay( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_xTaskAbortDelay must be defined as 1 in FreeRTOSConfig.h for this
N * function to be available.
N *
N * A task will enter the Blocked state when it is waiting for an event.  The
N * event it is waiting for can be a temporal event (waiting for a time), such
N * as when vTaskDelay() is called, or an event on an object, such as when
N * xQueueReceive() or ulTaskNotifyTake() is called.  If the handle of a task
N * that is in the Blocked state is used in a call to xTaskAbortDelay() then the
N * task will leave the Blocked state, and return from whichever function call
N * placed the task into the Blocked state.
N *
N * @param xTask The handle of the task to remove from the Blocked state.
N *
N * @return If the task referenced by xTask was not in the Blocked state then
N * pdFAIL is returned.  Otherwise pdPASS is returned.
N *
N * \defgroup xTaskAbortDelay xTaskAbortDelay
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskAbortDelay( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_uxTaskPriorityGet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the priority of any task.
N *
N * @param xTask Handle of the task to be queried.  Passing a NULL
N * handle results in the priority of the calling task being returned.
N *
N * @return The priority of xTask.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to obtain the priority of the created task.
N	 // It was created with tskIDLE_PRIORITY, but may have changed
N	 // it itself.
N	 if( uxTaskPriorityGet( xHandle ) != tskIDLE_PRIORITY )
N	 {
N		 // The task has changed it's priority.
N	 }
N
N	 // ...
N
N	 // Is our priority higher than the created task?
N	 if( uxTaskPriorityGet( xHandle ) < uxTaskPriorityGet( NULL ) )
N	 {
N		 // Our priority (obtained using NULL handle) is higher.
N	 }
N }
N   </pre>
N * \defgroup uxTaskPriorityGet uxTaskPriorityGet
N * \ingroup TaskCtrl
N */
NUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGet( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask );</pre>
N *
N * A version of uxTaskPriorityGet() that can be used from an ISR.
N */
NUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>eTaskState eTaskGetState( TaskHandle_t xTask );</pre>
N *
N * INCLUDE_eTaskGetState must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Obtain the state of any task.  States are encoded by the eTaskState
N * enumerated type.
N *
N * @param xTask Handle of the task to be queried.
N *
N * @return The state of xTask at the time the function was called.  Note the
N * state of the task might change between the function being called, and the
N * functions return value being tested by the calling task.
N */
NeTaskState eTaskGetState( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XeTaskState eTaskGetState( TaskHandle_t xTask ) ;
N
N/**
N * task. h
N * <pre>void vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState );</pre>
N *
N * configUSE_TRACE_FACILITY must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * Populates a TaskStatus_t structure with information about a task.
N *
N * @param xTask Handle of the task being queried.  If xTask is NULL then
N * information will be returned about the calling task.
N *
N * @param pxTaskStatus A pointer to the TaskStatus_t structure that will be
N * filled with information about the task referenced by the handle passed using
N * the xTask parameter.
N *
N * @xGetFreeStackSpace The TaskStatus_t structure contains a member to report
N * the stack high water mark of the task being queried.  Calculating the stack
N * high water mark takes a relatively long time, and can make the system
N * temporarily unresponsive - so the xGetFreeStackSpace parameter is provided to
N * allow the high water mark checking to be skipped.  The high watermark value
N * will only be written to the TaskStatus_t structure if xGetFreeStackSpace is
N * not set to pdFALSE;
N *
N * @param eState The TaskStatus_t structure contains a member to report the
N * state of the task being queried.  Obtaining the task state is not as fast as
N * a simple assignment - so the eState parameter is provided to allow the state
N * information to be omitted from the TaskStatus_t structure.  To obtain state
N * information then set eState to eInvalid - otherwise the value passed in
N * eState will be reported as the task state in the TaskStatus_t structure.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N TaskStatus_t xTaskDetails;
N
N    // Obtain the handle of a task from its name.
N    xHandle = xTaskGetHandle( "Task_Name" );
N
N    // Check the handle is not NULL.
N    configASSERT( xHandle );
N
N    // Use the handle to obtain further information about the task.
N    vTaskGetInfo( xHandle,
N                  &xTaskDetails,
N                  pdTRUE, // Include the high water mark in xTaskDetails.
N                  eInvalid ); // Include the task state in xTaskDetails.
N }
N   </pre>
N * \defgroup vTaskGetInfo vTaskGetInfo
N * \ingroup TaskCtrl
N */
Nvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) PRIVILEGED_FUNCTION;
Xvoid vTaskGetInfo( TaskHandle_t xTask, TaskStatus_t *pxTaskStatus, BaseType_t xGetFreeStackSpace, eTaskState eState ) ;
N
N/**
N * task. h
N * <pre>void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority );</pre>
N *
N * INCLUDE_vTaskPrioritySet must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Set the priority of any task.
N *
N * A context switch will occur before the function returns if the priority
N * being set is higher than the currently executing task.
N *
N * @param xTask Handle to the task for which the priority is being set.
N * Passing a NULL handle results in the priority of the calling task being set.
N *
N * @param uxNewPriority The priority to which the task will be set.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to raise the priority of the created task.
N	 vTaskPrioritySet( xHandle, tskIDLE_PRIORITY + 1 );
N
N	 // ...
N
N	 // Use a NULL handle to raise our priority to the same value.
N	 vTaskPrioritySet( NULL, tskIDLE_PRIORITY + 1 );
N }
N   </pre>
N * \defgroup vTaskPrioritySet vTaskPrioritySet
N * \ingroup TaskCtrl
N */
Nvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) PRIVILEGED_FUNCTION;
Xvoid vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspend( TaskHandle_t xTaskToSuspend );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Suspend any task.  When suspended a task will never get any microcontroller
N * processing time, no matter what its priority.
N *
N * Calls to vTaskSuspend are not accumulative -
N * i.e. calling vTaskSuspend () twice on the same task still only requires one
N * call to vTaskResume () to ready the suspended task.
N *
N * @param xTaskToSuspend Handle to the task being suspended.  Passing a NULL
N * handle will cause the calling task to be suspended.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Suspend ourselves.
N	 vTaskSuspend( NULL );
N
N	 // We cannot get here unless another task calls vTaskResume
N	 // with our handle as the parameter.
N }
N   </pre>
N * \defgroup vTaskSuspend vTaskSuspend
N * \ingroup TaskCtrl
N */
Nvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspend( TaskHandle_t xTaskToSuspend ) ;
N
N/**
N * task. h
N * <pre>void vTaskResume( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_vTaskSuspend must be defined as 1 for this function to be available.
N * See the configuration section for more information.
N *
N * Resumes a suspended task.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * vTaskResume ().
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N TaskHandle_t xHandle;
N
N	 // Create a task, storing the handle.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, &xHandle );
N
N	 // ...
N
N	 // Use the handle to suspend the created task.
N	 vTaskSuspend( xHandle );
N
N	 // ...
N
N	 // The created task will not run during this period, unless
N	 // another task calls vTaskResume( xHandle ).
N
N	 //...
N
N
N	 // Resume the suspended task ourselves.
N	 vTaskResume( xHandle );
N
N	 // The created task will once again get microcontroller processing
N	 // time in accordance with its priority within the system.
N }
N   </pre>
N * \defgroup vTaskResume vTaskResume
N * \ingroup TaskCtrl
N */
Nvoid vTaskResume( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
Xvoid vTaskResume( TaskHandle_t xTaskToResume ) ;
N
N/**
N * task. h
N * <pre>void xTaskResumeFromISR( TaskHandle_t xTaskToResume );</pre>
N *
N * INCLUDE_xTaskResumeFromISR must be defined as 1 for this function to be
N * available.  See the configuration section for more information.
N *
N * An implementation of vTaskResume() that can be called from within an ISR.
N *
N * A task that has been suspended by one or more calls to vTaskSuspend ()
N * will be made available for running again by a single call to
N * xTaskResumeFromISR ().
N *
N * xTaskResumeFromISR() should not be used to synchronise a task with an
N * interrupt if there is a chance that the interrupt could arrive prior to the
N * task being suspended - as this can lead to interrupts being missed. Use of a
N * semaphore as a synchronisation mechanism would avoid this eventuality.
N *
N * @param xTaskToResume Handle to the task being readied.
N *
N * @return pdTRUE if resuming the task should result in a context switch,
N * otherwise pdFALSE. This is used by the ISR to determine if a context switch
N * may be required following the ISR.
N *
N * \defgroup vTaskResumeFromISR vTaskResumeFromISR
N * \ingroup TaskCtrl
N */
NBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume ) ;
N
N/*-----------------------------------------------------------
N * SCHEDULER CONTROL
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <pre>void vTaskStartScheduler( void );</pre>
N *
N * Starts the real time kernel tick processing.  After calling the kernel
N * has control over which tasks are executed and when.
N *
N * See the demo application file main.c for an example of creating
N * tasks and starting the kernel.
N *
N * Example usage:
N   <pre>
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will not get here unless a task calls vTaskEndScheduler ()
N }
N   </pre>
N *
N * \defgroup vTaskStartScheduler vTaskStartScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskStartScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskStartScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskEndScheduler( void );</pre>
N *
N * NOTE:  At the time of writing only the x86 real mode port, which runs on a PC
N * in place of DOS, implements this function.
N *
N * Stops the real time kernel tick.  All created tasks will be automatically
N * deleted and multitasking (either preemptive or cooperative) will
N * stop.  Execution then resumes from the point where vTaskStartScheduler ()
N * was called, as if vTaskStartScheduler () had just returned.
N *
N * See the demo application file main. c in the demo/PC directory for an
N * example that uses vTaskEndScheduler ().
N *
N * vTaskEndScheduler () requires an exit function to be defined within the
N * portable layer (see vPortEndScheduler () in port. c for the PC port).  This
N * performs hardware specific operations such as stopping the kernel tick.
N *
N * vTaskEndScheduler () will cause all of the resources allocated by the
N * kernel to be freed - but will not free resources allocated by application
N * tasks.
N *
N * Example usage:
N   <pre>
N void vTaskCode( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // At some point we want to end the real time kernel processing
N		 // so call ...
N		 vTaskEndScheduler ();
N	 }
N }
N
N void vAFunction( void )
N {
N	 // Create at least one task before starting the kernel.
N	 xTaskCreate( vTaskCode, "NAME", STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
N
N	 // Start the real time kernel with preemption.
N	 vTaskStartScheduler ();
N
N	 // Will only get here when the vTaskCode () task has called
N	 // vTaskEndScheduler ().  When we get here we are back to single task
N	 // execution.
N }
N   </pre>
N *
N * \defgroup vTaskEndScheduler vTaskEndScheduler
N * \ingroup SchedulerControl
N */
Nvoid vTaskEndScheduler( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskEndScheduler( void ) ;
N
N/**
N * task. h
N * <pre>void vTaskSuspendAll( void );</pre>
N *
N * Suspends the scheduler without disabling interrupts.  Context switches will
N * not occur while the scheduler is suspended.
N *
N * After calling vTaskSuspendAll () the calling task will continue to execute
N * without risk of being swapped out until a call to xTaskResumeAll () has been
N * made.
N *
N * API functions that have the potential to cause a context switch (for example,
N * vTaskDelayUntil(), xQueueSend(), etc.) must not be called while the scheduler
N * is suspended.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the kernel
N		 // tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.
N		 xTaskResumeAll ();
N	 }
N }
N   </pre>
N * \defgroup vTaskSuspendAll vTaskSuspendAll
N * \ingroup SchedulerControl
N */
Nvoid vTaskSuspendAll( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSuspendAll( void ) ;
N
N/**
N * task. h
N * <pre>BaseType_t xTaskResumeAll( void );</pre>
N *
N * Resumes scheduler activity after it was suspended by a call to
N * vTaskSuspendAll().
N *
N * xTaskResumeAll() only resumes the scheduler.  It does not unsuspend tasks
N * that were previously suspended by a call to vTaskSuspend().
N *
N * @return If resuming the scheduler caused a context switch then pdTRUE is
N *		  returned, otherwise pdFALSE is returned.
N *
N * Example usage:
N   <pre>
N void vTask1( void * pvParameters )
N {
N	 for( ;; )
N	 {
N		 // Task code goes here.
N
N		 // ...
N
N		 // At some point the task wants to perform a long operation during
N		 // which it does not want to get swapped out.  It cannot use
N		 // taskENTER_CRITICAL ()/taskEXIT_CRITICAL () as the length of the
N		 // operation may cause interrupts to be missed - including the
N		 // ticks.
N
N		 // Prevent the real time kernel swapping out the task.
N		 vTaskSuspendAll ();
N
N		 // Perform the operation here.  There is no need to use critical
N		 // sections as we have all the microcontroller processing time.
N		 // During this time interrupts will still operate and the real
N		 // time kernel tick count will be maintained.
N
N		 // ...
N
N		 // The operation is complete.  Restart the kernel.  We want to force
N		 // a context switch - but there is no point if resuming the scheduler
N		 // caused a context switch already.
N		 if( !xTaskResumeAll () )
N		 {
N			  taskYIELD ();
N		 }
N	 }
N }
N   </pre>
N * \defgroup xTaskResumeAll xTaskResumeAll
N * \ingroup SchedulerControl
N */
NBaseType_t xTaskResumeAll( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskResumeAll( void ) ;
N
N/*-----------------------------------------------------------
N * TASK UTILITIES
N *----------------------------------------------------------*/
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCount( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * \defgroup xTaskGetTickCount xTaskGetTickCount
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCount( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCount( void ) ;
N
N/**
N * task. h
N * <PRE>TickType_t xTaskGetTickCountFromISR( void );</PRE>
N *
N * @return The count of ticks since vTaskStartScheduler was called.
N *
N * This is a version of xTaskGetTickCount() that is safe to be called from an
N * ISR - provided that TickType_t is the natural word size of the
N * microcontroller being used or interrupt nesting is either not supported or
N * not being used.
N *
N * \defgroup xTaskGetTickCountFromISR xTaskGetTickCountFromISR
N * \ingroup TaskUtils
N */
NTickType_t xTaskGetTickCountFromISR( void ) PRIVILEGED_FUNCTION;
XTickType_t xTaskGetTickCountFromISR( void ) ;
N
N/**
N * task. h
N * <PRE>uint16_t uxTaskGetNumberOfTasks( void );</PRE>
N *
N * @return The number of tasks that the real time kernel is currently managing.
N * This includes all ready, blocked and suspended tasks.  A task that
N * has been deleted but not yet freed by the idle task will also be
N * included in the count.
N *
N * \defgroup uxTaskGetNumberOfTasks uxTaskGetNumberOfTasks
N * \ingroup TaskUtils
N */
NUBaseType_t uxTaskGetNumberOfTasks( void ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetNumberOfTasks( void ) ;
N
N/**
N * task. h
N * <PRE>char *pcTaskGetName( TaskHandle_t xTaskToQuery );</PRE>
N *
N * @return The text (human readable) name of the task referenced by the handle
N * xTaskToQuery.  A task can query its own name by either passing in its own
N * handle, or by setting xTaskToQuery to NULL.
N *
N * \defgroup pcTaskGetName pcTaskGetName
N * \ingroup TaskUtils
N */
Nchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xchar *pcTaskGetName( TaskHandle_t xTaskToQuery ) ;  
N
N/**
N * task. h
N * <PRE>TaskHandle_t xTaskGetHandle( const char *pcNameToQuery );</PRE>
N *
N * NOTE:  This function takes a relatively long time to complete and should be
N * used sparingly.
N *
N * @return The handle of the task that has the human readable name pcNameToQuery.
N * NULL is returned if no matching name is found.  INCLUDE_xTaskGetHandle
N * must be set to 1 in FreeRTOSConfig.h for pcTaskGetHandle() to be available.
N *
N * \defgroup pcTaskGetHandle pcTaskGetHandle
N * \ingroup TaskUtils
N */
NTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
XTaskHandle_t xTaskGetHandle( const char *pcNameToQuery ) ;  
N
N/**
N * task.h
N * <PRE>UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask );</PRE>
N *
N * INCLUDE_uxTaskGetStackHighWaterMark must be set to 1 in FreeRTOSConfig.h for
N * this function to be available.
N *
N * Returns the high water mark of the stack associated with xTask.  That is,
N * the minimum free stack space there has been (in words, so on a 32 bit machine
N * a value of 1 means 4 bytes) since the task started.  The smaller the returned
N * number the closer the task has come to overflowing its stack.
N *
N * @param xTask Handle of the task associated with the stack to be checked.
N * Set xTask to NULL to check the stack of the calling task.
N *
N * @return The smallest amount of free stack space there has been (in words, so
N * actual spaces on the stack rather than bytes) since the task referenced by
N * xTask was created.
N */
NUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask ) ;
N
N/* When using trace macros it is sometimes necessary to include task.h before
NFreeRTOS.h.  When this is done TaskHookFunction_t will not yet have been defined,
Nso the following two prototypes will cause a compilation error.  This can be
Nfixed by simply guarding against the inclusion of these two prototypes unless
Nthey are explicitly required by the configUSE_APPLICATION_TASK_TAG configuration
Nconstant. */
N#ifdef configUSE_APPLICATION_TASK_TAG
N	#if configUSE_APPLICATION_TASK_TAG == 1
X	#if 0 == 1
S		/**
S		 * task.h
S		 * <pre>void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction );</pre>
S		 *
S		 * Sets pxHookFunction to be the task hook function used by the task xTask.
S		 * Passing xTask as NULL has the effect of setting the calling tasks hook
S		 * function.
S		 */
S		void vTaskSetApplicationTaskTag( TaskHandle_t xTask, TaskHookFunction_t pxHookFunction ) PRIVILEGED_FUNCTION;
S
S		/**
S		 * task.h
S		 * <pre>void xTaskGetApplicationTaskTag( TaskHandle_t xTask );</pre>
S		 *
S		 * Returns the pxHookFunction value assigned to the task xTask.
S		 */
S		TaskHookFunction_t xTaskGetApplicationTaskTag( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
N	#endif /* configUSE_APPLICATION_TASK_TAG ==1 */
N#endif /* ifdef configUSE_APPLICATION_TASK_TAG */
N
N#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS > 0 )
X#if( 0 > 0 )
S
S	/* Each task contains an array of pointers that is dimensioned by the
S	configNUM_THREAD_LOCAL_STORAGE_POINTERS setting in FreeRTOSConfig.h.  The
S	kernel does not use the pointers itself, so the application writer can use
S	the pointers for any purpose they wish.  The following two functions are
S	used to set and query a pointer respectively. */
S	void vTaskSetThreadLocalStoragePointer( TaskHandle_t xTaskToSet, BaseType_t xIndex, void *pvValue ) PRIVILEGED_FUNCTION;
S	void *pvTaskGetThreadLocalStoragePointer( TaskHandle_t xTaskToQuery, BaseType_t xIndex ) PRIVILEGED_FUNCTION;
S
N#endif
N
N/**
N * task.h
N * <pre>BaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter );</pre>
N *
N * Calls the hook function associated with xTask.  Passing xTask as NULL has
N * the effect of calling the Running tasks (the calling task) hook function.
N *
N * pvParameter is passed to the hook function for the task to interpret as it
N * wants.  The return value is the value returned by the task hook function
N * registered by the user.
N */
NBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCallApplicationTaskHook( TaskHandle_t xTask, void *pvParameter ) ;
N
N/**
N * xTaskGetIdleTaskHandle() is only available if
N * INCLUDE_xTaskGetIdleTaskHandle is set to 1 in FreeRTOSConfig.h.
N *
N * Simply returns the handle of the idle task.  It is not valid to call
N * xTaskGetIdleTaskHandle() before the scheduler has been started.
N */
NTaskHandle_t xTaskGetIdleTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetIdleTaskHandle( void ) ;
N
N/**
N * configUSE_TRACE_FACILITY must be defined as 1 in FreeRTOSConfig.h for
N * uxTaskGetSystemState() to be available.
N *
N * uxTaskGetSystemState() populates an TaskStatus_t structure for each task in
N * the system.  TaskStatus_t structures contain, among other things, members
N * for the task handle, task name, task priority, task state, and total amount
N * of run time consumed by the task.  See the TaskStatus_t structure
N * definition in this file for the full member list.
N *
N * NOTE:  This function is intended for debugging use only as its use results in
N * the scheduler remaining suspended for an extended period.
N *
N * @param pxTaskStatusArray A pointer to an array of TaskStatus_t structures.
N * The array must contain at least one TaskStatus_t structure for each task
N * that is under the control of the RTOS.  The number of tasks under the control
N * of the RTOS can be determined using the uxTaskGetNumberOfTasks() API function.
N *
N * @param uxArraySize The size of the array pointed to by the pxTaskStatusArray
N * parameter.  The size is specified as the number of indexes in the array, or
N * the number of TaskStatus_t structures contained in the array, not by the
N * number of bytes in the array.
N *
N * @param pulTotalRunTime If configGENERATE_RUN_TIME_STATS is set to 1 in
N * FreeRTOSConfig.h then *pulTotalRunTime is set by uxTaskGetSystemState() to the
N * total run time (as defined by the run time stats clock, see
N * http://www.freertos.org/rtos-run-time-stats.html) since the target booted.
N * pulTotalRunTime can be set to NULL to omit the total run time information.
N *
N * @return The number of TaskStatus_t structures that were populated by
N * uxTaskGetSystemState().  This should equal the number returned by the
N * uxTaskGetNumberOfTasks() API function, but will be zero if the value passed
N * in the uxArraySize parameter was too small.
N *
N * Example usage:
N   <pre>
N    // This example demonstrates how a human readable table of run time stats
N	// information is generated from raw data provided by uxTaskGetSystemState().
N	// The human readable table is written to pcWriteBuffer
N	void vTaskGetRunTimeStats( char *pcWriteBuffer )
N	{
N	TaskStatus_t *pxTaskStatusArray;
N	volatile UBaseType_t uxArraySize, x;
N	uint32_t ulTotalRunTime, ulStatsAsPercentage;
N
N		// Make sure the write buffer does not contain a string.
N		*pcWriteBuffer = 0x00;
N
N		// Take a snapshot of the number of tasks in case it changes while this
N		// function is executing.
N		uxArraySize = uxTaskGetNumberOfTasks();
N
N		// Allocate a TaskStatus_t structure for each task.  An array could be
N		// allocated statically at compile time.
N		pxTaskStatusArray = pvPortMalloc( uxArraySize * sizeof( TaskStatus_t ) );
N
N		if( pxTaskStatusArray != NULL )
N		{
N			// Generate raw status information about each task.
N			uxArraySize = uxTaskGetSystemState( pxTaskStatusArray, uxArraySize, &ulTotalRunTime );
N
N			// For percentage calculations.
N			ulTotalRunTime /= 100UL;
N
N			// Avoid divide by zero errors.
N			if( ulTotalRunTime > 0 )
N			{
N				// For each populated position in the pxTaskStatusArray array,
N				// format the raw data as human readable ASCII data
N				for( x = 0; x < uxArraySize; x++ )
N				{
N					// What percentage of the total run time has the task used?
N					// This will always be rounded down to the nearest integer.
N					// ulTotalRunTimeDiv100 has already been divided by 100.
N					ulStatsAsPercentage = pxTaskStatusArray[ x ].ulRunTimeCounter / ulTotalRunTime;
N
N					if( ulStatsAsPercentage > 0UL )
N					{
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t%lu%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter, ulStatsAsPercentage );
N					}
N					else
N					{
N						// If the percentage is zero here then the task has
N						// consumed less than 1% of the total run time.
N						sprintf( pcWriteBuffer, "%s\t\t%lu\t\t<1%%\r\n", pxTaskStatusArray[ x ].pcTaskName, pxTaskStatusArray[ x ].ulRunTimeCounter );
N					}
N
N					pcWriteBuffer += strlen( ( char * ) pcWriteBuffer );
N				}
N			}
N
N			// The array is no longer needed, free the memory it consumes.
N			vPortFree( pxTaskStatusArray );
N		}
N	}
N	</pre>
N */
NUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetSystemState( TaskStatus_t * const pxTaskStatusArray, const UBaseType_t uxArraySize, uint32_t * const pulTotalRunTime ) ;
N
N/**
N * task. h
N * <PRE>void vTaskList( char *pcWriteBuffer );</PRE>
N *
N * configUSE_TRACE_FACILITY and configUSE_STATS_FORMATTING_FUNCTIONS must
N * both be defined as 1 for this function to be available.  See the
N * configuration section of the FreeRTOS.org website for more information.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Lists all the current tasks, along with their current state and stack
N * usage high water mark.
N *
N * Tasks are reported as blocked ('B'), ready ('R'), deleted ('D') or
N * suspended ('S').
N *
N * PLEASE NOTE:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskList() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays task
N * names, states and stack usage.
N *
N * vTaskList() has a dependency on the sprintf() C library function that might
N * bloat the code size, use a lot of stack, and provide different results on
N * different platforms.  An alternative, tiny, third party, and limited
N * functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState()
N * directly to get access to raw stats data, rather than indirectly through a
N * call to vTaskList().
N *
N * @param pcWriteBuffer A buffer into which the above mentioned details
N * will be written, in ASCII form.  This buffer is assumed to be large
N * enough to contain the generated report.  Approximately 40 bytes per
N * task should be sufficient.
N *
N * \defgroup vTaskList vTaskList
N * \ingroup TaskUtils
N */
Nvoid vTaskList( char * pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskList( char * pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>void vTaskGetRunTimeStats( char *pcWriteBuffer );</PRE>
N *
N * configGENERATE_RUN_TIME_STATS and configUSE_STATS_FORMATTING_FUNCTIONS
N * must both be defined as 1 for this function to be available.  The application
N * must also then provide definitions for
N * portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() and portGET_RUN_TIME_COUNTER_VALUE()
N * to configure a peripheral timer/counter and return the timers current count
N * value respectively.  The counter should be at least 10 times the frequency of
N * the tick count.
N *
N * NOTE 1: This function will disable interrupts for its duration.  It is
N * not intended for normal application runtime use but as a debug aid.
N *
N * Setting configGENERATE_RUN_TIME_STATS to 1 will result in a total
N * accumulated execution time being stored for each task.  The resolution
N * of the accumulated time value depends on the frequency of the timer
N * configured by the portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() macro.
N * Calling vTaskGetRunTimeStats() writes the total execution time of each
N * task into a buffer, both as an absolute count value and as a percentage
N * of the total system execution time.
N *
N * NOTE 2:
N *
N * This function is provided for convenience only, and is used by many of the
N * demo applications.  Do not consider it to be part of the scheduler.
N *
N * vTaskGetRunTimeStats() calls uxTaskGetSystemState(), then formats part of the
N * uxTaskGetSystemState() output into a human readable table that displays the
N * amount of time each task has spent in the Running state in both absolute and
N * percentage terms.
N *
N * vTaskGetRunTimeStats() has a dependency on the sprintf() C library function
N * that might bloat the code size, use a lot of stack, and provide different
N * results on different platforms.  An alternative, tiny, third party, and
N * limited functionality implementation of sprintf() is provided in many of the
N * FreeRTOS/Demo sub-directories in a file called printf-stdarg.c (note
N * printf-stdarg.c does not provide a full snprintf() implementation!).
N *
N * It is recommended that production systems call uxTaskGetSystemState() directly
N * to get access to raw stats data, rather than indirectly through a call to
N * vTaskGetRunTimeStats().
N *
N * @param pcWriteBuffer A buffer into which the execution times will be
N * written, in ASCII form.  This buffer is assumed to be large enough to
N * contain the generated report.  Approximately 40 bytes per task should
N * be sufficient.
N *
N * \defgroup vTaskGetRunTimeStats vTaskGetRunTimeStats
N * \ingroup TaskUtils
N */
Nvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
Xvoid vTaskGetRunTimeStats( char *pcWriteBuffer ) ;  
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N *  pulPreviousNotificationValue -
N *  Can be used to pass out the subject task's notification value before any
N *  bits are modified by the notify function.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue ) ;
N#define xTaskNotify( xTaskToNotify, ulValue, eAction ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL )
N#define xTaskNotifyAndQuery( xTaskToNotify, ulValue, eAction, pulPreviousNotifyValue ) xTaskGenericNotify( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotifyValue ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, BaseType_t *pxHigherPriorityTaskWoken );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotify() that can be used from an interrupt service routine
N * (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param ulValue Data that can be sent with the notification.  How the data is
N * used depends on the value of the eAction parameter.
N *
N * @param eAction Specifies how the notification updates the task's notification
N * value, if at all.  Valid values for eAction are as follows:
N *
N * eSetBits -
N * The task's notification value is bitwise ORed with ulValue.  xTaskNofify()
N * always returns pdPASS in this case.
N *
N * eIncrement -
N * The task's notification value is incremented.  ulValue is not used and
N * xTaskNotify() always returns pdPASS in this case.
N *
N * eSetValueWithOverwrite -
N * The task's notification value is set to the value of ulValue, even if the
N * task being notified had not yet processed the previous notification (the
N * task already had a notification pending).  xTaskNotify() always returns
N * pdPASS in this case.
N *
N * eSetValueWithoutOverwrite -
N * If the task being notified did not already have a notification pending then
N * the task's notification value is set to ulValue and xTaskNotify() will
N * return pdPASS.  If the task being notified already had a notification
N * pending then no action is performed and pdFAIL is returned.
N *
N * eNoAction -
N * The task receives a notification without its notification value being
N * updated.  ulValue is not used and xTaskNotify() always returns pdPASS in
N * this case.
N *
N * @param pxHigherPriorityTaskWoken  xTaskNotifyFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * xTaskNotifyFromISR() sets this value to pdTRUE then a context switch should
N * be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * @return Dependent on the value of eAction.  See the description of the
N * eAction parameter.
N *
N * \defgroup xTaskNotify xTaskNotify
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken ) ;
N#define xTaskNotifyFromISR( xTaskToNotify, ulValue, eAction, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), NULL, ( pxHigherPriorityTaskWoken ) )
N#define xTaskNotifyAndQueryFromISR( xTaskToNotify, ulValue, eAction, pulPreviousNotificationValue, pxHigherPriorityTaskWoken ) xTaskGenericNotifyFromISR( ( xTaskToNotify ), ( ulValue ), ( eAction ), ( pulPreviousNotificationValue ), ( pxHigherPriorityTaskWoken ) )
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * A notification sent to a task will remain pending until it is cleared by the
N * task calling xTaskNotifyWait() or ulTaskNotifyTake().  If the task was
N * already in the Blocked state to wait for a notification when the notification
N * arrives then the task will automatically be removed from the Blocked state
N * (unblocked) and the notification cleared.
N *
N * A task can use xTaskNotifyWait() to [optionally] block to wait for a
N * notification to be pending, or ulTaskNotifyTake() to [optionally] block
N * to wait for its notification value to have a non-zero value.  The task does
N * not consume any CPU time while it is in the Blocked state.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param ulBitsToClearOnEntry Bits that are set in ulBitsToClearOnEntry value
N * will be cleared in the calling task's notification value before the task
N * checks to see if any notifications are pending, and optionally blocks if no
N * notifications are pending.  Setting ulBitsToClearOnEntry to ULONG_MAX (if
N * limits.h is included) or 0xffffffffUL (if limits.h is not included) will have
N * the effect of resetting the task's notification value to 0.  Setting
N * ulBitsToClearOnEntry to 0 will leave the task's notification value unchanged.
N *
N * @param ulBitsToClearOnExit If a notification is pending or received before
N * the calling task exits the xTaskNotifyWait() function then the task's
N * notification value (see the xTaskNotify() API function) is passed out using
N * the pulNotificationValue parameter.  Then any bits that are set in
N * ulBitsToClearOnExit will be cleared in the task's notification value (note
N * *pulNotificationValue is set before any bits are cleared).  Setting
N * ulBitsToClearOnExit to ULONG_MAX (if limits.h is included) or 0xffffffffUL
N * (if limits.h is not included) will have the effect of resetting the task's
N * notification value to 0 before the function exits.  Setting
N * ulBitsToClearOnExit to 0 will leave the task's notification value unchanged
N * when the function exits (in which case the value passed out in
N * pulNotificationValue will match the task's notification value).
N *
N * @param pulNotificationValue Used to pass the task's notification value out
N * of the function.  Note the value passed out will not be effected by the
N * clearing of any bits caused by ulBitsToClearOnExit being non-zero.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for a notification to be received, should a notification
N * not already be pending when xTaskNotifyWait() was called.  The task
N * will not consume any processing time while it is in the Blocked state.  This
N * is specified in kernel ticks, the macro pdMS_TO_TICSK( value_in_ms ) can be
N * used to convert a time specified in milliseconds to a time specified in
N * ticks.
N *
N * @return If a notification was received (including notifications that were
N * already pending when xTaskNotifyWait was called) then pdPASS is
N * returned.  Otherwise pdFAIL is returned.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyGive( TaskHandle_t xTaskToNotify );</PRE>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * xTaskNotifyGive() is a helper macro intended for use when task notifications
N * are used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given using the xSemaphoreGive() API function,
N * the equivalent action that instead uses a task notification is
N * xTaskNotifyGive().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @return xTaskNotifyGive() is a macro that calls xTaskNotify() with the
N * eAction parameter set to eIncrement - so pdPASS is always returned.
N *
N * \defgroup xTaskNotifyGive xTaskNotifyGive
N * \ingroup TaskNotifications
N */
N#define xTaskNotifyGive( xTaskToNotify ) xTaskGenericNotify( ( xTaskToNotify ), ( 0 ), eIncrement, NULL )
N
N/**
N * task. h
N * <PRE>void vTaskNotifyGiveFromISR( TaskHandle_t xTaskHandle, BaseType_t *pxHigherPriorityTaskWoken );
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this macro
N * to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * A version of xTaskNotifyGive() that can be called from an interrupt service
N * routine (ISR).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * vTaskNotifyGiveFromISR() is intended for use when task notifications are
N * used as light weight and faster binary or counting semaphore equivalents.
N * Actual FreeRTOS semaphores are given from an ISR using the
N * xSemaphoreGiveFromISR() API function, the equivalent action that instead uses
N * a task notification is vTaskNotifyGiveFromISR().
N *
N * When task notifications are being used as a binary or counting semaphore
N * equivalent then the task being notified should wait for the notification
N * using the ulTaskNotificationTake() API function rather than the
N * xTaskNotifyWait() API function.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for more details.
N *
N * @param xTaskToNotify The handle of the task being notified.  The handle to a
N * task can be returned from the xTaskCreate() API function used to create the
N * task, and the handle of the currently running task can be obtained by calling
N * xTaskGetCurrentTaskHandle().
N *
N * @param pxHigherPriorityTaskWoken  vTaskNotifyGiveFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending the notification caused the
N * task to which the notification was sent to leave the Blocked state, and the
N * unblocked task has a priority higher than the currently running task.  If
N * vTaskNotifyGiveFromISR() sets this value to pdTRUE then a context switch
N * should be requested before the interrupt is exited.  How a context switch is
N * requested from an ISR is dependent on the port - see the documentation page
N * for the port in use.
N *
N * \defgroup xTaskNotifyWait xTaskNotifyWait
N * \ingroup TaskNotifications
N */
Nvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
Xvoid vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken ) ;
N
N/**
N * task. h
N * <PRE>uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait );</pre>
N *
N * configUSE_TASK_NOTIFICATIONS must be undefined or defined as 1 for this
N * function to be available.
N *
N * When configUSE_TASK_NOTIFICATIONS is set to one each task has its own private
N * "notification value", which is a 32-bit unsigned integer (uint32_t).
N *
N * Events can be sent to a task using an intermediary object.  Examples of such
N * objects are queues, semaphores, mutexes and event groups.  Task notifications
N * are a method of sending an event directly to a task without the need for such
N * an intermediary object.
N *
N * A notification sent to a task can optionally perform an action, such as
N * update, overwrite or increment the task's notification value.  In that way
N * task notifications can be used to send data to a task, or be used as light
N * weight and fast binary or counting semaphores.
N *
N * ulTaskNotifyTake() is intended for use when a task notification is used as a
N * faster and lighter weight binary or counting semaphore alternative.  Actual
N * FreeRTOS semaphores are taken using the xSemaphoreTake() API function, the
N * equivalent action that instead uses a task notification is
N * ulTaskNotifyTake().
N *
N * When a task is using its notification value as a binary or counting semaphore
N * other tasks should send notifications to it using the xTaskNotifyGive()
N * macro, or xTaskNotify() function with the eAction parameter set to
N * eIncrement.
N *
N * ulTaskNotifyTake() can either clear the task's notification value to
N * zero on exit, in which case the notification value acts like a binary
N * semaphore, or decrement the task's notification value on exit, in which case
N * the notification value acts like a counting semaphore.
N *
N * A task can use ulTaskNotifyTake() to [optionally] block to wait for a
N * the task's notification value to be non-zero.  The task does not consume any
N * CPU time while it is in the Blocked state.
N *
N * Where as xTaskNotifyWait() will return when a notification is pending,
N * ulTaskNotifyTake() will return when the task's notification value is
N * not zero.
N *
N * See http://www.FreeRTOS.org/RTOS-task-notifications.html for details.
N *
N * @param xClearCountOnExit if xClearCountOnExit is pdFALSE then the task's
N * notification value is decremented when the function exits.  In this way the
N * notification value acts like a counting semaphore.  If xClearCountOnExit is
N * not pdFALSE then the task's notification value is cleared to zero when the
N * function exits.  In this way the notification value acts like a binary
N * semaphore.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait in
N * the Blocked state for the task's notification value to be greater than zero,
N * should the count not already be greater than zero when
N * ulTaskNotifyTake() was called.  The task will not consume any processing
N * time while it is in the Blocked state.  This is specified in kernel ticks,
N * the macro pdMS_TO_TICSK( value_in_ms ) can be used to convert a time
N * specified in milliseconds to a time specified in ticks.
N *
N * @return The task's notification count before it is either cleared to zero or
N * decremented (see the xClearCountOnExit parameter).
N *
N * \defgroup ulTaskNotifyTake ulTaskNotifyTake
N * \ingroup TaskNotifications
N */
Nuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xuint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait ) ;
N
N/**
N * task. h
N * <PRE>BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );</pre>
N *
N * If the notification state of the task referenced by the handle xTask is
N * eNotified, then set the task's notification state to eNotWaitingNotification.
N * The task's notification value is not altered.  Set xTask to NULL to clear the
N * notification state of the calling task.
N *
N * @return pdTRUE if the task's notification state was set to
N * eNotWaitingNotification, otherwise pdFALSE.
N * \defgroup xTaskNotifyStateClear xTaskNotifyStateClear
N * \ingroup TaskNotifications
N */
NBaseType_t xTaskNotifyStateClear( TaskHandle_t xTask );
N
N/*-----------------------------------------------------------
N * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
N *----------------------------------------------------------*/
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Called from the real time kernel tick (either preemptive or cooperative),
N * this increments the tick count and checks if any tasks that are blocked
N * for a finite period required removing from a blocked list and placing on
N * a ready list.  If a non-zero value is returned then a context switch is
N * required because either:
N *   + A task was removed from a blocked list because its timeout had expired,
N *     or
N *   + Time slicing is in use and there is a task of equal priority to the
N *     currently running task.
N */
NBaseType_t xTaskIncrementTick( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskIncrementTick( void ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes the calling task from the ready list and places it both
N * on the list of tasks waiting for a particular event, and the
N * list of delayed tasks.  The task will be removed from both lists
N * and replaced on the ready list should either the event occur (and
N * there be no higher priority tasks waiting on the same event) or
N * the delay period expires.
N *
N * The 'unordered' version replaces the event list item value with the
N * xItemValue value, and inserts the list item at the end of the list.
N *
N * The 'ordered' version uses the existing event list item value (which is the
N * owning tasks priority) to insert the list item into the event list is task
N * priority order.
N *
N * @param pxEventList The list containing tasks that are blocked waiting
N * for the event to occur.
N *
N * @param xItemValue The item value to use for the event list item when the
N * event list is not ordered by task priority.
N *
N * @param xTicksToWait The maximum amount of time that the task should wait
N * for the event to occur.  This is specified in kernel ticks,the constant
N * portTICK_PERIOD_MS can be used to convert kernel ticks into a real time
N * period.
N */
Nvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait ) ;
Nvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * This function performs nearly the same function as vTaskPlaceOnEventList().
N * The difference being that this function does not permit tasks to block
N * indefinitely, whereas vTaskPlaceOnEventList() does.
N *
N */
Nvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vTaskPlaceOnEventListRestricted( List_t * const pxEventList, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS AN
N * INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED.
N *
N * Removes a task from both the specified event list and the list of blocked
N * tasks, and places it on a ready queue.
N *
N * xTaskRemoveFromEventList()/vTaskRemoveFromUnorderedEventList() will be called
N * if either an event occurs to unblock a task, or the block timeout period
N * expires.
N *
N * xTaskRemoveFromEventList() is used when the event list is in task priority
N * order.  It removes the list item from the head of the event list as that will
N * have the highest priority owning task of all the tasks on the event list.
N * vTaskRemoveFromUnorderedEventList() is used when the event list is not
N * ordered and the event list items hold something other than the owning tasks
N * priority.  In this case the event list item value is updated to the value
N * passed in the xItemValue parameter.
N *
N * @return pdTRUE if the task being removed has a higher priority than the task
N * making the call, otherwise pdFALSE.
N */
NBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList ) ;
Nvoid vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) PRIVILEGED_FUNCTION;
Xvoid vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue ) ;
N
N/*
N * THIS FUNCTION MUST NOT BE USED FROM APPLICATION CODE.  IT IS ONLY
N * INTENDED FOR USE WHEN IMPLEMENTING A PORT OF THE SCHEDULER AND IS
N * AN INTERFACE WHICH IS FOR THE EXCLUSIVE USE OF THE SCHEDULER.
N *
N * Sets the pointer to the current TCB to the TCB of the highest priority task
N * that is ready to run.
N */
Nvoid vTaskSwitchContext( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskSwitchContext( void ) ;
N
N/*
N * THESE FUNCTIONS MUST NOT BE USED FROM APPLICATION CODE.  THEY ARE USED BY
N * THE EVENT BITS MODULE.
N */
NTickType_t uxTaskResetEventItemValue( void ) PRIVILEGED_FUNCTION;
XTickType_t uxTaskResetEventItemValue( void ) ;
N
N/*
N * Return the handle of the calling task.
N */
NTaskHandle_t xTaskGetCurrentTaskHandle( void ) PRIVILEGED_FUNCTION;
XTaskHandle_t xTaskGetCurrentTaskHandle( void ) ;
N
N/*
N * Capture the current time status for future reference.
N */
Nvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N/*
N * Compare the time status now with that previously captured to see if the
N * timeout has expired.
N */
NBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait ) ;
N
N/*
N * Shortcut used by the queue implementation to prevent unnecessary call to
N * taskYIELD();
N */
Nvoid vTaskMissedYield( void ) PRIVILEGED_FUNCTION;
Xvoid vTaskMissedYield( void ) ;
N
N/*
N * Returns the scheduler state as taskSCHEDULER_RUNNING,
N * taskSCHEDULER_NOT_STARTED or taskSCHEDULER_SUSPENDED.
N */
NBaseType_t xTaskGetSchedulerState( void ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskGetSchedulerState( void ) ;
N
N/*
N * Raises the priority of the mutex holder to that of the calling task should
N * the mutex holder have a priority less than the calling task.
N */
NBaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * Set the priority of a task back to its proper priority in the case that it
N * inherited a higher priority while it was holding a semaphore.
N */
NBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) PRIVILEGED_FUNCTION;
XBaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder ) ;
N
N/*
N * If a higher priority task attempting to obtain a mutex caused a lower
N * priority task to inherit the higher priority task's priority - but the higher
N * priority task then timed out without obtaining the mutex, then the lower
N * priority task will disinherit the priority again - but only down as far as
N * the highest priority task that is still waiting for the mutex (if there were
N * more than one task waiting for the mutex).
N */
Nvoid vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) PRIVILEGED_FUNCTION;
Xvoid vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask ) ;
N
N/*
N * Get the uxTCBNumber assigned to the task referenced by the xTask parameter.
N */
NUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) PRIVILEGED_FUNCTION;
XUBaseType_t uxTaskGetTaskNumber( TaskHandle_t xTask ) ;
N
N/*
N * Set the uxTaskNumber of the task referenced by the xTask parameter to
N * uxHandle.
N */
Nvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) PRIVILEGED_FUNCTION;
Xvoid vTaskSetTaskNumber( TaskHandle_t xTask, const UBaseType_t uxHandle ) ;
N
N/*
N * Only available when configUSE_TICKLESS_IDLE is set to 1.
N * If tickless mode is being used, or a low power mode is implemented, then
N * the tick interrupt will not execute during idle periods.  When this is the
N * case, the tick count value maintained by the scheduler needs to be kept up
N * to date with the actual execution time by being skipped forward by a time
N * equal to the idle period.
N */
Nvoid vTaskStepTick( const TickType_t xTicksToJump ) PRIVILEGED_FUNCTION;
Xvoid vTaskStepTick( const TickType_t xTicksToJump ) ;
N
N/*
N * Only avilable when configUSE_TICKLESS_IDLE is set to 1.
N * Provided for use within portSUPPRESS_TICKS_AND_SLEEP() to allow the port
N * specific sleep function to determine if it is ok to proceed with the sleep,
N * and if it is ok to proceed, if it is ok to sleep indefinitely.
N *
N * This function is necessary because portSUPPRESS_TICKS_AND_SLEEP() is only
N * called with the scheduler suspended, not from within a critical section.  It
N * is therefore possible for an interrupt to request a context switch between
N * portSUPPRESS_TICKS_AND_SLEEP() and the low power mode actually being
N * entered.  eTaskConfirmSleepModeStatus() should be called from a short
N * critical section between the timer being stopped and the sleep mode being
N * entered to ensure it is ok to proceed into the sleep mode.
N */
NeSleepModeStatus eTaskConfirmSleepModeStatus( void ) PRIVILEGED_FUNCTION;
XeSleepModeStatus eTaskConfirmSleepModeStatus( void ) ;
N
N/*
N * For internal use only.  Increment the mutex held count when a mutex is
N * taken and return the handle of the task that has taken the mutex.
N */
Nvoid *pvTaskIncrementMutexHeldCount( void ) PRIVILEGED_FUNCTION;
Xvoid *pvTaskIncrementMutexHeldCount( void ) ;
N
N/*
N * For internal use only.  Same as vTaskSetTimeOutState(), but without a critial
N * section.
N */
Nvoid vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) PRIVILEGED_FUNCTION;
Xvoid vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N#endif /* INC_TASK_H */
N
N
N
L 38 "Common\CMSIS-FreeRTOS\10.0.1\Source\queue.c" 2
N#include "queue.h"
L 1 ".\Common\CMSIS-FreeRTOS\10.0.1\Source\include\queue.h" 1
N/*
N * FreeRTOS Kernel V10.0.1
N * Copyright (C) 2017 Amazon.com, Inc. or its affiliates.  All Rights Reserved.
N *
N * Permission is hereby granted, free of charge, to any person obtaining a copy of
N * this software and associated documentation files (the "Software"), to deal in
N * the Software without restriction, including without limitation the rights to
N * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
N * the Software, and to permit persons to whom the Software is furnished to do so,
N * subject to the following conditions:
N *
N * The above copyright notice and this permission notice shall be included in all
N * copies or substantial portions of the Software.
N *
N * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
N * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
N * FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
N * COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
N * IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
N * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
N *
N * http://www.FreeRTOS.org
N * http://aws.amazon.com/freertos
N *
N * 1 tab == 4 spaces!
N */
N
N
N#ifndef QUEUE_H
N#define QUEUE_H
N
N#ifndef INC_FREERTOS_H
S	#error "include FreeRTOS.h" must appear in source files before "include queue.h"
N#endif
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N
N/**
N * Type by which queues are referenced.  For example, a call to xQueueCreate()
N * returns an QueueHandle_t variable that can then be used as a parameter to
N * xQueueSend(), xQueueReceive(), etc.
N */
Ntypedef void * QueueHandle_t;
N
N/**
N * Type by which queue sets are referenced.  For example, a call to
N * xQueueCreateSet() returns an xQueueSet variable that can then be used as a
N * parameter to xQueueSelectFromSet(), xQueueAddToSet(), etc.
N */
Ntypedef void * QueueSetHandle_t;
N
N/**
N * Queue sets can contain both queues and semaphores, so the
N * QueueSetMemberHandle_t is defined as a type to be used where a parameter or
N * return value can be either an QueueHandle_t or an SemaphoreHandle_t.
N */
Ntypedef void * QueueSetMemberHandle_t;
N
N/* For internal use only. */
N#define	queueSEND_TO_BACK		( ( BaseType_t ) 0 )
N#define	queueSEND_TO_FRONT		( ( BaseType_t ) 1 )
N#define queueOVERWRITE			( ( BaseType_t ) 2 )
N
N/* For internal use only.  These definitions *must* match those in queue.c. */
N#define queueQUEUE_TYPE_BASE				( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_SET					( ( uint8_t ) 0U )
N#define queueQUEUE_TYPE_MUTEX 				( ( uint8_t ) 1U )
N#define queueQUEUE_TYPE_COUNTING_SEMAPHORE	( ( uint8_t ) 2U )
N#define queueQUEUE_TYPE_BINARY_SEMAPHORE	( ( uint8_t ) 3U )
N#define queueQUEUE_TYPE_RECURSIVE_MUTEX		( ( uint8_t ) 4U )
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreate(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @return If the queue is successfully create then a handle to the newly
N * created queue is returned.  If the queue cannot be created then 0 is
N * returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N	if( xQueue1 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue2 == 0 )
N	{
N		// Queue was not created and must not be used.
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreate xQueueCreate
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xQueueCreate( uxQueueLength, uxItemSize ) xQueueGenericCreate( ( uxQueueLength ), ( uxItemSize ), ( queueQUEUE_TYPE_BASE ) )
N#endif
N
N/**
N * queue. h
N * <pre>
N QueueHandle_t xQueueCreateStatic(
N							  UBaseType_t uxQueueLength,
N							  UBaseType_t uxItemSize,
N							  uint8_t *pucQueueStorageBuffer,
N							  StaticQueue_t *pxQueueBuffer
N						  );
N * </pre>
N *
N * Creates a new queue instance, and returns a handle by which the new queue
N * can be referenced.
N *
N * Internally, within the FreeRTOS implementation, queues use two blocks of
N * memory.  The first block is used to hold the queue's data structures.  The
N * second block is used to hold items placed into the queue.  If a queue is
N * created using xQueueCreate() then both blocks of memory are automatically
N * dynamically allocated inside the xQueueCreate() function.  (see
N * http://www.freertos.org/a00111.html).  If a queue is created using
N * xQueueCreateStatic() then the application writer must provide the memory that
N * will get used by the queue.  xQueueCreateStatic() therefore allows a queue to
N * be created without using any dynamic memory allocation.
N *
N * http://www.FreeRTOS.org/Embedded-RTOS-Queues.html
N *
N * @param uxQueueLength The maximum number of items that the queue can contain.
N *
N * @param uxItemSize The number of bytes each item in the queue will require.
N * Items are queued by copy, not by reference, so this is the number of bytes
N * that will be copied for each posted item.  Each item on the queue must be
N * the same size.
N *
N * @param pucQueueStorageBuffer If uxItemSize is not zero then
N * pucQueueStorageBuffer must point to a uint8_t array that is at least large
N * enough to hold the maximum number of items that can be in the queue at any
N * one time - which is ( uxQueueLength * uxItemsSize ) bytes.  If uxItemSize is
N * zero then pucQueueStorageBuffer can be NULL.
N *
N * @param pxQueueBuffer Must point to a variable of type StaticQueue_t, which
N * will be used to hold the queue's data structure.
N *
N * @return If the queue is created then a handle to the created queue is
N * returned.  If pxQueueBuffer is NULL then NULL is returned.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N };
N
N #define QUEUE_LENGTH 10
N #define ITEM_SIZE sizeof( uint32_t )
N
N // xQueueBuffer will hold the queue structure.
N StaticQueue_t xQueueBuffer;
N
N // ucQueueStorage will hold the items posted to the queue.  Must be at least
N // [(queue length) * ( queue item size)] bytes long.
N uint8_t ucQueueStorage[ QUEUE_LENGTH * ITEM_SIZE ];
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( QUEUE_LENGTH, // The number of items the queue can hold.
N							ITEM_SIZE	  // The size of each item in the queue
N							&( ucQueueStorage[ 0 ] ), // The buffer that will hold the items in the queue.
N							&xQueueBuffer ); // The buffer that will hold the queue structure.
N
N	// The queue is guaranteed to be created successfully as no dynamic memory
N	// allocation is used.  Therefore xQueue1 is now a handle to a valid queue.
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueCreateStatic xQueueCreateStatic
N * \ingroup QueueManagement
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	#define xQueueCreateStatic( uxQueueLength, uxItemSize, pucQueueStorage, pxQueueBuffer ) xQueueGenericCreateStatic( ( uxQueueLength ), ( uxItemSize ), ( pucQueueStorage ), ( pxQueueBuffer ), ( queueQUEUE_TYPE_BASE ) )
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFront(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * Post an item to the front of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToFront( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToFront( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToFront( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_FRONT )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBack(
N								   QueueHandle_t	xQueue,
N								   const void		*pvItemToQueue,
N								   TickType_t		xTicksToWait
N							   );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().
N *
N * Post an item to the back of a queue.  The item is queued by copy, not by
N * reference.  This function must not be called from an interrupt service
N * routine.  See xQueueSendFromISR () for an alternative which may be used
N * in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the queue
N * is full.  The  time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSendToBack( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSendToBack( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSendToBack( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSend(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  TickType_t xTicksToWait
N						 );
N * </pre>
N *
N * This is a macro that calls xQueueGenericSend().  It is included for
N * backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToFront() and xQueueSendToBack() macros.  It is
N * equivalent to xQueueSendToBack().
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10 ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0 );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
N#define xQueueSend( xQueue, pvItemToQueue, xTicksToWait ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), ( xTicksToWait ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwrite(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue
N						 );
N * </pre>
N *
N * Only for use with queues that have a length of one - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * This function must not be called from an interrupt service routine.
N * See xQueueOverwriteFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle of the queue to which the data is being sent.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @return xQueueOverwrite() is a macro that calls xQueueGenericSend(), and
N * therefore has the same return values as xQueueSendToFront().  However, pdPASS
N * is the only value that can be returned because xQueueOverwrite() will write
N * to the queue even when the queue is already full.
N *
N * Example usage:
N   <pre>
N
N void vFunction( void *pvParameters )
N {
N QueueHandle_t xQueue;
N uint32_t ulVarToSend, ulValReceived;
N
N	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwrite() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N
N	// Write the value 10 to the queue using xQueueOverwrite().
N	ulVarToSend = 10;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// Peeking the queue should now return 10, but leave the value 10 in
N	// the queue.  A block time of zero is used as it is known that the
N	// queue holds a value.
N	ulValReceived = 0;
N	xQueuePeek( xQueue, &ulValReceived, 0 );
N
N	if( ulValReceived != 10 )
N	{
N		// Error unless the item was removed by a different task.
N	}
N
N	// The queue is still full.  Use xQueueOverwrite() to overwrite the
N	// value held in the queue with 100.
N	ulVarToSend = 100;
N	xQueueOverwrite( xQueue, &ulVarToSend );
N
N	// This time read from the queue, leaving the queue empty once more.
N	// A block time of 0 is used again.
N	xQueueReceive( xQueue, &ulValReceived, 0 );
N
N	// The value read should be the last value written, even though the
N	// queue was already full when the value was written.
N	if( ulValReceived != 100 )
N	{
N		// Error!
N	}
N
N	// ...
N}
N </pre>
N * \defgroup xQueueOverwrite xQueueOverwrite
N * \ingroup QueueManagement
N */
N#define xQueueOverwrite( xQueue, pvItemToQueue ) xQueueGenericSend( ( xQueue ), ( pvItemToQueue ), 0, queueOVERWRITE )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSend(
N									QueueHandle_t xQueue,
N									const void * pvItemToQueue,
N									TickType_t xTicksToWait
N									BaseType_t xCopyPosition
N								);
N * </pre>
N *
N * It is preferred that the macros xQueueSend(), xQueueSendToFront() and
N * xQueueSendToBack() are used in place of calling this function directly.
N *
N * Post an item on a queue.  The item is queued by copy, not by reference.
N * This function must not be called from an interrupt service routine.
N * See xQueueSendFromISR () for an alternative which may be used in an ISR.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for space to become available on the queue, should it already
N * be full.  The call will return immediately if this is set to 0 and the
N * queue is full.  The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the item was successfully posted, otherwise errQUEUE_FULL.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N uint32_t ulVar = 10UL;
N
N void vATask( void *pvParameters )
N {
N QueueHandle_t xQueue1, xQueue2;
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 uint32_t values.
N	xQueue1 = xQueueCreate( 10, sizeof( uint32_t ) );
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue2 = xQueueCreate( 10, sizeof( struct AMessage * ) );
N
N	// ...
N
N	if( xQueue1 != 0 )
N	{
N		// Send an uint32_t.  Wait for 10 ticks for space to become
N		// available if necessary.
N		if( xQueueGenericSend( xQueue1, ( void * ) &ulVar, ( TickType_t ) 10, queueSEND_TO_BACK ) != pdPASS )
N		{
N			// Failed to post the message, even after 10 ticks.
N		}
N	}
N
N	if( xQueue2 != 0 )
N	{
N		// Send a pointer to a struct AMessage object.  Don't block if the
N		// queue is already full.
N		pxMessage = & xMessage;
N		xQueueGenericSend( xQueue2, ( void * ) &pxMessage, ( TickType_t ) 0, queueSEND_TO_BACK );
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueSend xQueueSend
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeek(
N							 QueueHandle_t xQueue,
N							 void * const pvBuffer,
N							 TickType_t xTicksToWait
N						 );</pre>
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * This macro must not be used in an interrupt service routine.  See
N * xQueuePeekFromISR() for an alternative that can be called from an interrupt
N * service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 The time is defined in tick periods so the constant
N * portTICK_PERIOD_MS should be used to convert to real time if this is required.
N * xQueuePeek() will return immediately if xTicksToWait is 0 and the queue
N * is empty.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to peek the data from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Peek a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueuePeek( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask, but the item still remains on the queue.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueuePeek xQueuePeek
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueuePeekFromISR(
N									QueueHandle_t xQueue,
N									void *pvBuffer,
N								);</pre>
N *
N * A version of xQueuePeek() that can be called from an interrupt service
N * routine (ISR).
N *
N * Receive an item from a queue without removing the item from the queue.
N * The item is received by copy so a buffer of adequate size must be
N * provided.  The number of bytes copied into the buffer was defined when
N * the queue was created.
N *
N * Successfully received items remain on the queue so will be returned again
N * by the next call, or a call to xQueueReceive().
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * \defgroup xQueuePeekFromISR xQueuePeekFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
XBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue, void * const pvBuffer ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceive(
N								 QueueHandle_t xQueue,
N								 void *pvBuffer,
N								 TickType_t xTicksToWait
N							);</pre>
N *
N * Receive an item from a queue.  The item is received by copy so a buffer of
N * adequate size must be provided.  The number of bytes copied into the buffer
N * was defined when the queue was created.
N *
N * Successfully received items are removed from the queue.
N *
N * This function must not be used in an interrupt service routine.  See
N * xQueueReceiveFromISR for an alternative that can.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param xTicksToWait The maximum amount of time the task should block
N * waiting for an item to receive should the queue be empty at the time
N * of the call.	 xQueueReceive() will return immediately if xTicksToWait
N * is zero and the queue is empty.  The time is defined in tick periods so the
N * constant portTICK_PERIOD_MS should be used to convert to real time if this is
N * required.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N struct AMessage
N {
N	char ucMessageID;
N	char ucData[ 20 ];
N } xMessage;
N
N QueueHandle_t xQueue;
N
N // Task to create a queue and post a value.
N void vATask( void *pvParameters )
N {
N struct AMessage *pxMessage;
N
N	// Create a queue capable of containing 10 pointers to AMessage structures.
N	// These should be passed by pointer as they contain a lot of data.
N	xQueue = xQueueCreate( 10, sizeof( struct AMessage * ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Send a pointer to a struct AMessage object.  Don't block if the
N	// queue is already full.
N	pxMessage = & xMessage;
N	xQueueSend( xQueue, ( void * ) &pxMessage, ( TickType_t ) 0 );
N
N	// ... Rest of task code.
N }
N
N // Task to receive from the queue.
N void vADifferentTask( void *pvParameters )
N {
N struct AMessage *pxRxedMessage;
N
N	if( xQueue != 0 )
N	{
N		// Receive a message on the created queue.  Block for 10 ticks if a
N		// message is not immediately available.
N		if( xQueueReceive( xQueue, &( pxRxedMessage ), ( TickType_t ) 10 ) )
N		{
N			// pcRxedMessage now points to the struct AMessage variable posted
N			// by vATask.
N		}
N	}
N
N	// ... Rest of task code.
N }
N </pre>
N * \defgroup xQueueReceive xQueueReceive
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of messages stored in a queue.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of messages available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue );</pre>
N *
N * Return the number of free spaces available in a queue.  This is equal to the
N * number of items that can be sent to the queue before the queue becomes full
N * if no items are removed.
N *
N * @param xQueue A handle to the queue being queried.
N *
N * @return The number of spaces available in the queue.
N *
N * \defgroup uxQueueMessagesWaiting uxQueueMessagesWaiting
N * \ingroup QueueManagement
N */
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>void vQueueDelete( QueueHandle_t xQueue );</pre>
N *
N * Delete a queue - freeing all the memory allocated for storing of items
N * placed on the queue.
N *
N * @param xQueue A handle to the queue to be deleted.
N *
N * \defgroup vQueueDelete vQueueDelete
N * \ingroup QueueManagement
N */
Nvoid vQueueDelete( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xvoid vQueueDelete( QueueHandle_t xQueue ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToFrontFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the front of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToFrontFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToFromFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPrioritTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToFrontFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToFrontFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_FRONT )
N
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendToBackFromISR(
N										 QueueHandle_t xQueue,
N										 const void *pvItemToQueue,
N										 BaseType_t *pxHigherPriorityTaskWoken
N									  );
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().
N *
N * Post an item to the back of a queue.  It is safe to use this macro from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendToBackFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendToBackFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendToBackFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendToBackFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueOverwriteFromISR(
N							  QueueHandle_t xQueue,
N							  const void * pvItemToQueue,
N							  BaseType_t *pxHigherPriorityTaskWoken
N						 );
N * </pre>
N *
N * A version of xQueueOverwrite() that can be used in an interrupt service
N * routine (ISR).
N *
N * Only for use with queues that can hold a single item - so the queue is either
N * empty or full.
N *
N * Post an item on a queue.  If the queue is already full then overwrite the
N * value held in the queue.  The item is queued by copy, not by reference.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueOverwriteFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueOverwriteFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return xQueueOverwriteFromISR() is a macro that calls
N * xQueueGenericSendFromISR(), and therefore has the same return values as
N * xQueueSendToFrontFromISR().  However, pdPASS is the only value that can be
N * returned because xQueueOverwriteFromISR() will write to the queue even when
N * the queue is already full.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N void vFunction( void *pvParameters )
N {
N 	// Create a queue to hold one uint32_t value.  It is strongly
N	// recommended *not* to use xQueueOverwriteFromISR() on queues that can
N	// contain more than one value, and doing so will trigger an assertion
N	// if configASSERT() is defined.
N	xQueue = xQueueCreate( 1, sizeof( uint32_t ) );
N}
N
Nvoid vAnInterruptHandler( void )
N{
N// xHigherPriorityTaskWoken must be set to pdFALSE before it is used.
NBaseType_t xHigherPriorityTaskWoken = pdFALSE;
Nuint32_t ulVarToSend, ulValReceived;
N
N	// Write the value 10 to the queue using xQueueOverwriteFromISR().
N	ulVarToSend = 10;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// The queue is full, but calling xQueueOverwriteFromISR() again will still
N	// pass because the value held in the queue will be overwritten with the
N	// new value.
N	ulVarToSend = 100;
N	xQueueOverwriteFromISR( xQueue, &ulVarToSend, &xHigherPriorityTaskWoken );
N
N	// Reading from the queue will now return 100.
N
N	// ...
N
N	if( xHigherPrioritytaskWoken == pdTRUE )
N	{
N		// Writing to the queue caused a task to unblock and the unblocked task
N		// has a priority higher than or equal to the priority of the currently
N		// executing task (the task this interrupt interrupted).  Perform a context
N		// switch so this interrupt returns directly to the unblocked task.
N		portYIELD_FROM_ISR(); // or portEND_SWITCHING_ISR() depending on the port.
N	}
N}
N </pre>
N * \defgroup xQueueOverwriteFromISR xQueueOverwriteFromISR
N * \ingroup QueueManagement
N */
N#define xQueueOverwriteFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueOVERWRITE )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueSendFromISR(
N									 QueueHandle_t xQueue,
N									 const void *pvItemToQueue,
N									 BaseType_t *pxHigherPriorityTaskWoken
N								);
N </pre>
N *
N * This is a macro that calls xQueueGenericSendFromISR().  It is included
N * for backward compatibility with versions of FreeRTOS.org that did not
N * include the xQueueSendToBackFromISR() and xQueueSendToFrontFromISR()
N * macros.
N *
N * Post an item to the back of a queue.  It is safe to use this function from
N * within an interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWoken;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWoken = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post the byte.
N		xQueueSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWoken );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.
N	if( xHigherPriorityTaskWoken )
N	{
N		// Actual macro used here is port specific.
N		portYIELD_FROM_ISR ();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
N#define xQueueSendFromISR( xQueue, pvItemToQueue, pxHigherPriorityTaskWoken ) xQueueGenericSendFromISR( ( xQueue ), ( pvItemToQueue ), ( pxHigherPriorityTaskWoken ), queueSEND_TO_BACK )
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueGenericSendFromISR(
N										   QueueHandle_t		xQueue,
N										   const	void	*pvItemToQueue,
N										   BaseType_t	*pxHigherPriorityTaskWoken,
N										   BaseType_t	xCopyPosition
N									   );
N </pre>
N *
N * It is preferred that the macros xQueueSendFromISR(),
N * xQueueSendToFrontFromISR() and xQueueSendToBackFromISR() be used in place
N * of calling this function directly.  xQueueGiveFromISR() is an
N * equivalent for use by semaphores that don't actually copy any data.
N *
N * Post an item on a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * Items are queued by copy not reference so it is preferable to only
N * queue small items, especially when called from an ISR.  In most cases
N * it would be preferable to store a pointer to the item being queued.
N *
N * @param xQueue The handle to the queue on which the item is to be posted.
N *
N * @param pvItemToQueue A pointer to the item that is to be placed on the
N * queue.  The size of the items the queue will hold was defined when the
N * queue was created, so this many bytes will be copied from pvItemToQueue
N * into the queue storage area.
N *
N * @param pxHigherPriorityTaskWoken xQueueGenericSendFromISR() will set
N * *pxHigherPriorityTaskWoken to pdTRUE if sending to the queue caused a task
N * to unblock, and the unblocked task has a priority higher than the currently
N * running task.  If xQueueGenericSendFromISR() sets this value to pdTRUE then
N * a context switch should be requested before the interrupt is exited.
N *
N * @param xCopyPosition Can take the value queueSEND_TO_BACK to place the
N * item at the back of the queue, or queueSEND_TO_FRONT to place the item
N * at the front of the queue (for high priority messages).
N *
N * @return pdTRUE if the data was successfully sent to the queue, otherwise
N * errQUEUE_FULL.
N *
N * Example usage for buffered IO (where the ISR can obtain more than one value
N * per call):
N   <pre>
N void vBufferISR( void )
N {
N char cIn;
N BaseType_t xHigherPriorityTaskWokenByPost;
N
N	// We have not woken a task at the start of the ISR.
N	xHigherPriorityTaskWokenByPost = pdFALSE;
N
N	// Loop until the buffer is empty.
N	do
N	{
N		// Obtain a byte from the buffer.
N		cIn = portINPUT_BYTE( RX_REGISTER_ADDRESS );
N
N		// Post each byte.
N		xQueueGenericSendFromISR( xRxQueue, &cIn, &xHigherPriorityTaskWokenByPost, queueSEND_TO_BACK );
N
N	} while( portINPUT_BYTE( BUFFER_COUNT ) );
N
N	// Now the buffer is empty we can switch context if necessary.  Note that the
N	// name of the yield function required is port specific.
N	if( xHigherPriorityTaskWokenByPost )
N	{
N		taskYIELD_YIELD_FROM_ISR();
N	}
N }
N </pre>
N *
N * \defgroup xQueueSendFromISR xQueueSendFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition ) ;
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/**
N * queue. h
N * <pre>
N BaseType_t xQueueReceiveFromISR(
N									   QueueHandle_t	xQueue,
N									   void	*pvBuffer,
N									   BaseType_t *pxTaskWoken
N								   );
N * </pre>
N *
N * Receive an item from a queue.  It is safe to use this function from within an
N * interrupt service routine.
N *
N * @param xQueue The handle to the queue from which the item is to be
N * received.
N *
N * @param pvBuffer Pointer to the buffer into which the received item will
N * be copied.
N *
N * @param pxTaskWoken A task may be blocked waiting for space to become
N * available on the queue.  If xQueueReceiveFromISR causes such a task to
N * unblock *pxTaskWoken will get set to pdTRUE, otherwise *pxTaskWoken will
N * remain unchanged.
N *
N * @return pdTRUE if an item was successfully received from the queue,
N * otherwise pdFALSE.
N *
N * Example usage:
N   <pre>
N
N QueueHandle_t xQueue;
N
N // Function to create a queue and post some values.
N void vAFunction( void *pvParameters )
N {
N char cValueToPost;
N const TickType_t xTicksToWait = ( TickType_t )0xff;
N
N	// Create a queue capable of containing 10 characters.
N	xQueue = xQueueCreate( 10, sizeof( char ) );
N	if( xQueue == 0 )
N	{
N		// Failed to create the queue.
N	}
N
N	// ...
N
N	// Post some characters that will be used within an ISR.  If the queue
N	// is full then this task will block for xTicksToWait ticks.
N	cValueToPost = 'a';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N	cValueToPost = 'b';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N
N	// ... keep posting characters ... this task may block when the queue
N	// becomes full.
N
N	cValueToPost = 'c';
N	xQueueSend( xQueue, ( void * ) &cValueToPost, xTicksToWait );
N }
N
N // ISR that outputs all the characters received on the queue.
N void vISR_Routine( void )
N {
N BaseType_t xTaskWokenByReceive = pdFALSE;
N char cRxedChar;
N
N	while( xQueueReceiveFromISR( xQueue, ( void * ) &cRxedChar, &xTaskWokenByReceive) )
N	{
N		// A character was received.  Output the character now.
N		vOutputCharacter( cRxedChar );
N
N		// If removing the character from the queue woke the task that was
N		// posting onto the queue cTaskWokenByReceive will have been set to
N		// pdTRUE.  No matter how many times this loop iterates only one
N		// task will be woken.
N	}
N
N	if( cTaskWokenByPost != ( char ) pdFALSE;
N	{
N		taskYIELD ();
N	}
N }
N </pre>
N * \defgroup xQueueReceiveFromISR xQueueReceiveFromISR
N * \ingroup QueueManagement
N */
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken ) ;
N
N/*
N * Utilities to query queues that are safe to use from an ISR.  These utilities
N * should be used only from witin an ISR, or within a critical section.
N */
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue ) ;
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue ) ;
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue ) ;
N
N/*
N * The functions defined above are for passing data to and from tasks.  The
N * functions below are the equivalents for passing data to and from
N * co-routines.
N *
N * These functions are called from the co-routine macro implementation and
N * should not be called directly from application code.  Instead use the macro
N * wrappers defined within croutine.h.
N */
NBaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken );
NBaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxTaskWoken );
NBaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait );
NBaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait );
N
N/*
N * For internal use only.  Use xSemaphoreCreateMutex(),
N * xSemaphoreCreateCounting() or xSemaphoreGetMutexHolder() instead of calling
N * these functions directly.
N */
NQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType ) ;
NQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue ) ;
NQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount ) ;
NQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) PRIVILEGED_FUNCTION;
XQueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue ) ;
NBaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait ) ;
Nvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolder( QueueHandle_t xSemaphore ) ;
Nvoid* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) PRIVILEGED_FUNCTION;
Xvoid* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore ) ;
N
N/*
N * For internal use only.  Use xSemaphoreTakeMutexRecursive() or
N * xSemaphoreGiveMutexRecursive() instead of calling these functions directly.
N */
NBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait ) ;
NBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGiveMutexRecursive( QueueHandle_t pxMutex ) ;
N
N/*
N * Reset a queue back to its original empty state.  The return value is now
N * obsolete and is always set to pdPASS.
N */
N#define xQueueReset( xQueue ) xQueueGenericReset( xQueue, pdFALSE )
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger.  If you are not using a kernel
N * aware debugger then this function can be ignored.
N *
N * configQUEUE_REGISTRY_SIZE defines the maximum number of handles the
N * registry can hold.  configQUEUE_REGISTRY_SIZE must be greater than 0
N * within FreeRTOSConfig.h for the registry to be available.  Its value
N * does not effect the number of queues, semaphores and mutexes that can be
N * created - just the number that the registry can hold.
N *
N * @param xQueue The handle of the queue being added to the registry.  This
N * is the handle returned by a call to xQueueCreate().  Semaphore and mutex
N * handles can also be passed in here.
N *
N * @param pcName The name to be associated with the handle.  This is the
N * name that the kernel aware debugger will display.  The queue registry only
N * stores a pointer to the string - so the string must be persistent (global or
N * preferably in ROM/Flash), not on the stack.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0 > 0 )
S	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcName ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif
N
N/*
N * The registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call vQueueAddToRegistry() add
N * a queue, semaphore or mutex handle to the registry if you want the handle
N * to be available to a kernel aware debugger, and vQueueUnregisterQueue() to
N * remove the queue, semaphore or mutex from the register.  If you are not using
N * a kernel aware debugger then this function can be ignored.
N *
N * @param xQueue The handle of the queue being removed from the registry.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0 > 0 )
S	void vQueueUnregisterQueue( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * The queue registry is provided as a means for kernel aware debuggers to
N * locate queues, semaphores and mutexes.  Call pcQueueGetName() to look
N * up and return the name of a queue in the queue registry from the queue's
N * handle.
N *
N * @param xQueue The handle of the queue the name of which will be returned.
N * @return If the queue is in the registry then a pointer to the name of the
N * queue is returned.  If the queue is not in the registry then NULL is
N * returned.
N */
N#if( configQUEUE_REGISTRY_SIZE > 0 )
X#if( 0 > 0 )
S	const char *pcQueueGetName( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
X	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType ) ;
N#endif
N
N/*
N * Generic version of the function used to creaet a queue using dynamic memory
N * allocation.  This is called by other functions and macros that create other
N * RTOS objects that use the queue structure as their base.
N */
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) PRIVILEGED_FUNCTION;
X	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType ) ;
N#endif
N
N/*
N * Queue sets provide a mechanism to allow a task to block (pend) on a read
N * operation from multiple queues or semaphores simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * A queue set must be explicitly created using a call to xQueueCreateSet()
N * before it can be used.  Once created, standard FreeRTOS queues and semaphores
N * can be added to the set using calls to xQueueAddToSet().
N * xQueueSelectFromSet() is then used to determine which, if any, of the queues
N * or semaphores contained in the set is in a state where a queue read or
N * semaphore take operation would be successful.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  An additional 4 bytes of RAM is required for each space in a every
N * queue added to a queue set.  Therefore counting semaphores that have a high
N * maximum count value should not be added to a queue set.
N *
N * Note 4:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param uxEventQueueLength Queue sets store events that occur on
N * the queues and semaphores contained in the set.  uxEventQueueLength specifies
N * the maximum number of events that can be queued at once.  To be absolutely
N * certain that events are not lost uxEventQueueLength should be set to the
N * total sum of the length of the queues added to the set, where binary
N * semaphores and mutexes have a length of 1, and counting semaphores have a
N * length set by their maximum count value.  Examples:
N *  + If a queue set is to hold a queue of length 5, another queue of length 12,
N *    and a binary semaphore, then uxEventQueueLength should be set to
N *    (5 + 12 + 1), or 18.
N *  + If a queue set is to hold three binary semaphores then uxEventQueueLength
N *    should be set to (1 + 1 + 1 ), or 3.
N *  + If a queue set is to hold a counting semaphore that has a maximum count of
N *    5, and a counting semaphore that has a maximum count of 3, then
N *    uxEventQueueLength should be set to (5 + 3), or 8.
N *
N * @return If the queue set is created successfully then a handle to the created
N * queue set is returned.  Otherwise NULL is returned.
N */
NQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) PRIVILEGED_FUNCTION;
XQueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength ) ;
N
N/*
N * Adds a queue or semaphore to a queue set that was previously created by a
N * call to xQueueCreateSet().
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being added to
N * the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set to which the queue or semaphore
N * is being added.
N *
N * @return If the queue or semaphore was successfully added to the queue set
N * then pdPASS is returned.  If the queue could not be successfully added to the
N * queue set because it is already a member of a different queue set then pdFAIL
N * is returned.
N */
NBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * Removes a queue or semaphore from a queue set.  A queue or semaphore can only
N * be removed from a set if the queue or semaphore is empty.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * @param xQueueOrSemaphore The handle of the queue or semaphore being removed
N * from the queue set (cast to an QueueSetMemberHandle_t type).
N *
N * @param xQueueSet The handle of the queue set in which the queue or semaphore
N * is included.
N *
N * @return If the queue or semaphore was successfully removed from the queue set
N * then pdPASS is returned.  If the queue was not in the queue set, or the
N * queue (or semaphore) was not empty, then pdFAIL is returned.
N */
NBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet ) ;
N
N/*
N * xQueueSelectFromSet() selects from the members of a queue set a queue or
N * semaphore that either contains data (in the case of a queue) or is available
N * to take (in the case of a semaphore).  xQueueSelectFromSet() effectively
N * allows a task to block (pend) on a read operation on all the queues and
N * semaphores in a queue set simultaneously.
N *
N * See FreeRTOS/Source/Demo/Common/Minimal/QueueSet.c for an example using this
N * function.
N *
N * Note 1:  See the documentation on http://wwwFreeRTOS.org/RTOS-queue-sets.html
N * for reasons why queue sets are very rarely needed in practice as there are
N * simpler methods of blocking on multiple objects.
N *
N * Note 2:  Blocking on a queue set that contains a mutex will not cause the
N * mutex holder to inherit the priority of the blocked task.
N *
N * Note 3:  A receive (in the case of a queue) or take (in the case of a
N * semaphore) operation must not be performed on a member of a queue set unless
N * a call to xQueueSelectFromSet() has first returned a handle to that set member.
N *
N * @param xQueueSet The queue set on which the task will (potentially) block.
N *
N * @param xTicksToWait The maximum time, in ticks, that the calling task will
N * remain in the Blocked state (with other tasks executing) to wait for a member
N * of the queue set to be ready for a successful queue read or semaphore take
N * operation.
N *
N * @return xQueueSelectFromSet() will return the handle of a queue (cast to
N * a QueueSetMemberHandle_t type) contained in the queue set that contains data,
N * or the handle of a semaphore (cast to a QueueSetMemberHandle_t type) contained
N * in the queue set that is available, or NULL if no such queue or semaphore
N * exists before before the specified block time expires.
N */
NQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, const TickType_t xTicksToWait ) ;
N
N/*
N * A version of xQueueSelectFromSet() that can be used from an ISR.
N */
NQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) PRIVILEGED_FUNCTION;
XQueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet ) ;
N
N/* Not public API functions. */
Nvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) PRIVILEGED_FUNCTION;
Xvoid vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely ) ;
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) PRIVILEGED_FUNCTION;
XBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue ) ;
Nvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) PRIVILEGED_FUNCTION;
Xvoid vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber ) ;
NUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
XUBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue ) ;
Nuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) PRIVILEGED_FUNCTION;
Xuint8_t ucQueueGetQueueType( QueueHandle_t xQueue ) ;
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* QUEUE_H */
N
L 39 "Common\CMSIS-FreeRTOS\10.0.1\Source\queue.c" 2
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S	#include "croutine.h"
N#endif
N
N/* Lint e961 and e750 are suppressed as a MISRA exception justified because the
NMPU ports require MPU_WRAPPERS_INCLUDED_FROM_API_FILE to be defined for the
Nheader files above, but not in this file, in order to generate the correct
Nprivileged Vs unprivileged linkage and placement. */
N#undef MPU_WRAPPERS_INCLUDED_FROM_API_FILE /*lint !e961 !e750. */
N
N
N/* Constants used with the cRxLock and cTxLock structure members. */
N#define queueUNLOCKED					( ( int8_t ) -1 )
N#define queueLOCKED_UNMODIFIED			( ( int8_t ) 0 )
N
N/* When the Queue_t structure is used to represent a base queue its pcHead and
NpcTail members are used as pointers into the queue storage area.  When the
NQueue_t structure is used to represent a mutex pcHead and pcTail pointers are
Nnot necessary, and the pcHead pointer is set to NULL to indicate that the
NpcTail pointer actually points to the mutex holder (if any).  Map alternative
Nnames to the pcHead and pcTail structure members to ensure the readability of
Nthe code is maintained despite this dual use of two structure members.  An
Nalternative implementation would be to use a union, but use of a union is
Nagainst the coding standard (although an exception to the standard has been
Npermitted where the dual use also significantly changes the type of the
Nstructure member). */
N#define pxMutexHolder					pcTail
N#define uxQueueType						pcHead
N#define queueQUEUE_IS_MUTEX				NULL
N
N/* Semaphores do not actually store or copy data, so have an item size of
Nzero. */
N#define queueSEMAPHORE_QUEUE_ITEM_LENGTH ( ( UBaseType_t ) 0 )
N#define queueMUTEX_GIVE_BLOCK_TIME		 ( ( TickType_t ) 0U )
N
N#if( configUSE_PREEMPTION == 0 )
X#if( 1 == 0 )
S	/* If the cooperative scheduler is being used then a yield should not be
S	performed just because a higher priority task has been woken. */
S	#define queueYIELD_IF_USING_PREEMPTION()
N#else
N	#define queueYIELD_IF_USING_PREEMPTION() portYIELD_WITHIN_API()
N#endif
N
N/*
N * Definition of the queue used by the scheduler.
N * Items are queued by copy, not reference.  See the following link for the
N * rationale: http://www.freertos.org/Embedded-RTOS-Queues.html
N */
Ntypedef struct QueueDefinition
N{
N	int8_t *pcHead;					/*< Points to the beginning of the queue storage area. */
N	int8_t *pcTail;					/*< Points to the byte at the end of the queue storage area.  Once more byte is allocated than necessary to store the queue items, this is used as a marker. */
N	int8_t *pcWriteTo;				/*< Points to the free next place in the storage area. */
N
N	union							/* Use of a union is an exception to the coding standard to ensure two mutually exclusive structure members don't appear simultaneously (wasting RAM). */
N	{
N		int8_t *pcReadFrom;			/*< Points to the last place that a queued item was read from when the structure is used as a queue. */
N		UBaseType_t uxRecursiveCallCount;/*< Maintains a count of the number of times a recursive mutex has been recursively 'taken' when the structure is used as a mutex. */
N	} u;
N
N	List_t xTasksWaitingToSend;		/*< List of tasks that are blocked waiting to post onto this queue.  Stored in priority order. */
N	List_t xTasksWaitingToReceive;	/*< List of tasks that are blocked waiting to read from this queue.  Stored in priority order. */
N
N	volatile UBaseType_t uxMessagesWaiting;/*< The number of items currently in the queue. */
N	UBaseType_t uxLength;			/*< The length of the queue defined as the number of items it will hold, not the number of bytes. */
N	UBaseType_t uxItemSize;			/*< The size of each items that the queue will hold. */
N
N	volatile int8_t cRxLock;		/*< Stores the number of items received from the queue (removed from the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
N	volatile int8_t cTxLock;		/*< Stores the number of items transmitted to the queue (added to the queue) while the queue was locked.  Set to queueUNLOCKED when the queue is not locked. */
N
N	#if( ( configSUPPORT_STATIC_ALLOCATION == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X	#if( ( 1 == 1 ) && ( 1 == 1 ) )
N		uint8_t ucStaticallyAllocated;	/*< Set to pdTRUE if the memory used by the queue was statically allocated to ensure no attempt is made to free the memory. */
N	#endif
N
N	#if ( configUSE_QUEUE_SETS == 1 )
X	#if ( 0 == 1 )
S		struct QueueDefinition *pxQueueSetContainer;
N	#endif
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S		UBaseType_t uxQueueNumber;
S		uint8_t ucQueueType;
N	#endif
N
N} xQUEUE;
N
N/* The old xQUEUE name is maintained above then typedefed to the new Queue_t
Nname below to enable the use of older kernel aware debuggers. */
Ntypedef xQUEUE Queue_t;
N
N/*-----------------------------------------------------------*/
N
N/*
N * The queue registry is just a means for kernel aware debuggers to locate
N * queue structures.  It has no other purpose so is an optional component.
N */
N#if ( configQUEUE_REGISTRY_SIZE > 0 )
X#if ( 0 > 0 )
S
S	/* The type stored within the queue registry array.  This allows a name
S	to be assigned to each queue making kernel aware debugging a little
S	more user friendly. */
S	typedef struct QUEUE_REGISTRY_ITEM
S	{
S		const char *pcQueueName; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
S		QueueHandle_t xHandle;
S	} xQueueRegistryItem;
S
S	/* The old xQueueRegistryItem name is maintained above then typedefed to the
S	new xQueueRegistryItem name below to enable the use of older kernel aware
S	debuggers. */
S	typedef xQueueRegistryItem QueueRegistryItem_t;
S
S	/* The queue registry is simply an array of QueueRegistryItem_t structures.
S	The pcQueueName member of a structure being NULL is indicative of the
S	array position being vacant. */
S	PRIVILEGED_DATA QueueRegistryItem_t xQueueRegistry[ configQUEUE_REGISTRY_SIZE ];
S
N#endif /* configQUEUE_REGISTRY_SIZE */
N
N/*
N * Unlocks a queue locked by a call to prvLockQueue.  Locking a queue does not
N * prevent an ISR from adding or removing items to the queue, but does prevent
N * an ISR from removing tasks from the queue event lists.  If an ISR finds a
N * queue is locked it will instead increment the appropriate queue lock count
N * to indicate that a task may require unblocking.  When the queue in unlocked
N * these lock counts are inspected, and the appropriate action taken.
N */
Nstatic void prvUnlockQueue( Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
Xstatic void prvUnlockQueue( Queue_t * const pxQueue ) ;
N
N/*
N * Uses a critical section to determine if there is any data in a queue.
N *
N * @return pdTRUE if the queue contains no items, otherwise pdFALSE.
N */
Nstatic BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
Xstatic BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue ) ;
N
N/*
N * Uses a critical section to determine if there is any space in a queue.
N *
N * @return pdTRUE if there is no space, otherwise pdFALSE;
N */
Nstatic BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) PRIVILEGED_FUNCTION;
Xstatic BaseType_t prvIsQueueFull( const Queue_t *pxQueue ) ;
N
N/*
N * Copies an item into the queue, either at the front of the queue or the
N * back of the queue.
N */
Nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) PRIVILEGED_FUNCTION;
Xstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition ) ;
N
N/*
N * Copies an item out of a queue.
N */
Nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) PRIVILEGED_FUNCTION;
Xstatic void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer ) ;
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S	/*
S	 * Checks to see if a queue is a member of a queue set, and if so, notifies
S	 * the queue set that the queue contains data.
S	 */
S	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition ) PRIVILEGED_FUNCTION;
N#endif
N
N/*
N * Called after a Queue_t structure has been allocated either statically or
N * dynamically to fill in the structure's members.
N */
Nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
Xstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue ) ;
N
N/*
N * Mutexes are a special type of queue.  When a mutex is created, first the
N * queue is created, then prvInitialiseMutex() is called to configure the queue
N * as a mutex.
N */
N#if( configUSE_MUTEXES == 1 )
X#if( 1 == 1 )
N	static void prvInitialiseMutex( Queue_t *pxNewQueue ) PRIVILEGED_FUNCTION;
X	static void prvInitialiseMutex( Queue_t *pxNewQueue ) ;
N#endif
N
N#if( configUSE_MUTEXES == 1 )
X#if( 1 == 1 )
N	/*
N	 * If a task waiting for a mutex causes the mutex holder to inherit a
N	 * priority, but the waiting task times out, then the holder should
N	 * disinherit the priority - but only down to the highest priority of any
N	 * other tasks that are waiting for the same mutex.  This function returns
N	 * that priority.
N	 */
N	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) PRIVILEGED_FUNCTION;
X	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue ) ;
N#endif
N/*-----------------------------------------------------------*/
N
N/*
N * Macro to mark a queue as locked.  Locking a queue prevents an ISR from
N * accessing the queue event lists.
N */
N#define prvLockQueue( pxQueue )								\
N	taskENTER_CRITICAL();									\
N	{														\
N		if( ( pxQueue )->cRxLock == queueUNLOCKED )			\
N		{													\
N			( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;	\
N		}													\
N		if( ( pxQueue )->cTxLock == queueUNLOCKED )			\
N		{													\
N			( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;	\
N		}													\
N	}														\
N	taskEXIT_CRITICAL()
X#define prvLockQueue( pxQueue )									taskENTER_CRITICAL();										{																if( ( pxQueue )->cRxLock == queueUNLOCKED )					{																( pxQueue )->cRxLock = queueLOCKED_UNMODIFIED;			}															if( ( pxQueue )->cTxLock == queueUNLOCKED )					{																( pxQueue )->cTxLock = queueLOCKED_UNMODIFIED;			}														}															taskEXIT_CRITICAL()
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
N{
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	configASSERT( pxQueue );
X	;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
N		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
N		pxQueue->pcWriteTo = pxQueue->pcHead;
N		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
N		pxQueue->cRxLock = queueUNLOCKED;
X		pxQueue->cRxLock = ( ( int8_t ) -1 );
N		pxQueue->cTxLock = queueUNLOCKED;
X		pxQueue->cTxLock = ( ( int8_t ) -1 );
N
N		if( xNewQueue == pdFALSE )
X		if( xNewQueue == ( ( BaseType_t ) 0 ) )
N		{
N			/* If there are tasks blocked waiting to read from the queue, then
N			the tasks will remain blocked as after this function exits the queue
N			will still be empty.  If there are tasks blocked waiting to write to
N			the queue, then one should be unblocked as after this function exits
N			it will be possible to write to it. */
N			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X			if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N			{
N				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
X				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( ( BaseType_t ) 0 ) )
N				{
N					queueYIELD_IF_USING_PREEMPTION();
X					vPortYield();
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		else
N		{
N			/* Ensure the event queues start in the correct state. */
N			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
N			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
N		}
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	/* A value is returned for calling semantic consistency with previous
N	versions. */
N	return pdPASS;
X	return ( ( ( BaseType_t ) 1 ) );
N}
N/*-----------------------------------------------------------*/
N
N#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N
N	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
N	{
N	Queue_t *pxNewQueue;
N
N		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
X		;
N
N		/* The StaticQueue_t structure and the queue storage area must be
N		supplied. */
N		configASSERT( pxStaticQueue != NULL );
X		;
N
N		/* A queue storage area should be provided if the item size is not 0, and
N		should not be provided if the item size is 0. */
N		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
X		;
N		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
X		;
N
N		#if( configASSERT_DEFINED == 1 )
X		#if( 0 == 1 )
S		{
S			/* Sanity check that the size of the structure used to declare a
S			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
S			the real queue and semaphore structures. */
S			volatile size_t xSize = sizeof( StaticQueue_t );
S			configASSERT( xSize == sizeof( Queue_t ) );
S		}
N		#endif /* configASSERT_DEFINED */
N
N		/* The address of a statically allocated queue was passed in, use it.
N		The address of a statically allocated storage area was also passed in
N		but is already set. */
N		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
N
N		if( pxNewQueue != NULL )
X		if( pxNewQueue != 0 )
N		{
N			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X			#if( 1 == 1 )
N			{
N				/* Queues can be allocated wither statically or dynamically, so
N				note this queue was allocated statically in case the queue is
N				later deleted. */
N				pxNewQueue->ucStaticallyAllocated = pdTRUE;
X				pxNewQueue->ucStaticallyAllocated = ( ( BaseType_t ) 1 );
N			}
N			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
N
N			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
N		}
N		else
N		{
N			traceQUEUE_CREATE_FAILED( ucQueueType );
X			;
N		}
N
N		return pxNewQueue;
N	}
N
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N/*-----------------------------------------------------------*/
N
N#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
X#if( 1 == 1 )
N
N	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
N	{
N	Queue_t *pxNewQueue;
N	size_t xQueueSizeInBytes;
N	uint8_t *pucQueueStorage;
N
N		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
X		;
N
N		if( uxItemSize == ( UBaseType_t ) 0 )
N		{
N			/* There is not going to be a queue storage area. */
N			xQueueSizeInBytes = ( size_t ) 0;
N		}
N		else
N		{
N			/* Allocate enough space to hold the maximum number of items that
N			can be in the queue at any time. */
N			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
N		}
N
N		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
N
N		if( pxNewQueue != NULL )
X		if( pxNewQueue != 0 )
N		{
N			/* Jump past the queue structure to find the location of the queue
N			storage area. */
N			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
N
N			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
X			#if( 1 == 1 )
N			{
N				/* Queues can be created either statically or dynamically, so
N				note this task was created dynamically in case it is later
N				deleted. */
N				pxNewQueue->ucStaticallyAllocated = pdFALSE;
X				pxNewQueue->ucStaticallyAllocated = ( ( BaseType_t ) 0 );
N			}
N			#endif /* configSUPPORT_STATIC_ALLOCATION */
N
N			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
N		}
N		else
N		{
N			traceQUEUE_CREATE_FAILED( ucQueueType );
X			;
N		}
N
N		return pxNewQueue;
N	}
N
N#endif /* configSUPPORT_STATIC_ALLOCATION */
N/*-----------------------------------------------------------*/
N
Nstatic void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
N{
N	/* Remove compiler warnings about unused parameters should
N	configUSE_TRACE_FACILITY not be set to 1. */
N	( void ) ucQueueType;
N
N	if( uxItemSize == ( UBaseType_t ) 0 )
N	{
N		/* No RAM was allocated for the queue storage area, but PC head cannot
N		be set to NULL because NULL is used as a key to say the queue is used as
N		a mutex.  Therefore just set pcHead to point to the queue as a benign
N		value that is known to be within the memory map. */
N		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
N	}
N	else
N	{
N		/* Set the head to the start of the queue storage area. */
N		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
N	}
N
N	/* Initialise the queue members as described where the queue type is
N	defined. */
N	pxNewQueue->uxLength = uxQueueLength;
N	pxNewQueue->uxItemSize = uxItemSize;
N	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
X	( void ) xQueueGenericReset( pxNewQueue, ( ( BaseType_t ) 1 ) );
N
N	#if ( configUSE_TRACE_FACILITY == 1 )
X	#if ( 0 == 1 )
S	{
S		pxNewQueue->ucQueueType = ucQueueType;
S	}
N	#endif /* configUSE_TRACE_FACILITY */
N
N	#if( configUSE_QUEUE_SETS == 1 )
X	#if( 0 == 1 )
S	{
S		pxNewQueue->pxQueueSetContainer = NULL;
S	}
N	#endif /* configUSE_QUEUE_SETS */
N
N	traceQUEUE_CREATE( pxNewQueue );
X	;
N}
N/*-----------------------------------------------------------*/
N
N#if( configUSE_MUTEXES == 1 )
X#if( 1 == 1 )
N
N	static void prvInitialiseMutex( Queue_t *pxNewQueue )
N	{
N		if( pxNewQueue != NULL )
X		if( pxNewQueue != 0 )
N		{
N			/* The queue create function will set all the queue structure members
N			correctly for a generic queue, but this function is creating a
N			mutex.  Overwrite those members that need to be set differently -
N			in particular the information required for priority inheritance. */
N			pxNewQueue->pxMutexHolder = NULL;
X			pxNewQueue->pcTail = 0;
N			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
X			pxNewQueue->pcHead = 0;
N
N			/* In case this is a recursive mutex. */
N			pxNewQueue->u.uxRecursiveCallCount = 0;
N
N			traceCREATE_MUTEX( pxNewQueue );
X			;
N
N			/* Start with the semaphore in the expected state. */
N			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
X			( void ) xQueueGenericSend( pxNewQueue, 0, ( TickType_t ) 0U, ( ( BaseType_t ) 0 ) );
N		}
N		else
N		{
N			traceCREATE_MUTEX_FAILED();
X			;
N		}
N	}
N
N#endif /* configUSE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X#if( ( 1 == 1 ) && ( 1 == 1 ) )
N
N	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
N	{
N	Queue_t *pxNewQueue;
N	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
N
N		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
N		prvInitialiseMutex( pxNewQueue );
N
N		return pxNewQueue;
N	}
N
N#endif /* configUSE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if( ( configUSE_MUTEXES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
X#if( ( 1 == 1 ) && ( 1 == 1 ) )
N
N	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
N	{
N	Queue_t *pxNewQueue;
N	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
N
N		/* Prevent compiler warnings about unused parameters if
N		configUSE_TRACE_FACILITY does not equal 1. */
N		( void ) ucQueueType;
N
N		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
X		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, 0, pxStaticQueue, ucQueueType );
N		prvInitialiseMutex( pxNewQueue );
N
N		return pxNewQueue;
N	}
N
N#endif /* configUSE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
X#if ( ( 1 == 1 ) && ( 1 == 1 ) )
N
N	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
N	{
N	void *pxReturn;
N
N		/* This function is called by xSemaphoreGetMutexHolder(), and should not
N		be called directly.  Note:  This is a good way of determining if the
N		calling task is the mutex holder, but not a good way of determining the
N		identity of the mutex holder, as the holder may change between the
N		following critical section exiting and the function returning. */
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
X			if( ( ( Queue_t * ) xSemaphore )->pcHead == 0 )
N			{
N				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
X				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pcTail;
N			}
N			else
N			{
N				pxReturn = NULL;
X				pxReturn = 0;
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		return pxReturn;
N	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
N
N#endif
N/*-----------------------------------------------------------*/
N
N#if ( ( configUSE_MUTEXES == 1 ) && ( INCLUDE_xSemaphoreGetMutexHolder == 1 ) )
X#if ( ( 1 == 1 ) && ( 1 == 1 ) )
N
N	void* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
N	{
N	void *pxReturn;
N
N		configASSERT( xSemaphore );
X		;
N
N		/* Mutexes cannot be used in interrupt service routines, so the mutex
N		holder should not change in an ISR, and therefore a critical section is
N		not required here. */
N		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
X		if( ( ( Queue_t * ) xSemaphore )->pcHead == 0 )
N		{
N			pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
X			pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pcTail;
N		}
N		else
N		{
N			pxReturn = NULL;
X			pxReturn = 0;
N		}
N
N		return pxReturn;
N	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
N
N#endif
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_RECURSIVE_MUTEXES == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xQueueGiveMutexRecursive( QueueHandle_t xMutex )
S	{
S	BaseType_t xReturn;
S	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
S
S		configASSERT( pxMutex );
S
S		/* If this is the task that holds the mutex then pxMutexHolder will not
S		change outside of this task.  If this task does not hold the mutex then
S		pxMutexHolder can never coincidentally equal the tasks handle, and as
S		this is the only condition we are interested in it does not matter if
S		pxMutexHolder is accessed simultaneously by another task.  Therefore no
S		mutual exclusion is required to test the pxMutexHolder variable. */
S		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Not a redundant cast as TaskHandle_t is a typedef. */
S		{
S			traceGIVE_MUTEX_RECURSIVE( pxMutex );
S
S			/* uxRecursiveCallCount cannot be zero if pxMutexHolder is equal to
S			the task handle, therefore no underflow check is required.  Also,
S			uxRecursiveCallCount is only modified by the mutex holder, and as
S			there can only be one, no mutual exclusion is required to modify the
S			uxRecursiveCallCount member. */
S			( pxMutex->u.uxRecursiveCallCount )--;
S
S			/* Has the recursive call count unwound to 0? */
S			if( pxMutex->u.uxRecursiveCallCount == ( UBaseType_t ) 0 )
S			{
S				/* Return the mutex.  This will automatically unblock any other
S				task that might be waiting to access the mutex. */
S				( void ) xQueueGenericSend( pxMutex, NULL, queueMUTEX_GIVE_BLOCK_TIME, queueSEND_TO_BACK );
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S
S			xReturn = pdPASS;
S		}
S		else
S		{
S			/* The mutex cannot be given because the calling task is not the
S			holder. */
S			xReturn = pdFAIL;
S
S			traceGIVE_MUTEX_RECURSIVE_FAILED( pxMutex );
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_RECURSIVE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_RECURSIVE_MUTEXES == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xQueueTakeMutexRecursive( QueueHandle_t xMutex, TickType_t xTicksToWait )
S	{
S	BaseType_t xReturn;
S	Queue_t * const pxMutex = ( Queue_t * ) xMutex;
S
S		configASSERT( pxMutex );
S
S		/* Comments regarding mutual exclusion as per those within
S		xQueueGiveMutexRecursive(). */
S
S		traceTAKE_MUTEX_RECURSIVE( pxMutex );
S
S		if( pxMutex->pxMutexHolder == ( void * ) xTaskGetCurrentTaskHandle() ) /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
S		{
S			( pxMutex->u.uxRecursiveCallCount )++;
S			xReturn = pdPASS;
S		}
S		else
S		{
S			xReturn = xQueueSemaphoreTake( pxMutex, xTicksToWait );
S
S			/* pdPASS will only be returned if the mutex was successfully
S			obtained.  The calling task may have entered the Blocked state
S			before reaching here. */
S			if( xReturn != pdFAIL )
S			{
S				( pxMutex->u.uxRecursiveCallCount )++;
S			}
S			else
S			{
S				traceTAKE_MUTEX_RECURSIVE_FAILED( pxMutex );
S			}
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_RECURSIVE_MUTEXES */
N/*-----------------------------------------------------------*/
N
N#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
X#if( ( 1 == 1 ) && ( 1 == 1 ) )
N
N	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
N	{
N	QueueHandle_t xHandle;
N
N		configASSERT( uxMaxCount != 0 );
X		;
N		configASSERT( uxInitialCount <= uxMaxCount );
X		;
N
N		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
X		xHandle = xQueueGenericCreateStatic( uxMaxCount, ( ( UBaseType_t ) 0 ), 0, pxStaticQueue, ( ( uint8_t ) 2U ) );
N
N		if( xHandle != NULL )
X		if( xHandle != 0 )
N		{
N			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
N
N			traceCREATE_COUNTING_SEMAPHORE();
X			;
N		}
N		else
N		{
N			traceCREATE_COUNTING_SEMAPHORE_FAILED();
X			;
N		}
N
N		return xHandle;
N	}
N
N#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
N/*-----------------------------------------------------------*/
N
N#if( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X#if( ( 1 == 1 ) && ( 1 == 1 ) )
N
N	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
N	{
N	QueueHandle_t xHandle;
N
N		configASSERT( uxMaxCount != 0 );
X		;
N		configASSERT( uxInitialCount <= uxMaxCount );
X		;
N
N		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
X		xHandle = xQueueGenericCreate( uxMaxCount, ( ( UBaseType_t ) 0 ), ( ( uint8_t ) 2U ) );
N
N		if( xHandle != NULL )
X		if( xHandle != 0 )
N		{
N			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
N
N			traceCREATE_COUNTING_SEMAPHORE();
X			;
N		}
N		else
N		{
N			traceCREATE_COUNTING_SEMAPHORE_FAILED();
X			;
N		}
N
N		return xHandle;
N	}
N
N#endif /* ( ( configUSE_COUNTING_SEMAPHORES == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) ) */
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
N{
NBaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
XBaseType_t xEntryTimeSet = ( ( BaseType_t ) 0 ), xYieldRequired;
NTimeOut_t xTimeOut;
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	configASSERT( pxQueue );
X	;
N	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
X	;
N	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
X	;
N	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
X	#if ( ( 1 == 1 ) || ( 0 == 1 ) )
N	{
N		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
X		;
N	}
N	#endif
N
N
N	/* This function relaxes the coding standard somewhat to allow return
N	statements within the function itself.  This is done in the interest
N	of execution time efficiency. */
N	for( ;; )
N	{
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* Is there room on the queue now?  The running task must be the
N			highest priority task wanting to access the queue.  If the head item
N			in the queue is to be overwritten then it does not matter if the
N			queue is full. */
N			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
X			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == ( ( BaseType_t ) 2 ) ) )
N			{
N				traceQUEUE_SEND( pxQueue );
X				;
N				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
N
N				#if ( configUSE_QUEUE_SETS == 1 )
X				#if ( 0 == 1 )
S				{
S					if( pxQueue->pxQueueSetContainer != NULL )
S					{
S						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
S						{
S							/* The queue is a member of a queue set, and posting
S							to the queue set caused a higher priority task to
S							unblock. A context switch is required. */
S							queueYIELD_IF_USING_PREEMPTION();
S						}
S						else
S						{
S							mtCOVERAGE_TEST_MARKER();
S						}
S					}
S					else
S					{
S						/* If there was a task waiting for data to arrive on the
S						queue then unblock it now. */
S						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S						{
S							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S							{
S								/* The unblocked task has a priority higher than
S								our own so yield immediately.  Yes it is ok to
S								do this from within the critical section - the
S								kernel takes care of that. */
S								queueYIELD_IF_USING_PREEMPTION();
S							}
S							else
S							{
S								mtCOVERAGE_TEST_MARKER();
S							}
S						}
S						else if( xYieldRequired != pdFALSE )
S						{
S							/* This path is a special case that will only get
S							executed if the task was holding multiple mutexes
S							and the mutexes were given back in an order that is
S							different to that in which they were taken. */
S							queueYIELD_IF_USING_PREEMPTION();
S						}
S						else
S						{
S							mtCOVERAGE_TEST_MARKER();
S						}
S					}
S				}
N				#else /* configUSE_QUEUE_SETS */
N				{
N					/* If there was a task waiting for data to arrive on the
N					queue then unblock it now. */
N					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X					if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N					{
N						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
X						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( ( BaseType_t ) 0 ) )
N						{
N							/* The unblocked task has a priority higher than
N							our own so yield immediately.  Yes it is ok to do
N							this from within the critical section - the kernel
N							takes care of that. */
N							queueYIELD_IF_USING_PREEMPTION();
X							vPortYield();
N						}
N						else
N						{
N							mtCOVERAGE_TEST_MARKER();
X							;
N						}
N					}
N					else if( xYieldRequired != pdFALSE )
X					else if( xYieldRequired != ( ( BaseType_t ) 0 ) )
N					{
N						/* This path is a special case that will only get
N						executed if the task was holding multiple mutexes and
N						the mutexes were given back in an order that is
N						different to that in which they were taken. */
N						queueYIELD_IF_USING_PREEMPTION();
X						vPortYield();
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				#endif /* configUSE_QUEUE_SETS */
N
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N				return pdPASS;
X				return ( ( ( BaseType_t ) 1 ) );
N			}
N			else
N			{
N				if( xTicksToWait == ( TickType_t ) 0 )
N				{
N					/* The queue was full and no block time is specified (or
N					the block time has expired) so leave now. */
N					taskEXIT_CRITICAL();
X					vPortExitCritical();
N
N					/* Return to the original privilege level before exiting
N					the function. */
N					traceQUEUE_SEND_FAILED( pxQueue );
X					;
N					return errQUEUE_FULL;
X					return ( ( BaseType_t ) 0 );
N				}
N				else if( xEntryTimeSet == pdFALSE )
X				else if( xEntryTimeSet == ( ( BaseType_t ) 0 ) )
N				{
N					/* The queue was full and a block time was specified so
N					configure the timeout structure. */
N					vTaskInternalSetTimeOutState( &xTimeOut );
N					xEntryTimeSet = pdTRUE;
X					xEntryTimeSet = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					/* Entry time was already set. */
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		/* Interrupts and other tasks can send to and receive from the queue
N		now the critical section has been exited. */
N
N		vTaskSuspendAll();
N		prvLockQueue( pxQueue );
X		vPortEnterCritical(); { if( ( pxQueue )->cRxLock == ( ( int8_t ) -1 ) ) { ( pxQueue )->cRxLock = ( ( int8_t ) 0 ); } if( ( pxQueue )->cTxLock == ( ( int8_t ) -1 ) ) { ( pxQueue )->cTxLock = ( ( int8_t ) 0 ); } } vPortExitCritical();
N
N		/* Update the timeout state to see if it has expired yet. */
N		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
X		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == ( ( BaseType_t ) 0 ) )
N		{
N			if( prvIsQueueFull( pxQueue ) != pdFALSE )
X			if( prvIsQueueFull( pxQueue ) != ( ( BaseType_t ) 0 ) )
N			{
N				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
X				;
N				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
N
N				/* Unlocking the queue means queue events can effect the
N				event list.  It is possible that interrupts occurring now
N				remove this task from the event list again - but as the
N				scheduler is suspended the task will go onto the pending
N				ready last instead of the actual ready list. */
N				prvUnlockQueue( pxQueue );
N
N				/* Resuming the scheduler will move tasks from the pending
N				ready list into the ready list - so it is feasible that this
N				task is already in a ready list before it yields - in which
N				case the yield will not cause a context switch unless there
N				is also a higher priority task in the pending ready list. */
N				if( xTaskResumeAll() == pdFALSE )
X				if( xTaskResumeAll() == ( ( BaseType_t ) 0 ) )
N				{
N					portYIELD_WITHIN_API();
X					vPortYield();
N				}
N			}
N			else
N			{
N				/* Try again. */
N				prvUnlockQueue( pxQueue );
N				( void ) xTaskResumeAll();
N			}
N		}
N		else
N		{
N			/* The timeout has expired. */
N			prvUnlockQueue( pxQueue );
N			( void ) xTaskResumeAll();
N
N			traceQUEUE_SEND_FAILED( pxQueue );
X			;
N			return errQUEUE_FULL;
X			return ( ( BaseType_t ) 0 );
N		}
N	}
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
N{
NBaseType_t xReturn;
NUBaseType_t uxSavedInterruptStatus;
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	configASSERT( pxQueue );
X	;
N	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
X	;
N	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
X	;
N
N	/* RTOS ports that support interrupt nesting have the concept of a maximum
N	system call (or maximum API call) interrupt priority.  Interrupts that are
N	above the maximum system call priority are kept permanently enabled, even
N	when the RTOS kernel is in a critical section, but cannot make any calls to
N	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
N	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N	failure if a FreeRTOS API function is called from an interrupt that has been
N	assigned a priority above the configured maximum system call priority.
N	Only FreeRTOS functions that end in FromISR can be called from interrupts
N	that have been assigned a priority at or (logically) below the maximum
N	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
N	safe API to ensure interrupt entry is as fast and as simple as possible.
N	More information (albeit Cortex-M specific) is provided on the following
N	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X	;
N
N	/* Similar to xQueueGenericSend, except without blocking if there is no room
N	in the queue.  Also don't directly wake a task that was blocked on a queue
N	read, instead return a flag to say whether a context switch is required or
N	not (i.e. has a task with a higher priority than us been woken by this
N	post). */
N	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X	uxSavedInterruptStatus = ulSetInterruptMaskFromISR();
N	{
N		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
X		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == ( ( BaseType_t ) 2 ) ) )
N		{
N			const int8_t cTxLock = pxQueue->cTxLock;
N
N			traceQUEUE_SEND_FROM_ISR( pxQueue );
X			;
N
N			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
N			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
N			in a task disinheriting a priority and prvCopyDataToQueue() can be
N			called here even though the disinherit function does not check if
N			the scheduler is suspended before accessing the ready lists. */
N			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
N
N			/* The event list is not altered if the queue is locked.  This will
N			be done when the queue is unlocked later. */
N			if( cTxLock == queueUNLOCKED )
X			if( cTxLock == ( ( int8_t ) -1 ) )
N			{
N				#if ( configUSE_QUEUE_SETS == 1 )
X				#if ( 0 == 1 )
S				{
S					if( pxQueue->pxQueueSetContainer != NULL )
S					{
S						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
S						{
S							/* The queue is a member of a queue set, and posting
S							to the queue set caused a higher priority task to
S							unblock.  A context switch is required. */
S							if( pxHigherPriorityTaskWoken != NULL )
S							{
S								*pxHigherPriorityTaskWoken = pdTRUE;
S							}
S							else
S							{
S								mtCOVERAGE_TEST_MARKER();
S							}
S						}
S						else
S						{
S							mtCOVERAGE_TEST_MARKER();
S						}
S					}
S					else
S					{
S						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S						{
S							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S							{
S								/* The task waiting has a higher priority so
S								record that a context switch is required. */
S								if( pxHigherPriorityTaskWoken != NULL )
S								{
S									*pxHigherPriorityTaskWoken = pdTRUE;
S								}
S								else
S								{
S									mtCOVERAGE_TEST_MARKER();
S								}
S							}
S							else
S							{
S								mtCOVERAGE_TEST_MARKER();
S							}
S						}
S						else
S						{
S							mtCOVERAGE_TEST_MARKER();
S						}
S					}
S				}
N				#else /* configUSE_QUEUE_SETS */
N				{
N					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X					if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N					{
N						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
X						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( ( BaseType_t ) 0 ) )
N						{
N							/* The task waiting has a higher priority so record that a
N							context	switch is required. */
N							if( pxHigherPriorityTaskWoken != NULL )
X							if( pxHigherPriorityTaskWoken != 0 )
N							{
N								*pxHigherPriorityTaskWoken = pdTRUE;
X								*pxHigherPriorityTaskWoken = ( ( BaseType_t ) 1 );
N							}
N							else
N							{
N								mtCOVERAGE_TEST_MARKER();
X								;
N							}
N						}
N						else
N						{
N							mtCOVERAGE_TEST_MARKER();
X							;
N						}
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				#endif /* configUSE_QUEUE_SETS */
N			}
N			else
N			{
N				/* Increment the lock count so the task that unlocks the queue
N				knows that data was posted while it was locked. */
N				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
N			}
N
N			xReturn = pdPASS;
X			xReturn = ( ( ( BaseType_t ) 1 ) );
N		}
N		else
N		{
N			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
X			;
N			xReturn = errQUEUE_FULL;
X			xReturn = ( ( BaseType_t ) 0 );
N		}
N	}
N	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X	vClearInterruptMaskFromISR( uxSavedInterruptStatus );
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
N{
NBaseType_t xReturn;
NUBaseType_t uxSavedInterruptStatus;
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
N	item size is 0.  Don't directly wake a task that was blocked on a queue
N	read, instead return a flag to say whether a context switch is required or
N	not (i.e. has a task with a higher priority than us been woken by this
N	post). */
N
N	configASSERT( pxQueue );
X	;
N
N	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
N	if the item size is not 0. */
N	configASSERT( pxQueue->uxItemSize == 0 );
X	;
N
N	/* Normally a mutex would not be given from an interrupt, especially if
N	there is a mutex holder, as priority inheritance makes no sense for an
N	interrupts, only tasks. */
N	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
X	;
N
N	/* RTOS ports that support interrupt nesting have the concept of a maximum
N	system call (or maximum API call) interrupt priority.  Interrupts that are
N	above the maximum system call priority are kept permanently enabled, even
N	when the RTOS kernel is in a critical section, but cannot make any calls to
N	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
N	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N	failure if a FreeRTOS API function is called from an interrupt that has been
N	assigned a priority above the configured maximum system call priority.
N	Only FreeRTOS functions that end in FromISR can be called from interrupts
N	that have been assigned a priority at or (logically) below the maximum
N	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
N	safe API to ensure interrupt entry is as fast and as simple as possible.
N	More information (albeit Cortex-M specific) is provided on the following
N	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X	;
N
N	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X	uxSavedInterruptStatus = ulSetInterruptMaskFromISR();
N	{
N		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
N
N		/* When the queue is used to implement a semaphore no data is ever
N		moved through the queue but it is still valid to see if the queue 'has
N		space'. */
N		if( uxMessagesWaiting < pxQueue->uxLength )
N		{
N			const int8_t cTxLock = pxQueue->cTxLock;
N
N			traceQUEUE_SEND_FROM_ISR( pxQueue );
X			;
N
N			/* A task can only have an inherited priority if it is a mutex
N			holder - and if there is a mutex holder then the mutex cannot be
N			given from an ISR.  As this is the ISR version of the function it
N			can be assumed there is no mutex holder and no need to determine if
N			priority disinheritance is needed.  Simply increase the count of
N			messages (semaphores) available. */
N			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
N
N			/* The event list is not altered if the queue is locked.  This will
N			be done when the queue is unlocked later. */
N			if( cTxLock == queueUNLOCKED )
X			if( cTxLock == ( ( int8_t ) -1 ) )
N			{
N				#if ( configUSE_QUEUE_SETS == 1 )
X				#if ( 0 == 1 )
S				{
S					if( pxQueue->pxQueueSetContainer != NULL )
S					{
S						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
S						{
S							/* The semaphore is a member of a queue set, and
S							posting	to the queue set caused a higher priority
S							task to	unblock.  A context switch is required. */
S							if( pxHigherPriorityTaskWoken != NULL )
S							{
S								*pxHigherPriorityTaskWoken = pdTRUE;
S							}
S							else
S							{
S								mtCOVERAGE_TEST_MARKER();
S							}
S						}
S						else
S						{
S							mtCOVERAGE_TEST_MARKER();
S						}
S					}
S					else
S					{
S						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S						{
S							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S							{
S								/* The task waiting has a higher priority so
S								record that a context switch is required. */
S								if( pxHigherPriorityTaskWoken != NULL )
S								{
S									*pxHigherPriorityTaskWoken = pdTRUE;
S								}
S								else
S								{
S									mtCOVERAGE_TEST_MARKER();
S								}
S							}
S							else
S							{
S								mtCOVERAGE_TEST_MARKER();
S							}
S						}
S						else
S						{
S							mtCOVERAGE_TEST_MARKER();
S						}
S					}
S				}
N				#else /* configUSE_QUEUE_SETS */
N				{
N					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X					if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N					{
N						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
X						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( ( BaseType_t ) 0 ) )
N						{
N							/* The task waiting has a higher priority so record that a
N							context	switch is required. */
N							if( pxHigherPriorityTaskWoken != NULL )
X							if( pxHigherPriorityTaskWoken != 0 )
N							{
N								*pxHigherPriorityTaskWoken = pdTRUE;
X								*pxHigherPriorityTaskWoken = ( ( BaseType_t ) 1 );
N							}
N							else
N							{
N								mtCOVERAGE_TEST_MARKER();
X								;
N							}
N						}
N						else
N						{
N							mtCOVERAGE_TEST_MARKER();
X							;
N						}
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				#endif /* configUSE_QUEUE_SETS */
N			}
N			else
N			{
N				/* Increment the lock count so the task that unlocks the queue
N				knows that data was posted while it was locked. */
N				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
N			}
N
N			xReturn = pdPASS;
X			xReturn = ( ( ( BaseType_t ) 1 ) );
N		}
N		else
N		{
N			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
X			;
N			xReturn = errQUEUE_FULL;
X			xReturn = ( ( BaseType_t ) 0 );
N		}
N	}
N	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X	vClearInterruptMaskFromISR( uxSavedInterruptStatus );
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
N{
NBaseType_t xEntryTimeSet = pdFALSE;
XBaseType_t xEntryTimeSet = ( ( BaseType_t ) 0 );
NTimeOut_t xTimeOut;
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	/* Check the pointer is not NULL. */
N	configASSERT( ( pxQueue ) );
X	;
N
N	/* The buffer into which data is received can only be NULL if the data size
N	is zero (so no data is copied into the buffer. */
N	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
X	;
N
N	/* Cannot block if the scheduler is suspended. */
N	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
X	#if ( ( 1 == 1 ) || ( 0 == 1 ) )
N	{
N		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
X		;
N	}
N	#endif
N
N
N	/* This function relaxes the coding standard somewhat to allow return
N	statements within the function itself.  This is done in the interest
N	of execution time efficiency. */
N
N	for( ;; )
N	{
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
N
N			/* Is there data in the queue now?  To be running the calling task
N			must be the highest priority task wanting to access the queue. */
N			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
N			{
N				/* Data available, remove one item. */
N				prvCopyDataFromQueue( pxQueue, pvBuffer );
N				traceQUEUE_RECEIVE( pxQueue );
X				;
N				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
N
N				/* There is now space in the queue, were any tasks waiting to
N				post to the queue?  If so, unblock the highest priority waiting
N				task. */
N				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X				if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N				{
N					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
X					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( ( BaseType_t ) 0 ) )
N					{
N						queueYIELD_IF_USING_PREEMPTION();
X						vPortYield();
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N				return pdPASS;
X				return ( ( ( BaseType_t ) 1 ) );
N			}
N			else
N			{
N				if( xTicksToWait == ( TickType_t ) 0 )
N				{
N					/* The queue was empty and no block time is specified (or
N					the block time has expired) so leave now. */
N					taskEXIT_CRITICAL();
X					vPortExitCritical();
N					traceQUEUE_RECEIVE_FAILED( pxQueue );
X					;
N					return errQUEUE_EMPTY;
X					return ( ( BaseType_t ) 0 );
N				}
N				else if( xEntryTimeSet == pdFALSE )
X				else if( xEntryTimeSet == ( ( BaseType_t ) 0 ) )
N				{
N					/* The queue was empty and a block time was specified so
N					configure the timeout structure. */
N					vTaskInternalSetTimeOutState( &xTimeOut );
N					xEntryTimeSet = pdTRUE;
X					xEntryTimeSet = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					/* Entry time was already set. */
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		/* Interrupts and other tasks can send to and receive from the queue
N		now the critical section has been exited. */
N
N		vTaskSuspendAll();
N		prvLockQueue( pxQueue );
X		vPortEnterCritical(); { if( ( pxQueue )->cRxLock == ( ( int8_t ) -1 ) ) { ( pxQueue )->cRxLock = ( ( int8_t ) 0 ); } if( ( pxQueue )->cTxLock == ( ( int8_t ) -1 ) ) { ( pxQueue )->cTxLock = ( ( int8_t ) 0 ); } } vPortExitCritical();
N
N		/* Update the timeout state to see if it has expired yet. */
N		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
X		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == ( ( BaseType_t ) 0 ) )
N		{
N			/* The timeout has not expired.  If the queue is still empty place
N			the task on the list of tasks waiting to receive from the queue. */
N			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
X			if( prvIsQueueEmpty( pxQueue ) != ( ( BaseType_t ) 0 ) )
N			{
N				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
X				;
N				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
N				prvUnlockQueue( pxQueue );
N				if( xTaskResumeAll() == pdFALSE )
X				if( xTaskResumeAll() == ( ( BaseType_t ) 0 ) )
N				{
N					portYIELD_WITHIN_API();
X					vPortYield();
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				/* The queue contains data again.  Loop back to try and read the
N				data. */
N				prvUnlockQueue( pxQueue );
N				( void ) xTaskResumeAll();
N			}
N		}
N		else
N		{
N			/* Timed out.  If there is no data in the queue exit, otherwise loop
N			back and attempt to read the data. */
N			prvUnlockQueue( pxQueue );
N			( void ) xTaskResumeAll();
N
N			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
X			if( prvIsQueueEmpty( pxQueue ) != ( ( BaseType_t ) 0 ) )
N			{
N				traceQUEUE_RECEIVE_FAILED( pxQueue );
X				;
N				return errQUEUE_EMPTY;
X				return ( ( BaseType_t ) 0 );
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N	}
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
N{
NBaseType_t xEntryTimeSet = pdFALSE;
XBaseType_t xEntryTimeSet = ( ( BaseType_t ) 0 );
NTimeOut_t xTimeOut;
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N#if( configUSE_MUTEXES == 1 )
X#if( 1 == 1 )
N	BaseType_t xInheritanceOccurred = pdFALSE;
X	BaseType_t xInheritanceOccurred = ( ( BaseType_t ) 0 );
N#endif
N
N	/* Check the queue pointer is not NULL. */
N	configASSERT( ( pxQueue ) );
X	;
N
N	/* Check this really is a semaphore, in which case the item size will be
N	0. */
N	configASSERT( pxQueue->uxItemSize == 0 );
X	;
N
N	/* Cannot block if the scheduler is suspended. */
N	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
X	#if ( ( 1 == 1 ) || ( 0 == 1 ) )
N	{
N		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
X		;
N	}
N	#endif
N
N
N	/* This function relaxes the coding standard somewhat to allow return
N	statements within the function itself.  This is done in the interest
N	of execution time efficiency. */
N
N	for( ;; )
N	{
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			/* Semaphores are queues with an item size of 0, and where the
N			number of messages in the queue is the semaphore's count value. */
N			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
N
N			/* Is there data in the queue now?  To be running the calling task
N			must be the highest priority task wanting to access the queue. */
N			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
N			{
N				traceQUEUE_RECEIVE( pxQueue );
X				;
N
N				/* Semaphores are queues with a data size of zero and where the
N				messages waiting is the semaphore's count.  Reduce the count. */
N				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
N
N				#if ( configUSE_MUTEXES == 1 )
X				#if ( 1 == 1 )
N				{
N					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
X					if( pxQueue->pcHead == 0 )
N					{
N						/* Record the information required to implement
N						priority inheritance should it become necessary. */
N						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
X						pxQueue->pcTail = ( int8_t * ) pvTaskIncrementMutexHeldCount();  
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				#endif /* configUSE_MUTEXES */
N
N				/* Check to see if other tasks are blocked waiting to give the
N				semaphore, and if so, unblock the highest priority such task. */
N				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X				if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N				{
N					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
X					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( ( BaseType_t ) 0 ) )
N					{
N						queueYIELD_IF_USING_PREEMPTION();
X						vPortYield();
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N				return pdPASS;
X				return ( ( ( BaseType_t ) 1 ) );
N			}
N			else
N			{
N				if( xTicksToWait == ( TickType_t ) 0 )
N				{
N					/* For inheritance to have occurred there must have been an
N					initial timeout, and an adjusted timeout cannot become 0, as
N					if it were 0 the function would have exited. */
N					#if( configUSE_MUTEXES == 1 )
X					#if( 1 == 1 )
N					{
N						configASSERT( xInheritanceOccurred == pdFALSE );
X						;
N					}
N					#endif /* configUSE_MUTEXES */
N
N					/* The semaphore count was 0 and no block time is specified
N					(or the block time has expired) so exit now. */
N					taskEXIT_CRITICAL();
X					vPortExitCritical();
N					traceQUEUE_RECEIVE_FAILED( pxQueue );
X					;
N					return errQUEUE_EMPTY;
X					return ( ( BaseType_t ) 0 );
N				}
N				else if( xEntryTimeSet == pdFALSE )
X				else if( xEntryTimeSet == ( ( BaseType_t ) 0 ) )
N				{
N					/* The semaphore count was 0 and a block time was specified
N					so configure the timeout structure ready to block. */
N					vTaskInternalSetTimeOutState( &xTimeOut );
N					xEntryTimeSet = pdTRUE;
X					xEntryTimeSet = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					/* Entry time was already set. */
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		/* Interrupts and other tasks can give to and take from the semaphore
N		now the critical section has been exited. */
N
N		vTaskSuspendAll();
N		prvLockQueue( pxQueue );
X		vPortEnterCritical(); { if( ( pxQueue )->cRxLock == ( ( int8_t ) -1 ) ) { ( pxQueue )->cRxLock = ( ( int8_t ) 0 ); } if( ( pxQueue )->cTxLock == ( ( int8_t ) -1 ) ) { ( pxQueue )->cTxLock = ( ( int8_t ) 0 ); } } vPortExitCritical();
N
N		/* Update the timeout state to see if it has expired yet. */
N		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
X		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == ( ( BaseType_t ) 0 ) )
N		{
N			/* A block time is specified and not expired.  If the semaphore
N			count is 0 then enter the Blocked state to wait for a semaphore to
N			become available.  As semaphores are implemented with queues the
N			queue being empty is equivalent to the semaphore count being 0. */
N			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
X			if( prvIsQueueEmpty( pxQueue ) != ( ( BaseType_t ) 0 ) )
N			{
N				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
X				;
N
N				#if ( configUSE_MUTEXES == 1 )
X				#if ( 1 == 1 )
N				{
N					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
X					if( pxQueue->pcHead == 0 )
N					{
N						taskENTER_CRITICAL();
X						vPortEnterCritical();
N						{
N							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
X							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pcTail );
N						}
N						taskEXIT_CRITICAL();
X						vPortExitCritical();
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				#endif
N
N				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
N				prvUnlockQueue( pxQueue );
N				if( xTaskResumeAll() == pdFALSE )
X				if( xTaskResumeAll() == ( ( BaseType_t ) 0 ) )
N				{
N					portYIELD_WITHIN_API();
X					vPortYield();
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				/* There was no timeout and the semaphore count was not 0, so
N				attempt to take the semaphore again. */
N				prvUnlockQueue( pxQueue );
N				( void ) xTaskResumeAll();
N			}
N		}
N		else
N		{
N			/* Timed out. */
N			prvUnlockQueue( pxQueue );
N			( void ) xTaskResumeAll();
N
N			/* If the semaphore count is 0 exit now as the timeout has
N			expired.  Otherwise return to attempt to take the semaphore that is
N			known to be available.  As semaphores are implemented by queues the
N			queue being empty is equivalent to the semaphore count being 0. */
N			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
X			if( prvIsQueueEmpty( pxQueue ) != ( ( BaseType_t ) 0 ) )
N			{
N				#if ( configUSE_MUTEXES == 1 )
X				#if ( 1 == 1 )
N				{
N					/* xInheritanceOccurred could only have be set if
N					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
N					test the mutex type again to check it is actually a mutex. */
N					if( xInheritanceOccurred != pdFALSE )
X					if( xInheritanceOccurred != ( ( BaseType_t ) 0 ) )
N					{
N						taskENTER_CRITICAL();
X						vPortEnterCritical();
N						{
N							UBaseType_t uxHighestWaitingPriority;
N
N							/* This task blocking on the mutex caused another
N							task to inherit this task's priority.  Now this task
N							has timed out the priority should be disinherited
N							again, but only as low as the next highest priority
N							task that is waiting for the same mutex. */
N							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
N							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
X							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pcTail, uxHighestWaitingPriority );
N						}
N						taskEXIT_CRITICAL();
X						vPortExitCritical();
N					}
N				}
N				#endif /* configUSE_MUTEXES */
N
N				traceQUEUE_RECEIVE_FAILED( pxQueue );
X				;
N				return errQUEUE_EMPTY;
X				return ( ( BaseType_t ) 0 );
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N	}
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
N{
NBaseType_t xEntryTimeSet = pdFALSE;
XBaseType_t xEntryTimeSet = ( ( BaseType_t ) 0 );
NTimeOut_t xTimeOut;
Nint8_t *pcOriginalReadPosition;
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	/* Check the pointer is not NULL. */
N	configASSERT( ( pxQueue ) );
X	;
N
N	/* The buffer into which data is received can only be NULL if the data size
N	is zero (so no data is copied into the buffer. */
N	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
X	;
N
N	/* Cannot block if the scheduler is suspended. */
N	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
X	#if ( ( 1 == 1 ) || ( 0 == 1 ) )
N	{
N		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
X		;
N	}
N	#endif
N
N
N	/* This function relaxes the coding standard somewhat to allow return
N	statements within the function itself.  This is done in the interest
N	of execution time efficiency. */
N
N	for( ;; )
N	{
N		taskENTER_CRITICAL();
X		vPortEnterCritical();
N		{
N			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
N
N			/* Is there data in the queue now?  To be running the calling task
N			must be the highest priority task wanting to access the queue. */
N			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
N			{
N				/* Remember the read position so it can be reset after the data
N				is read from the queue as this function is only peeking the
N				data, not removing it. */
N				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
N
N				prvCopyDataFromQueue( pxQueue, pvBuffer );
N				traceQUEUE_PEEK( pxQueue );
X				;
N
N				/* The data is not being removed, so reset the read pointer. */
N				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
N
N				/* The data is being left in the queue, so see if there are
N				any other tasks waiting for the data. */
N				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X				if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N				{
N					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
X					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( ( BaseType_t ) 0 ) )
N					{
N						/* The task waiting has a higher priority than this task. */
N						queueYIELD_IF_USING_PREEMPTION();
X						vPortYield();
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				taskEXIT_CRITICAL();
X				vPortExitCritical();
N				return pdPASS;
X				return ( ( ( BaseType_t ) 1 ) );
N			}
N			else
N			{
N				if( xTicksToWait == ( TickType_t ) 0 )
N				{
N					/* The queue was empty and no block time is specified (or
N					the block time has expired) so leave now. */
N					taskEXIT_CRITICAL();
X					vPortExitCritical();
N					traceQUEUE_PEEK_FAILED( pxQueue );
X					;
N					return errQUEUE_EMPTY;
X					return ( ( BaseType_t ) 0 );
N				}
N				else if( xEntryTimeSet == pdFALSE )
X				else if( xEntryTimeSet == ( ( BaseType_t ) 0 ) )
N				{
N					/* The queue was empty and a block time was specified so
N					configure the timeout structure ready to enter the blocked
N					state. */
N					vTaskInternalSetTimeOutState( &xTimeOut );
N					xEntryTimeSet = pdTRUE;
X					xEntryTimeSet = ( ( BaseType_t ) 1 );
N				}
N				else
N				{
N					/* Entry time was already set. */
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N		}
N		taskEXIT_CRITICAL();
X		vPortExitCritical();
N
N		/* Interrupts and other tasks can send to and receive from the queue
N		now the critical section has been exited. */
N
N		vTaskSuspendAll();
N		prvLockQueue( pxQueue );
X		vPortEnterCritical(); { if( ( pxQueue )->cRxLock == ( ( int8_t ) -1 ) ) { ( pxQueue )->cRxLock = ( ( int8_t ) 0 ); } if( ( pxQueue )->cTxLock == ( ( int8_t ) -1 ) ) { ( pxQueue )->cTxLock = ( ( int8_t ) 0 ); } } vPortExitCritical();
N
N		/* Update the timeout state to see if it has expired yet. */
N		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
X		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == ( ( BaseType_t ) 0 ) )
N		{
N			/* Timeout has not expired yet, check to see if there is data in the
N			queue now, and if not enter the Blocked state to wait for data. */
N			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
X			if( prvIsQueueEmpty( pxQueue ) != ( ( BaseType_t ) 0 ) )
N			{
N				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
X				;
N				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
N				prvUnlockQueue( pxQueue );
N				if( xTaskResumeAll() == pdFALSE )
X				if( xTaskResumeAll() == ( ( BaseType_t ) 0 ) )
N				{
N					portYIELD_WITHIN_API();
X					vPortYield();
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				/* There is data in the queue now, so don't enter the blocked
N				state, instead return to try and obtain the data. */
N				prvUnlockQueue( pxQueue );
N				( void ) xTaskResumeAll();
N			}
N		}
N		else
N		{
N			/* The timeout has expired.  If there is still no data in the queue
N			exit, otherwise go back and try to read the data again. */
N			prvUnlockQueue( pxQueue );
N			( void ) xTaskResumeAll();
N
N			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
X			if( prvIsQueueEmpty( pxQueue ) != ( ( BaseType_t ) 0 ) )
N			{
N				traceQUEUE_PEEK_FAILED( pxQueue );
X				;
N				return errQUEUE_EMPTY;
X				return ( ( BaseType_t ) 0 );
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N	}
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
N{
NBaseType_t xReturn;
NUBaseType_t uxSavedInterruptStatus;
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	configASSERT( pxQueue );
X	;
N	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
X	;
N
N	/* RTOS ports that support interrupt nesting have the concept of a maximum
N	system call (or maximum API call) interrupt priority.  Interrupts that are
N	above the maximum system call priority are kept permanently enabled, even
N	when the RTOS kernel is in a critical section, but cannot make any calls to
N	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
N	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N	failure if a FreeRTOS API function is called from an interrupt that has been
N	assigned a priority above the configured maximum system call priority.
N	Only FreeRTOS functions that end in FromISR can be called from interrupts
N	that have been assigned a priority at or (logically) below the maximum
N	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
N	safe API to ensure interrupt entry is as fast and as simple as possible.
N	More information (albeit Cortex-M specific) is provided on the following
N	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X	;
N
N	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X	uxSavedInterruptStatus = ulSetInterruptMaskFromISR();
N	{
N		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
N
N		/* Cannot block in an ISR, so check there is data available. */
N		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
N		{
N			const int8_t cRxLock = pxQueue->cRxLock;
N
N			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
X			;
N
N			prvCopyDataFromQueue( pxQueue, pvBuffer );
N			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
N
N			/* If the queue is locked the event list will not be modified.
N			Instead update the lock count so the task that unlocks the queue
N			will know that an ISR has removed data while the queue was
N			locked. */
N			if( cRxLock == queueUNLOCKED )
X			if( cRxLock == ( ( int8_t ) -1 ) )
N			{
N				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X				if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N				{
N					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
X					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( ( BaseType_t ) 0 ) )
N					{
N						/* The task waiting has a higher priority than us so
N						force a context switch. */
N						if( pxHigherPriorityTaskWoken != NULL )
X						if( pxHigherPriorityTaskWoken != 0 )
N						{
N							*pxHigherPriorityTaskWoken = pdTRUE;
X							*pxHigherPriorityTaskWoken = ( ( BaseType_t ) 1 );
N						}
N						else
N						{
N							mtCOVERAGE_TEST_MARKER();
X							;
N						}
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N			}
N			else
N			{
N				/* Increment the lock count so the task that unlocks the queue
N				knows that data was removed while it was locked. */
N				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
N			}
N
N			xReturn = pdPASS;
X			xReturn = ( ( ( BaseType_t ) 1 ) );
N		}
N		else
N		{
N			xReturn = pdFAIL;
X			xReturn = ( ( ( BaseType_t ) 0 ) );
N			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
X			;
N		}
N	}
N	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X	vClearInterruptMaskFromISR( uxSavedInterruptStatus );
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
N{
NBaseType_t xReturn;
NUBaseType_t uxSavedInterruptStatus;
Nint8_t *pcOriginalReadPosition;
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	configASSERT( pxQueue );
X	;
N	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
X	;
N	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
X	;  
N
N	/* RTOS ports that support interrupt nesting have the concept of a maximum
N	system call (or maximum API call) interrupt priority.  Interrupts that are
N	above the maximum system call priority are kept permanently enabled, even
N	when the RTOS kernel is in a critical section, but cannot make any calls to
N	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
N	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
N	failure if a FreeRTOS API function is called from an interrupt that has been
N	assigned a priority above the configured maximum system call priority.
N	Only FreeRTOS functions that end in FromISR can be called from interrupts
N	that have been assigned a priority at or (logically) below the maximum
N	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
N	safe API to ensure interrupt entry is as fast and as simple as possible.
N	More information (albeit Cortex-M specific) is provided on the following
N	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
N	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
X	;
N
N	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
X	uxSavedInterruptStatus = ulSetInterruptMaskFromISR();
N	{
N		/* Cannot block in an ISR, so check there is data available. */
N		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
N		{
N			traceQUEUE_PEEK_FROM_ISR( pxQueue );
X			;
N
N			/* Remember the read position so it can be reset as nothing is
N			actually being removed from the queue. */
N			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
N			prvCopyDataFromQueue( pxQueue, pvBuffer );
N			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
N
N			xReturn = pdPASS;
X			xReturn = ( ( ( BaseType_t ) 1 ) );
N		}
N		else
N		{
N			xReturn = pdFAIL;
X			xReturn = ( ( ( BaseType_t ) 0 ) );
N			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
X			;
N		}
N	}
N	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
X	vClearInterruptMaskFromISR( uxSavedInterruptStatus );
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
NUBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
N{
NUBaseType_t uxReturn;
N
N	configASSERT( xQueue );
X	;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return uxReturn;
N} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
N/*-----------------------------------------------------------*/
N
NUBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
N{
NUBaseType_t uxReturn;
NQueue_t *pxQueue;
N
N	pxQueue = ( Queue_t * ) xQueue;
N	configASSERT( pxQueue );
X	;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return uxReturn;
N} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
N/*-----------------------------------------------------------*/
N
NUBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
N{
NUBaseType_t uxReturn;
N
N	configASSERT( xQueue );
X	;
N
N	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
N
N	return uxReturn;
N} /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
N/*-----------------------------------------------------------*/
N
Nvoid vQueueDelete( QueueHandle_t xQueue )
N{
NQueue_t * const pxQueue = ( Queue_t * ) xQueue;
N
N	configASSERT( pxQueue );
X	;
N	traceQUEUE_DELETE( pxQueue );
X	;
N
N	#if ( configQUEUE_REGISTRY_SIZE > 0 )
X	#if ( 0 > 0 )
S	{
S		vQueueUnregisterQueue( pxQueue );
S	}
N	#endif
N
N	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
X	#if( ( 1 == 1 ) && ( 1 == 0 ) )
S	{
S		/* The queue can only have been allocated dynamically - free it
S		again. */
S		vPortFree( pxQueue );
S	}
N	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
X	#elif( ( 1 == 1 ) && ( 1 == 1 ) )
N	{
N		/* The queue could have been allocated statically or dynamically, so
N		check before attempting to free the memory. */
N		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
X		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) ( ( BaseType_t ) 0 ) )
N		{
N			vPortFree( pxQueue );
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N	#else
S	{
S		/* The queue must have been statically allocated, so is not going to be
S		deleted.  Avoid compiler warnings about the unused parameter. */
S		( void ) pxQueue;
S	}
N	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
N}
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	UBaseType_t uxQueueGetQueueNumber( QueueHandle_t xQueue )
S	{
S		return ( ( Queue_t * ) xQueue )->uxQueueNumber;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	void vQueueSetQueueNumber( QueueHandle_t xQueue, UBaseType_t uxQueueNumber )
S	{
S		( ( Queue_t * ) xQueue )->uxQueueNumber = uxQueueNumber;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TRACE_FACILITY == 1 )
X#if ( 0 == 1 )
S
S	uint8_t ucQueueGetQueueType( QueueHandle_t xQueue )
S	{
S		return ( ( Queue_t * ) xQueue )->ucQueueType;
S	}
S
N#endif /* configUSE_TRACE_FACILITY */
N/*-----------------------------------------------------------*/
N
N#if( configUSE_MUTEXES == 1 )
X#if( 1 == 1 )
N
N	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
N	{
N	UBaseType_t uxHighestPriorityOfWaitingTasks;
N
N		/* If a task waiting for a mutex causes the mutex holder to inherit a
N		priority, but the waiting task times out, then the holder should
N		disinherit the priority - but only down to the highest priority of any
N		other tasks that are waiting for the same mutex.  For this purpose,
N		return the priority of the highest priority task that is waiting for the
N		mutex. */
N		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
X		if( ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems ) > 0 )
N		{
N			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
X			uxHighestPriorityOfWaitingTasks = 12 - ( ( ( &( pxQueue ->xTasksWaitingToReceive ) )->xListEnd ). pxNext->xItemValue );
N		}
N		else
N		{
N			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
X			uxHighestPriorityOfWaitingTasks = ( ( UBaseType_t ) 0U );
N		}
N
N		return uxHighestPriorityOfWaitingTasks;
N	}
N
N#endif /* configUSE_MUTEXES */
N/*-----------------------------------------------------------*/
N
Nstatic BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
N{
NBaseType_t xReturn = pdFALSE;
XBaseType_t xReturn = ( ( BaseType_t ) 0 );
NUBaseType_t uxMessagesWaiting;
N
N	/* This function is called from a critical section. */
N
N	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
N
N	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
N	{
N		#if ( configUSE_MUTEXES == 1 )
X		#if ( 1 == 1 )
N		{
N			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
X			if( pxQueue->pcHead == 0 )
N			{
N				/* The mutex is no longer being held. */
N				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
X				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pcTail );
N				pxQueue->pxMutexHolder = NULL;
X				pxQueue->pcTail = 0;
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		#endif /* configUSE_MUTEXES */
N	}
N	else if( xPosition == queueSEND_TO_BACK )
X	else if( xPosition == ( ( BaseType_t ) 0 ) )
N	{
N		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
N		pxQueue->pcWriteTo += pxQueue->uxItemSize;
N		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
N		{
N			pxQueue->pcWriteTo = pxQueue->pcHead;
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N	else
N	{
N		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
N		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
N		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
N		{
N			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N
N		if( xPosition == queueOVERWRITE )
X		if( xPosition == ( ( BaseType_t ) 2 ) )
N		{
N			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
N			{
N				/* An item is not being added but overwritten, so subtract
N				one from the recorded number of items in the queue so when
N				one is added again below the number of recorded items remains
N				correct. */
N				--uxMessagesWaiting;
N			}
N			else
N			{
N				mtCOVERAGE_TEST_MARKER();
X				;
N			}
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N	}
N
N	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
Nstatic void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
N{
N	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
N	{
N		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
N		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
N		{
N			pxQueue->u.pcReadFrom = pxQueue->pcHead;
N		}
N		else
N		{
N			mtCOVERAGE_TEST_MARKER();
X			;
N		}
N		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
N	}
N}
N/*-----------------------------------------------------------*/
N
Nstatic void prvUnlockQueue( Queue_t * const pxQueue )
N{
N	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
N
N	/* The lock counts contains the number of extra data items placed or
N	removed from the queue while the queue was locked.  When a queue is
N	locked items can be added or removed, but the event lists cannot be
N	updated. */
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		int8_t cTxLock = pxQueue->cTxLock;
N
N		/* See if data was added to the queue while it was locked. */
N		while( cTxLock > queueLOCKED_UNMODIFIED )
X		while( cTxLock > ( ( int8_t ) 0 ) )
N		{
N			/* Data was posted while the queue was locked.  Are any tasks
N			blocked waiting for data to become available? */
N			#if ( configUSE_QUEUE_SETS == 1 )
X			#if ( 0 == 1 )
S			{
S				if( pxQueue->pxQueueSetContainer != NULL )
S				{
S					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
S					{
S						/* The queue is a member of a queue set, and posting to
S						the queue set caused a higher priority task to unblock.
S						A context switch is required. */
S						vTaskMissedYield();
S					}
S					else
S					{
S						mtCOVERAGE_TEST_MARKER();
S					}
S				}
S				else
S				{
S					/* Tasks that are removed from the event list will get
S					added to the pending ready list as the scheduler is still
S					suspended. */
S					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S					{
S						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S						{
S							/* The task waiting has a higher priority so record that a
S							context	switch is required. */
S							vTaskMissedYield();
S						}
S						else
S						{
S							mtCOVERAGE_TEST_MARKER();
S						}
S					}
S					else
S					{
S						break;
S					}
S				}
S			}
N			#else /* configUSE_QUEUE_SETS */
N			{
N				/* Tasks that are removed from the event list will get added to
N				the pending ready list as the scheduler is still suspended. */
N				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
X				if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToReceive ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N				{
N					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
X					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != ( ( BaseType_t ) 0 ) )
N					{
N						/* The task waiting has a higher priority so record that
N						a context switch is required. */
N						vTaskMissedYield();
N					}
N					else
N					{
N						mtCOVERAGE_TEST_MARKER();
X						;
N					}
N				}
N				else
N				{
N					break;
N				}
N			}
N			#endif /* configUSE_QUEUE_SETS */
N
N			--cTxLock;
N		}
N
N		pxQueue->cTxLock = queueUNLOCKED;
X		pxQueue->cTxLock = ( ( int8_t ) -1 );
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	/* Do the same for the Rx lock. */
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		int8_t cRxLock = pxQueue->cRxLock;
N
N		while( cRxLock > queueLOCKED_UNMODIFIED )
X		while( cRxLock > ( ( int8_t ) 0 ) )
N		{
N			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
X			if( ( ( BaseType_t ) ( ( &( pxQueue ->xTasksWaitingToSend ) )->uxNumberOfItems == ( UBaseType_t ) 0 ) ) == ( ( BaseType_t ) 0 ) )
N			{
N				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
X				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != ( ( BaseType_t ) 0 ) )
N				{
N					vTaskMissedYield();
N				}
N				else
N				{
N					mtCOVERAGE_TEST_MARKER();
X					;
N				}
N
N				--cRxLock;
N			}
N			else
N			{
N				break;
N			}
N		}
N
N		pxQueue->cRxLock = queueUNLOCKED;
X		pxQueue->cRxLock = ( ( int8_t ) -1 );
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N}
N/*-----------------------------------------------------------*/
N
Nstatic BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
N{
NBaseType_t xReturn;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
N		{
N			xReturn = pdTRUE;
X			xReturn = ( ( BaseType_t ) 1 );
N		}
N		else
N		{
N			xReturn = pdFALSE;
X			xReturn = ( ( BaseType_t ) 0 );
N		}
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
N{
NBaseType_t xReturn;
N
N	configASSERT( xQueue );
X	;
N	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
N	{
N		xReturn = pdTRUE;
X		xReturn = ( ( BaseType_t ) 1 );
N	}
N	else
N	{
N		xReturn = pdFALSE;
X		xReturn = ( ( BaseType_t ) 0 );
N	}
N
N	return xReturn;
N} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
N/*-----------------------------------------------------------*/
N
Nstatic BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
N{
NBaseType_t xReturn;
N
N	taskENTER_CRITICAL();
X	vPortEnterCritical();
N	{
N		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
N		{
N			xReturn = pdTRUE;
X			xReturn = ( ( BaseType_t ) 1 );
N		}
N		else
N		{
N			xReturn = pdFALSE;
X			xReturn = ( ( BaseType_t ) 0 );
N		}
N	}
N	taskEXIT_CRITICAL();
X	vPortExitCritical();
N
N	return xReturn;
N}
N/*-----------------------------------------------------------*/
N
NBaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
N{
NBaseType_t xReturn;
N
N	configASSERT( xQueue );
X	;
N	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
N	{
N		xReturn = pdTRUE;
X		xReturn = ( ( BaseType_t ) 1 );
N	}
N	else
N	{
N		xReturn = pdFALSE;
X		xReturn = ( ( BaseType_t ) 0 );
N	}
N
N	return xReturn;
N} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xQueueCRSend( QueueHandle_t xQueue, const void *pvItemToQueue, TickType_t xTicksToWait )
S	{
S	BaseType_t xReturn;
S	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
S
S		/* If the queue is already full we may have to block.  A critical section
S		is required to prevent an interrupt removing something from the queue
S		between the check to see if the queue is full and blocking on the queue. */
S		portDISABLE_INTERRUPTS();
S		{
S			if( prvIsQueueFull( pxQueue ) != pdFALSE )
S			{
S				/* The queue is full - do we want to block or just leave without
S				posting? */
S				if( xTicksToWait > ( TickType_t ) 0 )
S				{
S					/* As this is called from a coroutine we cannot block directly, but
S					return indicating that we need to block. */
S					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
S					portENABLE_INTERRUPTS();
S					return errQUEUE_BLOCKED;
S				}
S				else
S				{
S					portENABLE_INTERRUPTS();
S					return errQUEUE_FULL;
S				}
S			}
S		}
S		portENABLE_INTERRUPTS();
S
S		portDISABLE_INTERRUPTS();
S		{
S			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
S			{
S				/* There is room in the queue, copy the data into the queue. */
S				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
S				xReturn = pdPASS;
S
S				/* Were any co-routines waiting for data to become available? */
S				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S				{
S					/* In this instance the co-routine could be placed directly
S					into the ready list as we are within a critical section.
S					Instead the same pending ready list mechanism is used as if
S					the event were caused from within an interrupt. */
S					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S					{
S						/* The co-routine waiting has a higher priority so record
S						that a yield might be appropriate. */
S						xReturn = errQUEUE_YIELD;
S					}
S					else
S					{
S						mtCOVERAGE_TEST_MARKER();
S					}
S				}
S				else
S				{
S					mtCOVERAGE_TEST_MARKER();
S				}
S			}
S			else
S			{
S				xReturn = errQUEUE_FULL;
S			}
S		}
S		portENABLE_INTERRUPTS();
S
S		return xReturn;
S	}
S
N#endif /* configUSE_CO_ROUTINES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xQueueCRReceive( QueueHandle_t xQueue, void *pvBuffer, TickType_t xTicksToWait )
S	{
S	BaseType_t xReturn;
S	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
S
S		/* If the queue is already empty we may have to block.  A critical section
S		is required to prevent an interrupt adding something to the queue
S		between the check to see if the queue is empty and blocking on the queue. */
S		portDISABLE_INTERRUPTS();
S		{
S			if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0 )
S			{
S				/* There are no messages in the queue, do we want to block or just
S				leave with nothing? */
S				if( xTicksToWait > ( TickType_t ) 0 )
S				{
S					/* As this is a co-routine we cannot block directly, but return
S					indicating that we need to block. */
S					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
S					portENABLE_INTERRUPTS();
S					return errQUEUE_BLOCKED;
S				}
S				else
S				{
S					portENABLE_INTERRUPTS();
S					return errQUEUE_FULL;
S				}
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
S		portENABLE_INTERRUPTS();
S
S		portDISABLE_INTERRUPTS();
S		{
S			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
S			{
S				/* Data is available from the queue. */
S				pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
S				if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
S				{
S					pxQueue->u.pcReadFrom = pxQueue->pcHead;
S				}
S				else
S				{
S					mtCOVERAGE_TEST_MARKER();
S				}
S				--( pxQueue->uxMessagesWaiting );
S				( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
S
S				xReturn = pdPASS;
S
S				/* Were any co-routines waiting for space to become available? */
S				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
S				{
S					/* In this instance the co-routine could be placed directly
S					into the ready list as we are within a critical section.
S					Instead the same pending ready list mechanism is used as if
S					the event were caused from within an interrupt. */
S					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
S					{
S						xReturn = errQUEUE_YIELD;
S					}
S					else
S					{
S						mtCOVERAGE_TEST_MARKER();
S					}
S				}
S				else
S				{
S					mtCOVERAGE_TEST_MARKER();
S				}
S			}
S			else
S			{
S				xReturn = pdFAIL;
S			}
S		}
S		portENABLE_INTERRUPTS();
S
S		return xReturn;
S	}
S
N#endif /* configUSE_CO_ROUTINES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xQueueCRSendFromISR( QueueHandle_t xQueue, const void *pvItemToQueue, BaseType_t xCoRoutinePreviouslyWoken )
S	{
S	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
S
S		/* Cannot block within an ISR so if there is no space on the queue then
S		exit without doing anything. */
S		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
S		{
S			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
S
S			/* We only want to wake one co-routine per ISR, so check that a
S			co-routine has not already been woken. */
S			if( xCoRoutinePreviouslyWoken == pdFALSE )
S			{
S				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
S				{
S					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
S					{
S						return pdTRUE;
S					}
S					else
S					{
S						mtCOVERAGE_TEST_MARKER();
S					}
S				}
S				else
S				{
S					mtCOVERAGE_TEST_MARKER();
S				}
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S
S		return xCoRoutinePreviouslyWoken;
S	}
S
N#endif /* configUSE_CO_ROUTINES */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_CO_ROUTINES == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xQueueCRReceiveFromISR( QueueHandle_t xQueue, void *pvBuffer, BaseType_t *pxCoRoutineWoken )
S	{
S	BaseType_t xReturn;
S	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
S
S		/* We cannot block from an ISR, so check there is data available. If
S		not then just leave without doing anything. */
S		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
S		{
S			/* Copy the data from the queue. */
S			pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
S			if( pxQueue->u.pcReadFrom >= pxQueue->pcTail )
S			{
S				pxQueue->u.pcReadFrom = pxQueue->pcHead;
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S			--( pxQueue->uxMessagesWaiting );
S			( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
S
S			if( ( *pxCoRoutineWoken ) == pdFALSE )
S			{
S				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
S				{
S					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
S					{
S						*pxCoRoutineWoken = pdTRUE;
S					}
S					else
S					{
S						mtCOVERAGE_TEST_MARKER();
S					}
S				}
S				else
S				{
S					mtCOVERAGE_TEST_MARKER();
S				}
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S
S			xReturn = pdPASS;
S		}
S		else
S		{
S			xReturn = pdFAIL;
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_CO_ROUTINES */
N/*-----------------------------------------------------------*/
N
N#if ( configQUEUE_REGISTRY_SIZE > 0 )
X#if ( 0 > 0 )
S
S	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
S	{
S	UBaseType_t ux;
S
S		/* See if there is an empty space in the registry.  A NULL name denotes
S		a free slot. */
S		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
S		{
S			if( xQueueRegistry[ ux ].pcQueueName == NULL )
S			{
S				/* Store the information on this queue. */
S				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
S				xQueueRegistry[ ux ].xHandle = xQueue;
S
S				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
S				break;
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
S	}
S
N#endif /* configQUEUE_REGISTRY_SIZE */
N/*-----------------------------------------------------------*/
N
N#if ( configQUEUE_REGISTRY_SIZE > 0 )
X#if ( 0 > 0 )
S
S	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
S	{
S	UBaseType_t ux;
S	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
S
S		/* Note there is nothing here to protect against another task adding or
S		removing entries from the registry while it is being searched. */
S		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
S		{
S			if( xQueueRegistry[ ux ].xHandle == xQueue )
S			{
S				pcReturn = xQueueRegistry[ ux ].pcQueueName;
S				break;
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
S
S		return pcReturn;
S	} /*lint !e818 xQueue cannot be a pointer to const because it is a typedef. */
S
N#endif /* configQUEUE_REGISTRY_SIZE */
N/*-----------------------------------------------------------*/
N
N#if ( configQUEUE_REGISTRY_SIZE > 0 )
X#if ( 0 > 0 )
S
S	void vQueueUnregisterQueue( QueueHandle_t xQueue )
S	{
S	UBaseType_t ux;
S
S		/* See if the handle of the queue being unregistered in actually in the
S		registry. */
S		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
S		{
S			if( xQueueRegistry[ ux ].xHandle == xQueue )
S			{
S				/* Set the name to NULL to show that this slot if free again. */
S				xQueueRegistry[ ux ].pcQueueName = NULL;
S
S				/* Set the handle to NULL to ensure the same queue handle cannot
S				appear in the registry twice if it is added, removed, then
S				added again. */
S				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
S				break;
S			}
S			else
S			{
S				mtCOVERAGE_TEST_MARKER();
S			}
S		}
S
S	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
S
N#endif /* configQUEUE_REGISTRY_SIZE */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_TIMERS == 1 )
X#if ( 0 == 1 )
S
S	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
S	{
S	Queue_t * const pxQueue = ( Queue_t * ) xQueue;
S
S		/* This function should not be called by application code hence the
S		'Restricted' in its name.  It is not part of the public API.  It is
S		designed for use by kernel code, and has special calling requirements.
S		It can result in vListInsert() being called on a list that can only
S		possibly ever have one item in it, so the list will be fast, but even
S		so it should be called with the scheduler locked and not from a critical
S		section. */
S
S		/* Only do anything if there are no messages in the queue.  This function
S		will not actually cause the task to block, just place it on a blocked
S		list.  It will not block until the scheduler is unlocked - at which
S		time a yield will be performed.  If an item is added to the queue while
S		the queue is locked, and the calling task blocks on the queue, then the
S		calling task will be immediately unblocked when the queue is unlocked. */
S		prvLockQueue( pxQueue );
S		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
S		{
S			/* There is nothing in the queue, block for the specified period. */
S			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S		prvUnlockQueue( pxQueue );
S	}
S
N#endif /* configUSE_TIMERS */
N/*-----------------------------------------------------------*/
N
N#if( ( configUSE_QUEUE_SETS == 1 ) && ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) )
X#if( ( 0 == 1 ) && ( 1 == 1 ) )
S
S	QueueSetHandle_t xQueueCreateSet( const UBaseType_t uxEventQueueLength )
S	{
S	QueueSetHandle_t pxQueue;
S
S		pxQueue = xQueueGenericCreate( uxEventQueueLength, ( UBaseType_t ) sizeof( Queue_t * ), queueQUEUE_TYPE_SET );
S
S		return pxQueue;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xQueueAddToSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
S	{
S	BaseType_t xReturn;
S
S		taskENTER_CRITICAL();
S		{
S			if( ( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer != NULL )
S			{
S				/* Cannot add a queue/semaphore to more than one queue set. */
S				xReturn = pdFAIL;
S			}
S			else if( ( ( Queue_t * ) xQueueOrSemaphore )->uxMessagesWaiting != ( UBaseType_t ) 0 )
S			{
S				/* Cannot add a queue/semaphore to a queue set if there are already
S				items in the queue/semaphore. */
S				xReturn = pdFAIL;
S			}
S			else
S			{
S				( ( Queue_t * ) xQueueOrSemaphore )->pxQueueSetContainer = xQueueSet;
S				xReturn = pdPASS;
S			}
S		}
S		taskEXIT_CRITICAL();
S
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	BaseType_t xQueueRemoveFromSet( QueueSetMemberHandle_t xQueueOrSemaphore, QueueSetHandle_t xQueueSet )
S	{
S	BaseType_t xReturn;
S	Queue_t * const pxQueueOrSemaphore = ( Queue_t * ) xQueueOrSemaphore;
S
S		if( pxQueueOrSemaphore->pxQueueSetContainer != xQueueSet )
S		{
S			/* The queue was not a member of the set. */
S			xReturn = pdFAIL;
S		}
S		else if( pxQueueOrSemaphore->uxMessagesWaiting != ( UBaseType_t ) 0 )
S		{
S			/* It is dangerous to remove a queue from a set when the queue is
S			not empty because the queue set will still hold pending events for
S			the queue. */
S			xReturn = pdFAIL;
S		}
S		else
S		{
S			taskENTER_CRITICAL();
S			{
S				/* The queue is no longer contained in the set. */
S				pxQueueOrSemaphore->pxQueueSetContainer = NULL;
S			}
S			taskEXIT_CRITICAL();
S			xReturn = pdPASS;
S		}
S
S		return xReturn;
S	} /*lint !e818 xQueueSet could not be declared as pointing to const as it is a typedef. */
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	QueueSetMemberHandle_t xQueueSelectFromSet( QueueSetHandle_t xQueueSet, TickType_t const xTicksToWait )
S	{
S	QueueSetMemberHandle_t xReturn = NULL;
S
S		( void ) xQueueReceive( ( QueueHandle_t ) xQueueSet, &xReturn, xTicksToWait ); /*lint !e961 Casting from one typedef to another is not redundant. */
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	QueueSetMemberHandle_t xQueueSelectFromSetFromISR( QueueSetHandle_t xQueueSet )
S	{
S	QueueSetMemberHandle_t xReturn = NULL;
S
S		( void ) xQueueReceiveFromISR( ( QueueHandle_t ) xQueueSet, &xReturn, NULL ); /*lint !e961 Casting from one typedef to another is not redundant. */
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N/*-----------------------------------------------------------*/
N
N#if ( configUSE_QUEUE_SETS == 1 )
X#if ( 0 == 1 )
S
S	static BaseType_t prvNotifyQueueSetContainer( const Queue_t * const pxQueue, const BaseType_t xCopyPosition )
S	{
S	Queue_t *pxQueueSetContainer = pxQueue->pxQueueSetContainer;
S	BaseType_t xReturn = pdFALSE;
S
S		/* This function must be called form a critical section. */
S
S		configASSERT( pxQueueSetContainer );
S		configASSERT( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength );
S
S		if( pxQueueSetContainer->uxMessagesWaiting < pxQueueSetContainer->uxLength )
S		{
S			const int8_t cTxLock = pxQueueSetContainer->cTxLock;
S
S			traceQUEUE_SEND( pxQueueSetContainer );
S
S			/* The data copied is the handle of the queue that contains data. */
S			xReturn = prvCopyDataToQueue( pxQueueSetContainer, &pxQueue, xCopyPosition );
S
S			if( cTxLock == queueUNLOCKED )
S			{
S				if( listLIST_IS_EMPTY( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) == pdFALSE )
S				{
S					if( xTaskRemoveFromEventList( &( pxQueueSetContainer->xTasksWaitingToReceive ) ) != pdFALSE )
S					{
S						/* The task waiting has a higher priority. */
S						xReturn = pdTRUE;
S					}
S					else
S					{
S						mtCOVERAGE_TEST_MARKER();
S					}
S				}
S				else
S				{
S					mtCOVERAGE_TEST_MARKER();
S				}
S			}
S			else
S			{
S				pxQueueSetContainer->cTxLock = ( int8_t ) ( cTxLock + 1 );
S			}
S		}
S		else
S		{
S			mtCOVERAGE_TEST_MARKER();
S		}
S
S		return xReturn;
S	}
S
N#endif /* configUSE_QUEUE_SETS */
N
N
N
N
N
N
N
N
N
N
N
N
