; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\soft_i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\soft_i2c.d --cpu=Cortex-M0 --apcs=interwork -O1 --diag_suppress=9931 -I.\APP -I.\APP\TN2115s_libs -I..\Common\CMSIS-FreeRTOS\10.0.1\Source\include -I..\Common\RTE\RTOS -I..\Common\CMSIS-FreeRTOS\10.0.1\CMSIS\RTOS2\FreeRTOS\Include -I..\Common\CMSIS-FreeRTOS\10.0.1\Source\portable\RVDS\ARM_CM0 -I.\APP\EINK -I.\RTE\_soc_m0 -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\Device\ARM\ARMCM0\Include -D__MICROLIB -D__UVISION_VERSION=529 -D_RTE_ -DARMCM0 --omf_browse=.\objects\soft_i2c.crf APP\IIC\soft_i2c.c]
                          THUMB

                          AREA ||i.I2C_Read16Bits||, CODE, READONLY, ALIGN=1

                  I2C_Read16Bits PROC
;;;586    */
;;;587    static uint8_t I2C_Read16Bits(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint16_t regAddr,uint8_t *pBuffer,uint16_t NumByteToRead)
000000  b5ff              PUSH     {r0-r7,lr}
;;;588    {
000002  b081              SUB      sp,sp,#4
000004  9c0a              LDR      r4,[sp,#0x28]
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461d              MOV      r5,r3
;;;589    
;;;590    	/* 第1步：发起I2C总线启动信号 */
;;;591    	i2c_Start(ops);
00000c  9801              LDR      r0,[sp,#4]
00000e  f7fffffe          BL       i2c_Start
;;;592    	
;;;593    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;594    	i2c_SendByte(ops,slaveAddr | I2C_WR);	/* 此处是写指令 */
000012  4639              MOV      r1,r7
000014  9801              LDR      r0,[sp,#4]
000016  f7fffffe          BL       i2c_SendByte
;;;595    	 
;;;596    	/* 第3步：等待ACK */
;;;597    	if (i2c_WaitAck(ops) != 0)
00001a  9801              LDR      r0,[sp,#4]
00001c  f7fffffe          BL       i2c_WaitAck
000020  2800              CMP      r0,#0
000022  d11f              BNE      |L1.100|
;;;598    	{
;;;599    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;600    	}
;;;601    	i2c_SendByte(ops,regAddr>>8);	/* 此处是写指令 */
000024  0a31              LSRS     r1,r6,#8
000026  9801              LDR      r0,[sp,#4]
000028  f7fffffe          BL       i2c_SendByte
;;;602    	 
;;;603    	/* 第3步：等待ACK */
;;;604    	if (i2c_WaitAck(ops) != 0)
00002c  9801              LDR      r0,[sp,#4]
00002e  f7fffffe          BL       i2c_WaitAck
000032  2800              CMP      r0,#0
000034  d116              BNE      |L1.100|
;;;605    	{
;;;606    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;607    	}
;;;608    	i2c_SendByte(ops,regAddr%256);	/* 此处是写指令 */
000036  b2f1              UXTB     r1,r6
000038  9801              LDR      r0,[sp,#4]
00003a  f7fffffe          BL       i2c_SendByte
;;;609    	 
;;;610    	/* 第3步：等待ACK */
;;;611    	if (i2c_WaitAck(ops) != 0)
00003e  9801              LDR      r0,[sp,#4]
000040  f7fffffe          BL       i2c_WaitAck
000044  2800              CMP      r0,#0
000046  d10d              BNE      |L1.100|
;;;612    	{
;;;613    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;614    	}
;;;615    	
;;;616    	i2c_Start(ops);
000048  9801              LDR      r0,[sp,#4]
00004a  f7fffffe          BL       i2c_Start
;;;617    	
;;;618    	i2c_SendByte(ops,slaveAddr | I2C_RD);	/* 此处是写指令 */
00004e  2001              MOVS     r0,#1
000050  4639              MOV      r1,r7
000052  4301              ORRS     r1,r1,r0
000054  9801              LDR      r0,[sp,#4]
000056  f7fffffe          BL       i2c_SendByte
;;;619    	 
;;;620    	/* 第3步：等待ACK */
;;;621    	if (i2c_WaitAck(ops) != 0)
00005a  9801              LDR      r0,[sp,#4]
00005c  f7fffffe          BL       i2c_WaitAck
000060  2800              CMP      r0,#0
000062  d00f              BEQ      |L1.132|
                  |L1.100|
;;;622    	{
;;;623    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;624    	}
;;;625    	
;;;626    	while(NumByteToRead--)
;;;627    	{
;;;628    		*pBuffer = i2c_ReadByte(ops);
;;;629    		pBuffer++;					//偏移到下一个数据存储地址
;;;630    		
;;;631    		if(NumByteToRead == 0)
;;;632            {
;;;633               i2c_NAck(ops);			//最后一个数据需要回NOACK
;;;634            }
;;;635            else
;;;636            {
;;;637              i2c_Ack(ops);			//回应ACK
;;;638    				}
;;;639    	}
;;;640    
;;;641    	/* 发送I2C总线停止信号 */
;;;642    	i2c_Stop(ops);
;;;643    	return I2C_SUCCESS;	/* 执行成功 */
;;;644    
;;;645    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;646    	/* 发送I2C总线停止信号 */
;;;647    	i2c_Stop(ops);
000064  9801              LDR      r0,[sp,#4]
000066  f7fffffe          BL       i2c_Stop
;;;648    	return I2C_FAIL;
00006a  2001              MOVS     r0,#1
                  |L1.108|
;;;649    
;;;650    }
00006c  b005              ADD      sp,sp,#0x14
00006e  bdf0              POP      {r4-r7,pc}
                  |L1.112|
000070  9801              LDR      r0,[sp,#4]            ;628
000072  f7fffffe          BL       i2c_ReadByte
000076  7028              STRB     r0,[r5,#0]            ;628
000078  1c6d              ADDS     r5,r5,#1              ;628
00007a  2c00              CMP      r4,#0                 ;631
00007c  d00c              BEQ      |L1.152|
00007e  9801              LDR      r0,[sp,#4]            ;637
000080  f7fffffe          BL       i2c_Ack
                  |L1.132|
000084  4620              MOV      r0,r4                 ;626
000086  1e64              SUBS     r4,r4,#1              ;626
000088  b2a4              UXTH     r4,r4                 ;626
00008a  2800              CMP      r0,#0                 ;626
00008c  d1f0              BNE      |L1.112|
00008e  9801              LDR      r0,[sp,#4]            ;642
000090  f7fffffe          BL       i2c_Stop
000094  2000              MOVS     r0,#0                 ;643
000096  e7e9              B        |L1.108|
                  |L1.152|
000098  9801              LDR      r0,[sp,#4]            ;633
00009a  f7fffffe          BL       i2c_NAck
00009e  e7f1              B        |L1.132|
;;;651    /*********************************************************************************************/
                          ENDP


                          AREA ||i.I2C_Read8Bits||, CODE, READONLY, ALIGN=1

                  I2C_Read8Bits PROC
;;;514    */
;;;515    static uint8_t I2C_Read8Bits(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint8_t regAddr,uint8_t *pBuffer,uint16_t NumByteToRead)
000000  b5ff              PUSH     {r0-r7,lr}
;;;516    {
000002  b081              SUB      sp,sp,#4
000004  9c0a              LDR      r4,[sp,#0x28]
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461d              MOV      r5,r3
;;;517    
;;;518    	/* 第1步：发起I2C总线启动信号 */
;;;519    	i2c_Start(ops);
00000c  9801              LDR      r0,[sp,#4]
00000e  f7fffffe          BL       i2c_Start
;;;520    	
;;;521    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;522    	i2c_SendByte(ops,slaveAddr | I2C_WR);	/* 此处是写指令 */
000012  4631              MOV      r1,r6
000014  9801              LDR      r0,[sp,#4]
000016  f7fffffe          BL       i2c_SendByte
;;;523    	 
;;;524    	/* 第3步：等待ACK */
;;;525    	if (i2c_WaitAck(ops) != 0)
00001a  9801              LDR      r0,[sp,#4]
00001c  f7fffffe          BL       i2c_WaitAck
000020  2800              CMP      r0,#0
000022  d116              BNE      |L2.82|
;;;526    	{
;;;527    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;528    	}
;;;529    	i2c_SendByte(ops,regAddr);	/* 此处是写指令 */
000024  4639              MOV      r1,r7
000026  9801              LDR      r0,[sp,#4]
000028  f7fffffe          BL       i2c_SendByte
;;;530    	 
;;;531    	/* 第3步：等待ACK */
;;;532    	if (i2c_WaitAck(ops) != 0)
00002c  9801              LDR      r0,[sp,#4]
00002e  f7fffffe          BL       i2c_WaitAck
000032  2800              CMP      r0,#0
000034  d10d              BNE      |L2.82|
;;;533    	{
;;;534    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;535    	}
;;;536    
;;;537    	i2c_Start(ops);
000036  9801              LDR      r0,[sp,#4]
000038  f7fffffe          BL       i2c_Start
;;;538    	
;;;539    	i2c_SendByte(ops,slaveAddr | I2C_RD);	/* 此处是写指令 */
00003c  2001              MOVS     r0,#1
00003e  4631              MOV      r1,r6
000040  4301              ORRS     r1,r1,r0
000042  9801              LDR      r0,[sp,#4]
000044  f7fffffe          BL       i2c_SendByte
;;;540    	 
;;;541    	/* 第3步：等待ACK */
;;;542    	if (i2c_WaitAck(ops) != 0)
000048  9801              LDR      r0,[sp,#4]
00004a  f7fffffe          BL       i2c_WaitAck
00004e  2800              CMP      r0,#0
000050  d00f              BEQ      |L2.114|
                  |L2.82|
;;;543    	{
;;;544    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;545    	}
;;;546    	
;;;547    	while(NumByteToRead--)
;;;548    	{
;;;549    		*pBuffer = i2c_ReadByte(ops);
;;;550    		pBuffer++;					//偏移到下一个数据存储地址
;;;551    		
;;;552    		if(NumByteToRead == 0)
;;;553            {
;;;554               i2c_NAck(ops);			//最后一个数据需要回NOACK
;;;555            }
;;;556            else
;;;557            {
;;;558              i2c_Ack(ops);			//回应ACK
;;;559    				}
;;;560    	}
;;;561    
;;;562    	/* 发送I2C总线停止信号 */
;;;563    	i2c_Stop(ops);
;;;564    	return I2C_SUCCESS;	/* 执行成功 */
;;;565    
;;;566    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;567    	/* 发送I2C总线停止信号 */
;;;568    	i2c_Stop(ops);
000052  9801              LDR      r0,[sp,#4]
000054  f7fffffe          BL       i2c_Stop
;;;569    	return I2C_FAIL;
000058  2001              MOVS     r0,#1
                  |L2.90|
;;;570    
;;;571    }
00005a  b005              ADD      sp,sp,#0x14
00005c  bdf0              POP      {r4-r7,pc}
                  |L2.94|
00005e  9801              LDR      r0,[sp,#4]            ;549
000060  f7fffffe          BL       i2c_ReadByte
000064  7028              STRB     r0,[r5,#0]            ;549
000066  1c6d              ADDS     r5,r5,#1              ;549
000068  2c00              CMP      r4,#0                 ;552
00006a  d00c              BEQ      |L2.134|
00006c  9801              LDR      r0,[sp,#4]            ;558
00006e  f7fffffe          BL       i2c_Ack
                  |L2.114|
000072  4620              MOV      r0,r4                 ;547
000074  1e64              SUBS     r4,r4,#1              ;547
000076  b2a4              UXTH     r4,r4                 ;547
000078  2800              CMP      r0,#0                 ;547
00007a  d1f0              BNE      |L2.94|
00007c  9801              LDR      r0,[sp,#4]            ;563
00007e  f7fffffe          BL       i2c_Stop
000082  2000              MOVS     r0,#0                 ;564
000084  e7e9              B        |L2.90|
                  |L2.134|
000086  9801              LDR      r0,[sp,#4]            ;554
000088  f7fffffe          BL       i2c_NAck
00008c  e7f1              B        |L2.114|
;;;572    /*
                          ENDP


                          AREA ||i.I2C_ReadCmds||, CODE, READONLY, ALIGN=1

                  I2C_ReadCmds PROC
;;;456    */
;;;457    static uint8_t I2C_ReadCmds(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint8_t* pBuffer,uint16_t NumByteToRead)
000000  b5f8              PUSH     {r3-r7,lr}
;;;458    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461c              MOV      r4,r3
;;;459    
;;;460    	/* 第1步：发起I2C总线启动信号 */
;;;461    	i2c_Start(ops);
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       i2c_Start
;;;462    	
;;;463    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;464    	i2c_SendByte(ops,slaveAddr | I2C_RD);	/* 此处是写指令 */
000010  2001              MOVS     r0,#1
000012  4639              MOV      r1,r7
000014  4301              ORRS     r1,r1,r0
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       i2c_SendByte
;;;465    	 
;;;466    	/* 第3步：等待ACK */
;;;467    	if (i2c_WaitAck(ops) != 0)
00001c  4630              MOV      r0,r6
00001e  f7fffffe          BL       i2c_WaitAck
000022  2800              CMP      r0,#0
000024  d010              BEQ      |L3.72|
;;;468    	{
;;;469    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;470    	}
;;;471    
;;;472    	while(NumByteToRead) 
;;;473      {
;;;474    
;;;475        
;;;476       *pBuffer = i2c_ReadByte(ops);
;;;477        
;;;478        /* 读指针自增 */
;;;479        pBuffer++; 
;;;480          
;;;481        /*计数器自减 */
;;;482        NumByteToRead--;
;;;483        
;;;484        if(NumByteToRead == 0)
;;;485    			i2c_NAck(ops);	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
;;;486        else
;;;487          i2c_Ack(ops);	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */  
;;;488      }
;;;489    	/* 发送I2C总线停止信号 */
;;;490    	i2c_Stop(ops);
;;;491    	return I2C_SUCCESS;
;;;492    
;;;493    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;494    	/* 发送I2C总线停止信号 */
;;;495    	i2c_Stop(ops);
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       i2c_Stop
;;;496    	return I2C_FAIL;
00002c  2001              MOVS     r0,#1
;;;497    
;;;498    }
00002e  bdf8              POP      {r3-r7,pc}
                  |L3.48|
000030  4630              MOV      r0,r6                 ;476
000032  f7fffffe          BL       i2c_ReadByte
000036  7028              STRB     r0,[r5,#0]            ;476
000038  1c6d              ADDS     r5,r5,#1              ;476
00003a  1e64              SUBS     r4,r4,#1              ;482
00003c  b2a4              UXTH     r4,r4                 ;482
00003e  2c00              CMP      r4,#0                 ;484
000040  d009              BEQ      |L3.86|
000042  4630              MOV      r0,r6                 ;487
000044  f7fffffe          BL       i2c_Ack
                  |L3.72|
000048  2c00              CMP      r4,#0                 ;472
00004a  d1f1              BNE      |L3.48|
00004c  4630              MOV      r0,r6                 ;490
00004e  f7fffffe          BL       i2c_Stop
000052  2000              MOVS     r0,#0                 ;491
000054  bdf8              POP      {r3-r7,pc}
                  |L3.86|
000056  4630              MOV      r0,r6                 ;485
000058  f7fffffe          BL       i2c_NAck
00005c  e7f4              B        |L3.72|
;;;499    
                          ENDP


                          AREA ||i.I2C_Write16Bits||, CODE, READONLY, ALIGN=1

                  I2C_Write16Bits PROC
;;;390    */
;;;391    static uint8_t I2C_Write16Bits(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint16_t regAddr, uint8_t* pBuffer,uint16_t usize)
000000  b5ff              PUSH     {r0-r7,lr}
;;;392    {
000002  b081              SUB      sp,sp,#4
000004  9d0a              LDR      r5,[sp,#0x28]
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;393    	/* 第1步：发起I2C总线启动信号 */
;;;394    	i2c_Start(ops);
00000c  9801              LDR      r0,[sp,#4]
00000e  f7fffffe          BL       i2c_Start
;;;395    				
;;;396    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;397    	i2c_SendByte(ops,slaveAddr|I2C_WR);	/* 此处是写指令 */
000012  4639              MOV      r1,r7
000014  9801              LDR      r0,[sp,#4]
000016  f7fffffe          BL       i2c_SendByte
;;;398    				
;;;399    	/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;400    	if (i2c_WaitAck(ops)!= 0)
00001a  9801              LDR      r0,[sp,#4]
00001c  f7fffffe          BL       i2c_WaitAck
000020  2800              CMP      r0,#0
000022  d11b              BNE      |L4.92|
;;;401    	{
;;;402    			goto cmd_fail;
;;;403    	}
;;;404    	i2c_SendByte(ops,regAddr>>8);
000024  0a31              LSRS     r1,r6,#8
000026  9801              LDR      r0,[sp,#4]
000028  f7fffffe          BL       i2c_SendByte
;;;405    	/* 第5步：等待ACK */
;;;406    	if (i2c_WaitAck(ops) != 0)
00002c  9801              LDR      r0,[sp,#4]
00002e  f7fffffe          BL       i2c_WaitAck
000032  2800              CMP      r0,#0
000034  d112              BNE      |L4.92|
;;;407    	{
;;;408    				goto cmd_fail;	/* EEPROM器件无应答 */
;;;409    	}
;;;410    	
;;;411    	i2c_SendByte(ops,regAddr%256);
000036  b2f1              UXTB     r1,r6
000038  9801              LDR      r0,[sp,#4]
00003a  f7fffffe          BL       i2c_SendByte
;;;412    	/* 第5步：等待ACK */
;;;413    	if (i2c_WaitAck(ops) != 0)
00003e  9801              LDR      r0,[sp,#4]
000040  f7fffffe          BL       i2c_WaitAck
000044  2800              CMP      r0,#0
000046  d109              BNE      |L4.92|
000048  e00f              B        |L4.106|
                  |L4.74|
;;;414    	{
;;;415    				goto cmd_fail;	/* EEPROM器件无应答 */
;;;416    	}
;;;417      while(usize--)
;;;418      {
;;;419    		/* 第4步：开始写入数据 */
;;;420    		i2c_SendByte(ops,*pBuffer);
00004a  7821              LDRB     r1,[r4,#0]
00004c  9801              LDR      r0,[sp,#4]
00004e  f7fffffe          BL       i2c_SendByte
;;;421    
;;;422    		/* 第5步：检查ACK */
;;;423    		if (i2c_WaitAck(ops) != 0)
000052  9801              LDR      r0,[sp,#4]
000054  f7fffffe          BL       i2c_WaitAck
000058  2800              CMP      r0,#0
00005a  d005              BEQ      |L4.104|
                  |L4.92|
;;;424    		{
;;;425    			goto cmd_fail;	/* 器件无应答 */
;;;426    		}
;;;427      
;;;428          pBuffer++;	/* 地址增1 */		
;;;429      }
;;;430    	/* 命令执行成功，发送I2C总线停止信号 */
;;;431    	i2c_Stop(ops);
;;;432    	return I2C_SUCCESS;
;;;433    
;;;434    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;435    	/* 发送I2C总线停止信号 */
;;;436    	i2c_Stop(ops);
00005c  9801              LDR      r0,[sp,#4]
00005e  f7fffffe          BL       i2c_Stop
;;;437    	return I2C_FAIL;
000062  2001              MOVS     r0,#1
                  |L4.100|
;;;438    
;;;439    }
000064  b005              ADD      sp,sp,#0x14
000066  bdf0              POP      {r4-r7,pc}
                  |L4.104|
000068  1c64              ADDS     r4,r4,#1              ;428
                  |L4.106|
00006a  4628              MOV      r0,r5                 ;417
00006c  1e6d              SUBS     r5,r5,#1              ;417
00006e  b2ad              UXTH     r5,r5                 ;417
000070  2800              CMP      r0,#0                 ;417
000072  d1ea              BNE      |L4.74|
000074  9801              LDR      r0,[sp,#4]            ;431
000076  f7fffffe          BL       i2c_Stop
00007a  2000              MOVS     r0,#0                 ;432
00007c  e7f2              B        |L4.100|
;;;440    /**************************************Read Function*******************************************************/
                          ENDP


                          AREA ||i.I2C_Write8Bits||, CODE, READONLY, ALIGN=1

                  I2C_Write8Bits PROC
;;;335    */
;;;336    uint8_t I2C_Write8Bits(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint8_t regAddr, uint8_t* pBuffer,uint16_t usize)
000000  b5ff              PUSH     {r0-r7,lr}
;;;337    {
000002  b081              SUB      sp,sp,#4
000004  9d0a              LDR      r5,[sp,#0x28]
000006  460f              MOV      r7,r1
000008  4616              MOV      r6,r2
00000a  461c              MOV      r4,r3
;;;338    	/* 第1步：发起I2C总线启动信号 */
;;;339    	i2c_Start(ops);
00000c  9801              LDR      r0,[sp,#4]
00000e  f7fffffe          BL       i2c_Start
;;;340    				
;;;341    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;342    	i2c_SendByte(ops,slaveAddr|I2C_WR);	/* 此处是写指令 */
000012  4639              MOV      r1,r7
000014  9801              LDR      r0,[sp,#4]
000016  f7fffffe          BL       i2c_SendByte
;;;343    				
;;;344    	/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;345    	if (i2c_WaitAck(ops)!= 0)
00001a  9801              LDR      r0,[sp,#4]
00001c  f7fffffe          BL       i2c_WaitAck
000020  2800              CMP      r0,#0
000022  d112              BNE      |L5.74|
;;;346    	{
;;;347    			goto cmd_fail;
;;;348    	}
;;;349    
;;;350    	i2c_SendByte(ops,(uint8_t)regAddr);
000024  4631              MOV      r1,r6
000026  9801              LDR      r0,[sp,#4]
000028  f7fffffe          BL       i2c_SendByte
;;;351    	/* 第5步：等待ACK */
;;;352    	if (i2c_WaitAck(ops) != 0)
00002c  9801              LDR      r0,[sp,#4]
00002e  f7fffffe          BL       i2c_WaitAck
000032  2800              CMP      r0,#0
000034  d109              BNE      |L5.74|
000036  e00f              B        |L5.88|
                  |L5.56|
;;;353    	{
;;;354    				goto cmd_fail;	/* EEPROM器件无应答 */
;;;355    	}
;;;356      while(usize--)
;;;357      {
;;;358    		/* 第4步：开始写入数据 */
;;;359    		i2c_SendByte(ops,*pBuffer);
000038  7821              LDRB     r1,[r4,#0]
00003a  9801              LDR      r0,[sp,#4]
00003c  f7fffffe          BL       i2c_SendByte
;;;360    
;;;361    		/* 第5步：检查ACK */
;;;362    		if (i2c_WaitAck(ops) != 0)
000040  9801              LDR      r0,[sp,#4]
000042  f7fffffe          BL       i2c_WaitAck
000046  2800              CMP      r0,#0
000048  d005              BEQ      |L5.86|
                  |L5.74|
;;;363    		{
;;;364    			goto cmd_fail;	/* 器件无应答 */
;;;365    		}
;;;366      
;;;367          pBuffer++;	/* 地址增1 */		
;;;368      }
;;;369    	/* 命令执行成功，发送I2C总线停止信号 */
;;;370    	i2c_Stop(ops);
;;;371    	return I2C_SUCCESS;
;;;372    
;;;373    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;374    	/* 发送I2C总线停止信号 */
;;;375    	i2c_Stop(ops);
00004a  9801              LDR      r0,[sp,#4]
00004c  f7fffffe          BL       i2c_Stop
;;;376    	return I2C_FAIL;
000050  2001              MOVS     r0,#1
                  |L5.82|
;;;377    
;;;378    }
000052  b005              ADD      sp,sp,#0x14
000054  bdf0              POP      {r4-r7,pc}
                  |L5.86|
000056  1c64              ADDS     r4,r4,#1              ;367
                  |L5.88|
000058  4628              MOV      r0,r5                 ;356
00005a  1e6d              SUBS     r5,r5,#1              ;356
00005c  b2ad              UXTH     r5,r5                 ;356
00005e  2800              CMP      r0,#0                 ;356
000060  d1ea              BNE      |L5.56|
000062  9801              LDR      r0,[sp,#4]            ;370
000064  f7fffffe          BL       i2c_Stop
000068  2000              MOVS     r0,#0                 ;371
00006a  e7f2              B        |L5.82|
;;;379    /*
                          ENDP


                          AREA ||i.I2C_WriteCmds||, CODE, READONLY, ALIGN=1

                  I2C_WriteCmds PROC
;;;285    */
;;;286    uint8_t I2C_WriteCmds(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint8_t* pBuffer,uint16_t usize)
000000  b5f8              PUSH     {r3-r7,lr}
;;;287    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
000006  4615              MOV      r5,r2
000008  461c              MOV      r4,r3
;;;288    	/* 第1步：发起I2C总线启动信号 */
;;;289    	i2c_Start(ops);
00000a  4630              MOV      r0,r6
00000c  f7fffffe          BL       i2c_Start
;;;290    				
;;;291    	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;292    	i2c_SendByte(ops,slaveAddr|I2C_WR);	/* 此处是写指令 */
000010  4639              MOV      r1,r7
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       i2c_SendByte
;;;293    				
;;;294    	/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;295    	if (i2c_WaitAck(ops)!= 0)
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       i2c_WaitAck
00001e  2800              CMP      r0,#0
000020  d109              BNE      |L6.54|
000022  e00e              B        |L6.66|
                  |L6.36|
;;;296    	{
;;;297    			goto cmd_fail;
;;;298    	}
;;;299      while(usize--)
;;;300      {
;;;301    		/* 第4步：开始写入数据 */
;;;302    		i2c_SendByte(ops,*pBuffer);
000024  7829              LDRB     r1,[r5,#0]
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       i2c_SendByte
;;;303    
;;;304    		/* 第5步：检查ACK */
;;;305    		if (i2c_WaitAck(ops) != 0)
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       i2c_WaitAck
000032  2800              CMP      r0,#0
000034  d004              BEQ      |L6.64|
                  |L6.54|
;;;306    		{
;;;307    			goto cmd_fail;	/* 器件无应答 */
;;;308    		}
;;;309      
;;;310          pBuffer++;	/* 地址增1 */		
;;;311      }
;;;312    	/* 命令执行成功，发送I2C总线停止信号 */
;;;313    	i2c_Stop(ops);
;;;314    	return I2C_SUCCESS;
;;;315    
;;;316    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;317    	/* 发送I2C总线停止信号 */
;;;318    	i2c_Stop(ops);
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       i2c_Stop
;;;319    	return I2C_FAIL;
00003c  2001              MOVS     r0,#1
;;;320    
;;;321    }
00003e  bdf8              POP      {r3-r7,pc}
                  |L6.64|
000040  1c6d              ADDS     r5,r5,#1              ;310
                  |L6.66|
000042  4620              MOV      r0,r4                 ;299
000044  1e64              SUBS     r4,r4,#1              ;299
000046  b2a4              UXTH     r4,r4                 ;299
000048  2800              CMP      r0,#0                 ;299
00004a  d1eb              BNE      |L6.36|
00004c  4630              MOV      r0,r6                 ;313
00004e  f7fffffe          BL       i2c_Stop
000052  2000              MOVS     r0,#0                 ;314
000054  bdf8              POP      {r3-r7,pc}
;;;322    
                          ENDP


                          AREA ||i.SoftI2C_Init||, CODE, READONLY, ALIGN=1

                  SoftI2C_Init PROC
;;;52     */
;;;53     void SoftI2C_Init(SoftI2C_Typedef *ops)
000000  b510              PUSH     {r4,lr}
;;;54     {
000002  4604              MOV      r4,r0
;;;55     //		ops->delay=i2c_delay;
;;;56     		GPIO_SET_OUTPUT_MODE(ops->pin_scl);
000004  8820              LDRH     r0,[r4,#0]
000006  f7fffffe          BL       GPIO_SET_OUTPUT_MODE
;;;57     		GPIO_SET_OUTPUT_MODE(ops->pin_sda);
00000a  8860              LDRH     r0,[r4,#2]
00000c  f7fffffe          BL       GPIO_SET_OUTPUT_MODE
;;;58         i2c_Stop(ops);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       i2c_Stop
;;;59     
;;;60     }
000016  bd10              POP      {r4,pc}
;;;61     
                          ENDP


                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=1

                  i2c_Ack PROC
;;;218    */
;;;219    void i2c_Ack(SoftI2C_Typedef *ops)
000000  b510              PUSH     {r4,lr}
;;;220    {
000002  4604              MOV      r4,r0
;;;221        SDA_L;  /* CPU驱动SDA = 0 */
000004  8860              LDRH     r0,[r4,#2]
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       i2c_set_pin
;;;222       // ops->delay(ops->delay_time);
;;;223        SCL_H; /* CPU产生1个时钟 */
00000c  8820              LDRH     r0,[r4,#0]
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       i2c_set_pin
;;;224      //  ops->delay(ops->delay_time);
;;;225        SCL_L;
000014  8820              LDRH     r0,[r4,#0]
000016  2100              MOVS     r1,#0
000018  f7fffffe          BL       i2c_set_pin
;;;226      //  ops->delay(ops->delay_time);
;;;227        SDA_H;  /* CPU释放SDA总线 */
00001c  8860              LDRH     r0,[r4,#2]
00001e  2101              MOVS     r1,#1
000020  f7fffffe          BL       i2c_set_pin
;;;228    }
000024  bd10              POP      {r4,pc}
;;;229    
                          ENDP


                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=1

                  i2c_CheckDevice PROC
;;;255    */
;;;256    uint8_t i2c_CheckDevice(SoftI2C_Typedef *ops,uint8_t _Address)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;258    	uint8_t ucAck;
;;;259    
;;;260    
;;;261    		i2c_Start(ops);		/* 发送启动信号 */
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       i2c_Start
;;;262    
;;;263    		/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;264    		i2c_SendByte(ops,_Address | 0);
00000c  4621              MOV      r1,r4
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       i2c_SendByte
;;;265    		ucAck = i2c_WaitAck(ops);	/* 检测设备的ACK应答 */
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       i2c_WaitAck
00001a  4604              MOV      r4,r0
;;;266    
;;;267    		i2c_Stop(ops);			/* 发送停止信号 */
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       i2c_Stop
;;;268    
;;;269    		return ucAck;
000022  4620              MOV      r0,r4
;;;270    }
000024  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=1

                  i2c_NAck PROC
;;;237    */
;;;238    void i2c_NAck(SoftI2C_Typedef *ops)
000000  b510              PUSH     {r4,lr}
;;;239    {
000002  4604              MOV      r4,r0
;;;240        SDA_H; /* CPU驱动SDA = 1 */
000004  8860              LDRH     r0,[r4,#2]
000006  2101              MOVS     r1,#1
000008  f7fffffe          BL       i2c_set_pin
;;;241      //  ops->delay(ops->delay_time);
;;;242        SCL_H; /* CPU产生1个时钟 */
00000c  8820              LDRH     r0,[r4,#0]
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       i2c_set_pin
;;;243      //  ops->delay(ops->delay_time);
;;;244        SCL_L;
000014  8820              LDRH     r0,[r4,#0]
000016  2100              MOVS     r1,#0
000018  f7fffffe          BL       i2c_set_pin
;;;245      //  ops->delay(ops->delay_time);
;;;246    }
00001c  bd10              POP      {r4,pc}
;;;247    
                          ENDP


                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=1

                  i2c_ReadByte PROC
;;;144    */
;;;145    uint8_t i2c_ReadByte(SoftI2C_Typedef *ops)
000000  b570              PUSH     {r4-r6,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147        uint8_t i;
;;;148        uint8_t value;
;;;149    
;;;150        /* 读到第1个bit为数据的bit7 */
;;;151        value = 0;
000004  2500              MOVS     r5,#0
;;;152        for (i = 0; i < 8; i++)
000006  2600              MOVS     r6,#0
                  |L11.8|
;;;153        {
;;;154            value <<= 1;
000008  0668              LSLS     r0,r5,#25
00000a  0e05              LSRS     r5,r0,#24
;;;155            SCL_H;
00000c  8820              LDRH     r0,[r4,#0]
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       i2c_set_pin
;;;156        //    ops->delay(ops->delay_time);
;;;157    			GPIO_SET_INPUT_MODE(ops->pin_sda);
000014  8860              LDRH     r0,[r4,#2]
000016  f7fffffe          BL       GPIO_SET_INPUT_MODE
;;;158            if (SDA_IN)
00001a  8860              LDRH     r0,[r4,#2]
00001c  f7fffffe          BL       i2c_get_pin
000020  2800              CMP      r0,#0
000022  d001              BEQ      |L11.40|
;;;159            {
;;;160                value++;
000024  1c6d              ADDS     r5,r5,#1
000026  b2ed              UXTB     r5,r5
                  |L11.40|
;;;161            }
;;;162            SCL_L;
000028  8820              LDRH     r0,[r4,#0]
00002a  2100              MOVS     r1,#0
00002c  f7fffffe          BL       i2c_set_pin
;;;163    				GPIO_SET_OUTPUT_MODE(ops->pin_sda);
000030  8860              LDRH     r0,[r4,#2]
000032  f7fffffe          BL       GPIO_SET_OUTPUT_MODE
000036  1c76              ADDS     r6,r6,#1              ;152
000038  b2f6              UXTB     r6,r6                 ;152
00003a  2e08              CMP      r6,#8                 ;152
00003c  d3e4              BCC      |L11.8|
;;;164       //     ops->delay(ops->delay_time);
;;;165        }
;;;166        return value;
00003e  4628              MOV      r0,r5
;;;167    }
000040  bd70              POP      {r4-r6,pc}
;;;168    
                          ENDP


                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=1

                  i2c_SendByte PROC
;;;108    */
;;;109    void i2c_SendByte(SoftI2C_Typedef *ops,uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;110    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;111        uint8_t i;
;;;112    
;;;113        /* 先发送字节的高位bit7 */
;;;114        for (i = 0; i < 8; i++)
000006  2500              MOVS     r5,#0
                  |L12.8|
;;;115        {
;;;116            if (_ucByte & 0x80)
000008  0630              LSLS     r0,r6,#24
00000a  d504              BPL      |L12.22|
;;;117            {
;;;118                SDA_H;
00000c  8860              LDRH     r0,[r4,#2]
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       i2c_set_pin
000014  e003              B        |L12.30|
                  |L12.22|
;;;119            }
;;;120            else
;;;121            {
;;;122                SDA_L;
000016  8860              LDRH     r0,[r4,#2]
000018  2100              MOVS     r1,#0
00001a  f7fffffe          BL       i2c_set_pin
                  |L12.30|
;;;123            }
;;;124    		//		ops->delay(ops->delay_time);
;;;125            SCL_H;
00001e  8820              LDRH     r0,[r4,#0]
000020  2101              MOVS     r1,#1
000022  f7fffffe          BL       i2c_set_pin
;;;126        //    ops->delay(ops->delay_time);
;;;127            SCL_L;
000026  8820              LDRH     r0,[r4,#0]
000028  2100              MOVS     r1,#0
00002a  f7fffffe          BL       i2c_set_pin
;;;128            if (i == 7)
00002e  2d07              CMP      r5,#7
000030  d103              BNE      |L12.58|
;;;129            {
;;;130                 SDA_H; // 释放总线
000032  8860              LDRH     r0,[r4,#2]
000034  2101              MOVS     r1,#1
000036  f7fffffe          BL       i2c_set_pin
                  |L12.58|
;;;131            }
;;;132            _ucByte <<= 1; /* 左移一个bit */
00003a  0670              LSLS     r0,r6,#25
00003c  0e06              LSRS     r6,r0,#24
00003e  1c6d              ADDS     r5,r5,#1              ;114
000040  b2ed              UXTB     r5,r5                 ;114
000042  2d08              CMP      r5,#8                 ;114
000044  d3e0              BCC      |L12.8|
;;;133    
;;;134        }
;;;135    }
000046  bd70              POP      {r4-r6,pc}
;;;136    
                          ENDP


                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=1

                  i2c_Start PROC
;;;70     */
;;;71     void i2c_Start(SoftI2C_Typedef *ops)
000000  b510              PUSH     {r4,lr}
;;;72     {
000002  4604              MOV      r4,r0
;;;73         /* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;74     		SDA_H;
000004  8860              LDRH     r0,[r4,#2]
000006  2101              MOVS     r1,#1
000008  f7fffffe          BL       i2c_set_pin
;;;75     		SCL_H;
00000c  8820              LDRH     r0,[r4,#0]
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       i2c_set_pin
;;;76     	//	ops->delay(ops->delay_time);
;;;77     		SDA_L;
000014  8860              LDRH     r0,[r4,#2]
000016  2100              MOVS     r1,#0
000018  f7fffffe          BL       i2c_set_pin
;;;78     	//	ops->delay(ops->delay_time);
;;;79     		SCL_L;
00001c  8820              LDRH     r0,[r4,#0]
00001e  2100              MOVS     r1,#0
000020  f7fffffe          BL       i2c_set_pin
;;;80     	//	ops->delay(ops->delay_time);
;;;81     }
000024  bd10              POP      {r4,pc}
;;;82     
                          ENDP


                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=1

                  i2c_Stop PROC
;;;90     */
;;;91     void i2c_Stop(SoftI2C_Typedef *ops)
000000  b510              PUSH     {r4,lr}
;;;92     {
000002  4604              MOV      r4,r0
;;;93         /* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;94         SDA_L;
000004  8860              LDRH     r0,[r4,#2]
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       i2c_set_pin
;;;95         SCL_H;
00000c  8820              LDRH     r0,[r4,#0]
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       i2c_set_pin
;;;96       //  ops->delay(ops->delay_time);
;;;97         SDA_H;
000014  8860              LDRH     r0,[r4,#2]
000016  2101              MOVS     r1,#1
000018  f7fffffe          BL       i2c_set_pin
;;;98       //  ops->delay(ops->delay_time);
;;;99     }
00001c  bd10              POP      {r4,pc}
;;;100    
                          ENDP


                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=1

                  i2c_WaitAck PROC
;;;176    */
;;;177    uint8_t i2c_WaitAck(SoftI2C_Typedef *ops)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {
000002  4604              MOV      r4,r0
;;;179        uint8_t re;
;;;180    
;;;181        SDA_H; /* CPU释放SDA总线 */
000004  8860              LDRH     r0,[r4,#2]
000006  2101              MOVS     r1,#1
000008  f7fffffe          BL       i2c_set_pin
;;;182      //  ops->delay(ops->delay_time);
;;;183        SCL_H; /* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
00000c  8820              LDRH     r0,[r4,#0]
00000e  2101              MOVS     r1,#1
000010  f7fffffe          BL       i2c_set_pin
;;;184      //  ops->delay(ops->delay_time);
;;;185    	GPIO_SET_INPUT_MODE(ops->pin_sda);
000014  8860              LDRH     r0,[r4,#2]
000016  f7fffffe          BL       GPIO_SET_INPUT_MODE
;;;186        if (SDA_IN) /* CPU读取SDA口线状态 */
00001a  8860              LDRH     r0,[r4,#2]
00001c  f7fffffe          BL       i2c_get_pin
000020  2800              CMP      r0,#0
000022  d001              BEQ      |L15.40|
;;;187        {
;;;188            re = 1;
000024  2501              MOVS     r5,#1
000026  e000              B        |L15.42|
                  |L15.40|
;;;189        }
;;;190        else
;;;191        {
;;;192            re = 0;
000028  2500              MOVS     r5,#0
                  |L15.42|
;;;193        }
;;;194    //		while(SDA_IN)
;;;195    //		{
;;;196    //				if(--time_out == 0)
;;;197    //				{
;;;198    //					i2c_Stop();
;;;199    //					return 1;
;;;200    //				
;;;201    //				}
;;;202    //		 ops->delay(ops->delay_time);
;;;203    //		
;;;204    //		}
;;;205        SCL_L;
00002a  8820              LDRH     r0,[r4,#0]
00002c  2100              MOVS     r1,#0
00002e  f7fffffe          BL       i2c_set_pin
;;;206    		GPIO_SET_OUTPUT_MODE(ops->pin_sda);
000032  8860              LDRH     r0,[r4,#2]
000034  f7fffffe          BL       GPIO_SET_OUTPUT_MODE
;;;207      //  ops->delay(ops->delay_time);
;;;208        return re;
000038  4628              MOV      r0,r5
;;;209    }
00003a  bd70              POP      {r4-r6,pc}
;;;210    
                          ENDP


                          AREA ||i.i2c_get_pin||, CODE, READONLY, ALIGN=1

                  i2c_get_pin PROC
;;;18     
;;;19     static uint16_t i2c_get_pin(uint16_t pin)
000000  b510              PUSH     {r4,lr}
;;;20     {
;;;21     		return GPIO_GET_PIN(pin);
000002  f7fffffe          BL       GPIO_GET_PIN
;;;22     }
000006  bd10              POP      {r4,pc}
;;;23     
                          ENDP


                          AREA ||i.i2c_master_receive||, CODE, READONLY, ALIGN=1

                  i2c_master_receive PROC
;;;659    
;;;660    uint8_t i2c_master_receive(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint8_t* pBuffer,uint16_t usize)
000000  b510              PUSH     {r4,lr}
;;;661    {	
;;;662    		uint8_t re;
;;;663    		re=I2C_ReadCmds(ops,slaveAddr,pBuffer,usize);
000002  f7fffffe          BL       I2C_ReadCmds
;;;664    		return re;
;;;665    }
000006  bd10              POP      {r4,pc}
;;;666    
                          ENDP


                          AREA ||i.i2c_master_send||, CODE, READONLY, ALIGN=1

                  i2c_master_send PROC
;;;651    /*********************************************************************************************/
;;;652    uint8_t i2c_master_send(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint8_t* pBuffer,uint16_t usize)
000000  b510              PUSH     {r4,lr}
;;;653    {
;;;654    		uint8_t re;
;;;655    		re=I2C_WriteCmds(ops,slaveAddr,pBuffer,usize);
000002  f7fffffe          BL       I2C_WriteCmds
;;;656    		return re;
;;;657    
;;;658    }
000006  bd10              POP      {r4,pc}
;;;659    
                          ENDP


                          AREA ||i.i2c_mem_read||, CODE, READONLY, ALIGN=1

                  i2c_mem_read PROC
;;;682    
;;;683    uint8_t i2c_mem_read(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint16_t regAddr,uint8_t MemAddressSize,uint8_t* pBuffer,uint16_t usize)
000000  b538              PUSH     {r3-r5,lr}
;;;684    {
000002  461d              MOV      r5,r3
000004  9c05              LDR      r4,[sp,#0x14]
000006  9b04              LDR      r3,[sp,#0x10]
;;;685    	uint8_t re;
;;;686    	if(MemAddressSize==I2C_MEMSIZE_8BIT)
000008  2d01              CMP      r5,#1
00000a  d003              BEQ      |L19.20|
;;;687    	{
;;;688    		re = I2C_Read8Bits(ops,slaveAddr,(uint8_t)regAddr,pBuffer,usize);
;;;689    	}
;;;690    	else
;;;691    	{
;;;692    		re = I2C_Read16Bits(ops,slaveAddr,(uint16_t)regAddr,pBuffer,usize);
00000c  9400              STR      r4,[sp,#0]
00000e  f7fffffe          BL       I2C_Read16Bits
;;;693    
;;;694    	}
;;;695    	return re;
;;;696    
;;;697    }
000012  bd38              POP      {r3-r5,pc}
                  |L19.20|
000014  b2d2              UXTB     r2,r2                 ;688
000016  9400              STR      r4,[sp,#0]            ;688
000018  f7fffffe          BL       I2C_Read8Bits
00001c  bd38              POP      {r3-r5,pc}
                          ENDP


                          AREA ||i.i2c_mem_write||, CODE, READONLY, ALIGN=1

                  i2c_mem_write PROC
;;;666    
;;;667    uint8_t i2c_mem_write(SoftI2C_Typedef *ops,uint8_t slaveAddr,uint16_t regAddr,uint16_t MemAddressSize,uint8_t* pBuffer,uint16_t usize)
000000  b538              PUSH     {r3-r5,lr}
;;;668    {
000002  461d              MOV      r5,r3
000004  9c05              LDR      r4,[sp,#0x14]
000006  9b04              LDR      r3,[sp,#0x10]
;;;669    	uint8_t re;
;;;670    	if(MemAddressSize==I2C_MEMSIZE_8BIT)
000008  2d01              CMP      r5,#1
00000a  d003              BEQ      |L20.20|
;;;671    	{
;;;672    		re = I2C_Write8Bits(ops,slaveAddr,(uint8_t)regAddr,pBuffer,usize);
;;;673    	}
;;;674    	else
;;;675    	{
;;;676    		re = I2C_Write16Bits(ops,slaveAddr,(uint16_t)regAddr,pBuffer,usize);
00000c  9400              STR      r4,[sp,#0]
00000e  f7fffffe          BL       I2C_Write16Bits
;;;677    
;;;678    	}
;;;679    	return re;
;;;680    
;;;681    }
000012  bd38              POP      {r3-r5,pc}
                  |L20.20|
000014  b2d2              UXTB     r2,r2                 ;672
000016  9400              STR      r4,[sp,#0]            ;672
000018  f7fffffe          BL       I2C_Write8Bits
00001c  bd38              POP      {r3-r5,pc}
;;;682    
                          ENDP


                          AREA ||i.i2c_set_pin||, CODE, READONLY, ALIGN=1

                  i2c_set_pin PROC
;;;5      
;;;6      static void i2c_set_pin(uint16_t pin,uint8_t state)
000000  b510              PUSH     {r4,lr}
;;;7      {
;;;8      	if(state)
000002  2900              CMP      r1,#0
000004  d002              BEQ      |L21.12|
;;;9      	{
;;;10     		GPIO_SET_PIN(pin);
000006  f7fffffe          BL       GPIO_SET_PIN
;;;11     	}
;;;12     	else
;;;13     	{
;;;14     		GPIO_CLR_PIN(pin);
;;;15     	}
;;;16     
;;;17     }
00000a  bd10              POP      {r4,pc}
                  |L21.12|
00000c  f7fffffe          BL       GPIO_CLR_PIN
000010  bd10              POP      {r4,pc}
;;;18     
                          ENDP


;*** Start embedded assembler ***

#line 1 "APP\\IIC\\soft_i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_soft_i2c_c_ff0913b0____REV16|
#line 492 "C:\\Users\\bbb\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___10_soft_i2c_c_ff0913b0____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_soft_i2c_c_ff0913b0____REVSH|
#line 507
|__asm___10_soft_i2c_c_ff0913b0____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
