; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\queue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\queue.d --cpu=Cortex-M0 --apcs=interwork -O1 --diag_suppress=9931 -I.\APP -I.\APP\TN2115s_libs -I.\Common\CMSIS-FreeRTOS\10.0.1\Source\include -I.\Common\RTE\RTOS -I.\Common\CMSIS-FreeRTOS\10.0.1\CMSIS\RTOS2\FreeRTOS\Include -I.\Common\CMSIS-FreeRTOS\10.0.1\Source\portable\RVDS\ARM_CM0 -I.\APP\EINK -I.\Device_desc -I.\Common\CMSIS-FreeRTOS\10.0.1\Source -I.\Common\RTE\Device\ARMCM0 -I.\RTE\_soc_m0 -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\Device\ARM\ARMCM0\Include -D__MICROLIB -D__UVISION_VERSION=529 -D_RTE_ -DARMCM0 --omf_browse=.\objects\queue.crf Common\CMSIS-FreeRTOS\10.0.1\Source\queue.c]
                          THUMB

                          AREA ||i.prvCopyDataFromQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataFromQueue PROC
;;;2118   
;;;2119   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
000000  b510              PUSH     {r4,lr}
;;;2120   {
000002  460b              MOV      r3,r1
;;;2121   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
000004  6c02              LDR      r2,[r0,#0x40]
000006  2a00              CMP      r2,#0
000008  d00b              BEQ      |L1.34|
;;;2122   	{
;;;2123   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
00000a  68c1              LDR      r1,[r0,#0xc]
00000c  1889              ADDS     r1,r1,r2
00000e  60c1              STR      r1,[r0,#0xc]
;;;2124   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
000010  6844              LDR      r4,[r0,#4]
000012  42a1              CMP      r1,r4
000014  d301              BCC      |L1.26|
;;;2125   		{
;;;2126   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
000016  6801              LDR      r1,[r0,#0]
000018  60c1              STR      r1,[r0,#0xc]
                  |L1.26|
;;;2127   		}
;;;2128   		else
;;;2129   		{
;;;2130   			mtCOVERAGE_TEST_MARKER();
;;;2131   		}
;;;2132   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
00001a  68c1              LDR      r1,[r0,#0xc]
00001c  4618              MOV      r0,r3
00001e  f7fffffe          BL       __aeabi_memcpy
                  |L1.34|
;;;2133   	}
;;;2134   }
000022  bd10              POP      {r4,pc}
;;;2135   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvCopyDataToQueue||, CODE, READONLY, ALIGN=1

                  prvCopyDataToQueue PROC
;;;2039   
;;;2040   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2041   {
000002  4604              MOV      r4,r0
000004  4616              MOV      r6,r2
;;;2042   BaseType_t xReturn = pdFALSE;
000006  2700              MOVS     r7,#0
;;;2043   UBaseType_t uxMessagesWaiting;
;;;2044   
;;;2045   	/* This function is called from a critical section. */
;;;2046   
;;;2047   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000008  6ba5              LDR      r5,[r4,#0x38]
;;;2048   
;;;2049   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
00000a  6c22              LDR      r2,[r4,#0x40]
00000c  2a00              CMP      r2,#0
00000e  d011              BEQ      |L2.52|
;;;2050   	{
;;;2051   		#if ( configUSE_MUTEXES == 1 )
;;;2052   		{
;;;2053   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;2054   			{
;;;2055   				/* The mutex is no longer being held. */
;;;2056   				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;2057   				pxQueue->pxMutexHolder = NULL;
;;;2058   			}
;;;2059   			else
;;;2060   			{
;;;2061   				mtCOVERAGE_TEST_MARKER();
;;;2062   			}
;;;2063   		}
;;;2064   		#endif /* configUSE_MUTEXES */
;;;2065   	}
;;;2066   	else if( xPosition == queueSEND_TO_BACK )
000010  2e00              CMP      r6,#0
000012  d019              BEQ      |L2.72|
;;;2067   	{
;;;2068   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
;;;2069   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
;;;2070   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
;;;2071   		{
;;;2072   			pxQueue->pcWriteTo = pxQueue->pcHead;
;;;2073   		}
;;;2074   		else
;;;2075   		{
;;;2076   			mtCOVERAGE_TEST_MARKER();
;;;2077   		}
;;;2078   	}
;;;2079   	else
;;;2080   	{
;;;2081   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000014  68e0              LDR      r0,[r4,#0xc]
000016  f7fffffe          BL       __aeabi_memcpy
;;;2082   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
00001a  68e1              LDR      r1,[r4,#0xc]
00001c  6c20              LDR      r0,[r4,#0x40]
00001e  1a09              SUBS     r1,r1,r0
000020  60e1              STR      r1,[r4,#0xc]
;;;2083   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
000022  6822              LDR      r2,[r4,#0]
000024  4291              CMP      r1,r2
000026  d202              BCS      |L2.46|
;;;2084   		{
;;;2085   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000028  6861              LDR      r1,[r4,#4]
00002a  1a08              SUBS     r0,r1,r0
00002c  60e0              STR      r0,[r4,#0xc]
                  |L2.46|
;;;2086   		}
;;;2087   		else
;;;2088   		{
;;;2089   			mtCOVERAGE_TEST_MARKER();
;;;2090   		}
;;;2091   
;;;2092   		if( xPosition == queueOVERWRITE )
00002e  2e02              CMP      r6,#2
000030  d017              BEQ      |L2.98|
000032  e019              B        |L2.104|
                  |L2.52|
000034  6820              LDR      r0,[r4,#0]            ;2053
000036  2800              CMP      r0,#0                 ;2053
000038  d116              BNE      |L2.104|
00003a  6860              LDR      r0,[r4,#4]            ;2056
00003c  f7fffffe          BL       xTaskPriorityDisinherit
000040  4607              MOV      r7,r0                 ;2056
000042  2000              MOVS     r0,#0                 ;2057
000044  6060              STR      r0,[r4,#4]            ;2057
000046  e00f              B        |L2.104|
                  |L2.72|
000048  68a0              LDR      r0,[r4,#8]            ;2068
00004a  f7fffffe          BL       __aeabi_memcpy
00004e  6c21              LDR      r1,[r4,#0x40]         ;2069
000050  68a0              LDR      r0,[r4,#8]            ;2069
000052  1840              ADDS     r0,r0,r1              ;2069
000054  60a0              STR      r0,[r4,#8]            ;2069
000056  6861              LDR      r1,[r4,#4]            ;2070
000058  4288              CMP      r0,r1                 ;2070
00005a  d305              BCC      |L2.104|
00005c  6820              LDR      r0,[r4,#0]            ;2072
00005e  60a0              STR      r0,[r4,#8]            ;2072
000060  e002              B        |L2.104|
                  |L2.98|
;;;2093   		{
;;;2094   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000062  2d00              CMP      r5,#0
000064  d000              BEQ      |L2.104|
;;;2095   			{
;;;2096   				/* An item is not being added but overwritten, so subtract
;;;2097   				one from the recorded number of items in the queue so when
;;;2098   				one is added again below the number of recorded items remains
;;;2099   				correct. */
;;;2100   				--uxMessagesWaiting;
000066  1e6d              SUBS     r5,r5,#1
                  |L2.104|
;;;2101   			}
;;;2102   			else
;;;2103   			{
;;;2104   				mtCOVERAGE_TEST_MARKER();
;;;2105   			}
;;;2106   		}
;;;2107   		else
;;;2108   		{
;;;2109   			mtCOVERAGE_TEST_MARKER();
;;;2110   		}
;;;2111   	}
;;;2112   
;;;2113   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
000068  1c6d              ADDS     r5,r5,#1
00006a  63a5              STR      r5,[r4,#0x38]
;;;2114   
;;;2115   	return xReturn;
00006c  4638              MOV      r0,r7
;;;2116   }
00006e  bdf8              POP      {r3-r7,pc}
;;;2117   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvGetDisinheritPriorityAfterTimeout||, CODE, READONLY, ALIGN=1

                  prvGetDisinheritPriorityAfterTimeout PROC
;;;2014   
;;;2015   	static UBaseType_t prvGetDisinheritPriorityAfterTimeout( const Queue_t * const pxQueue )
000000  6a41              LDR      r1,[r0,#0x24]
;;;2016   	{
;;;2017   	UBaseType_t uxHighestPriorityOfWaitingTasks;
;;;2018   
;;;2019   		/* If a task waiting for a mutex causes the mutex holder to inherit a
;;;2020   		priority, but the waiting task times out, then the holder should
;;;2021   		disinherit the priority - but only down to the highest priority of any
;;;2022   		other tasks that are waiting for the same mutex.  For this purpose,
;;;2023   		return the priority of the highest priority task that is waiting for the
;;;2024   		mutex. */
;;;2025   		if( listCURRENT_LIST_LENGTH( &( pxQueue->xTasksWaitingToReceive ) ) > 0 )
000002  2900              CMP      r1,#0
000004  d004              BEQ      |L3.16|
;;;2026   		{
;;;2027   			uxHighestPriorityOfWaitingTasks = configMAX_PRIORITIES - listGET_ITEM_VALUE_OF_HEAD_ENTRY( &( pxQueue->xTasksWaitingToReceive ) );
000006  6b00              LDR      r0,[r0,#0x30]
000008  210c              MOVS     r1,#0xc
00000a  6800              LDR      r0,[r0,#0]
00000c  1a08              SUBS     r0,r1,r0
;;;2028   		}
;;;2029   		else
;;;2030   		{
;;;2031   			uxHighestPriorityOfWaitingTasks = tskIDLE_PRIORITY;
;;;2032   		}
;;;2033   
;;;2034   		return uxHighestPriorityOfWaitingTasks;
;;;2035   	}
00000e  4770              BX       lr
                  |L3.16|
000010  2000              MOVS     r0,#0                 ;2031
000012  4770              BX       lr
;;;2036   
                          ENDP


                          AREA ||i.prvInitialiseMutex||, CODE, READONLY, ALIGN=1

                  prvInitialiseMutex PROC
;;;451    
;;;452    	static void prvInitialiseMutex( Queue_t *pxNewQueue )
000000  b510              PUSH     {r4,lr}
;;;453    	{
;;;454    		if( pxNewQueue != NULL )
000002  2800              CMP      r0,#0
000004  d008              BEQ      |L4.24|
;;;455    		{
;;;456    			/* The queue create function will set all the queue structure members
;;;457    			correctly for a generic queue, but this function is creating a
;;;458    			mutex.  Overwrite those members that need to be set differently -
;;;459    			in particular the information required for priority inheritance. */
;;;460    			pxNewQueue->pxMutexHolder = NULL;
000006  2100              MOVS     r1,#0
000008  6041              STR      r1,[r0,#4]
;;;461    			pxNewQueue->uxQueueType = queueQUEUE_IS_MUTEX;
00000a  6001              STR      r1,[r0,#0]
;;;462    
;;;463    			/* In case this is a recursive mutex. */
;;;464    			pxNewQueue->u.uxRecursiveCallCount = 0;
00000c  60c1              STR      r1,[r0,#0xc]
;;;465    
;;;466    			traceCREATE_MUTEX( pxNewQueue );
;;;467    
;;;468    			/* Start with the semaphore in the expected state. */
;;;469    			( void ) xQueueGenericSend( pxNewQueue, NULL, ( TickType_t ) 0U, queueSEND_TO_BACK );
00000e  2300              MOVS     r3,#0
000010  461a              MOV      r2,r3
000012  4619              MOV      r1,r3
000014  f7fffffe          BL       xQueueGenericSend
                  |L4.24|
;;;470    		}
;;;471    		else
;;;472    		{
;;;473    			traceCREATE_MUTEX_FAILED();
;;;474    		}
;;;475    	}
000018  bd10              POP      {r4,pc}
;;;476    
                          ENDP


                          AREA ||i.prvInitialiseNewQueue||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewQueue PROC
;;;407    
;;;408    static void prvInitialiseNewQueue( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, const uint8_t ucQueueType, Queue_t *pxNewQueue )
000000  b510              PUSH     {r4,lr}
;;;409    {
000002  4603              MOV      r3,r0
000004  9802              LDR      r0,[sp,#8]
;;;410    	/* Remove compiler warnings about unused parameters should
;;;411    	configUSE_TRACE_FACILITY not be set to 1. */
;;;412    	( void ) ucQueueType;
;;;413    
;;;414    	if( uxItemSize == ( UBaseType_t ) 0 )
000006  2900              CMP      r1,#0
000008  d006              BEQ      |L5.24|
;;;415    	{
;;;416    		/* No RAM was allocated for the queue storage area, but PC head cannot
;;;417    		be set to NULL because NULL is used as a key to say the queue is used as
;;;418    		a mutex.  Therefore just set pcHead to point to the queue as a benign
;;;419    		value that is known to be within the memory map. */
;;;420    		pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
;;;421    	}
;;;422    	else
;;;423    	{
;;;424    		/* Set the head to the start of the queue storage area. */
;;;425    		pxNewQueue->pcHead = ( int8_t * ) pucQueueStorage;
00000a  6002              STR      r2,[r0,#0]
                  |L5.12|
;;;426    	}
;;;427    
;;;428    	/* Initialise the queue members as described where the queue type is
;;;429    	defined. */
;;;430    	pxNewQueue->uxLength = uxQueueLength;
00000c  63c3              STR      r3,[r0,#0x3c]
;;;431    	pxNewQueue->uxItemSize = uxItemSize;
00000e  6401              STR      r1,[r0,#0x40]
;;;432    	( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
000010  2101              MOVS     r1,#1
000012  f7fffffe          BL       xQueueGenericReset
;;;433    
;;;434    	#if ( configUSE_TRACE_FACILITY == 1 )
;;;435    	{
;;;436    		pxNewQueue->ucQueueType = ucQueueType;
;;;437    	}
;;;438    	#endif /* configUSE_TRACE_FACILITY */
;;;439    
;;;440    	#if( configUSE_QUEUE_SETS == 1 )
;;;441    	{
;;;442    		pxNewQueue->pxQueueSetContainer = NULL;
;;;443    	}
;;;444    	#endif /* configUSE_QUEUE_SETS */
;;;445    
;;;446    	traceQUEUE_CREATE( pxNewQueue );
;;;447    }
000016  bd10              POP      {r4,pc}
                  |L5.24|
000018  6000              STR      r0,[r0,#0]            ;420
00001a  e7f7              B        |L5.12|
;;;448    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueEmpty||, CODE, READONLY, ALIGN=1

                  prvIsQueueEmpty PROC
;;;2256   
;;;2257   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000000  b510              PUSH     {r4,lr}
;;;2258   {
000002  4604              MOV      r4,r0
;;;2259   BaseType_t xReturn;
;;;2260   
;;;2261   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2262   	{
;;;2263   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000008  6ba0              LDR      r0,[r4,#0x38]
00000a  2800              CMP      r0,#0
00000c  d004              BEQ      |L6.24|
;;;2264   		{
;;;2265   			xReturn = pdTRUE;
;;;2266   		}
;;;2267   		else
;;;2268   		{
;;;2269   			xReturn = pdFALSE;
00000e  2400              MOVS     r4,#0
                  |L6.16|
;;;2270   		}
;;;2271   	}
;;;2272   	taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;2273   
;;;2274   	return xReturn;
000014  4620              MOV      r0,r4
;;;2275   }
000016  bd10              POP      {r4,pc}
                  |L6.24|
000018  2401              MOVS     r4,#1                 ;2265
00001a  e7f9              B        |L6.16|
;;;2276   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvIsQueueFull||, CODE, READONLY, ALIGN=1

                  prvIsQueueFull PROC
;;;2295   
;;;2296   static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
000000  b510              PUSH     {r4,lr}
;;;2297   {
000002  4604              MOV      r4,r0
;;;2298   BaseType_t xReturn;
;;;2299   
;;;2300   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2301   	{
;;;2302   		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
000008  6ba0              LDR      r0,[r4,#0x38]
00000a  6be1              LDR      r1,[r4,#0x3c]
00000c  4288              CMP      r0,r1
00000e  d101              BNE      |L7.20|
;;;2303   		{
;;;2304   			xReturn = pdTRUE;
000010  2401              MOVS     r4,#1
000012  e000              B        |L7.22|
                  |L7.20|
;;;2305   		}
;;;2306   		else
;;;2307   		{
;;;2308   			xReturn = pdFALSE;
000014  2400              MOVS     r4,#0
                  |L7.22|
;;;2309   		}
;;;2310   	}
;;;2311   	taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;2312   
;;;2313   	return xReturn;
00001a  4620              MOV      r0,r4
;;;2314   }
00001c  bd10              POP      {r4,pc}
;;;2315   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvUnlockQueue||, CODE, READONLY, ALIGN=1

                  prvUnlockQueue PROC
;;;2136   
;;;2137   static void prvUnlockQueue( Queue_t * const pxQueue )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2138   {
000002  4604              MOV      r4,r0
;;;2139   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;2140   
;;;2141   	/* The lock counts contains the number of extra data items placed or
;;;2142   	removed from the queue while the queue was locked.  When a queue is
;;;2143   	locked items can be added or removed, but the event lists cannot be
;;;2144   	updated. */
;;;2145   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;2146   	{
;;;2147   		int8_t cTxLock = pxQueue->cTxLock;
000008  4626              MOV      r6,r4
00000a  3640              ADDS     r6,r6,#0x40
00000c  2505              MOVS     r5,#5
00000e  5775              LDRSB    r5,[r6,r5]
;;;2148   
;;;2149   		/* See if data was added to the queue while it was locked. */
;;;2150   		while( cTxLock > queueLOCKED_UNMODIFIED )
;;;2151   		{
;;;2152   			/* Data was posted while the queue was locked.  Are any tasks
;;;2153   			blocked waiting for data to become available? */
;;;2154   			#if ( configUSE_QUEUE_SETS == 1 )
;;;2155   			{
;;;2156   				if( pxQueue->pxQueueSetContainer != NULL )
;;;2157   				{
;;;2158   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;2159   					{
;;;2160   						/* The queue is a member of a queue set, and posting to
;;;2161   						the queue set caused a higher priority task to unblock.
;;;2162   						A context switch is required. */
;;;2163   						vTaskMissedYield();
;;;2164   					}
;;;2165   					else
;;;2166   					{
;;;2167   						mtCOVERAGE_TEST_MARKER();
;;;2168   					}
;;;2169   				}
;;;2170   				else
;;;2171   				{
;;;2172   					/* Tasks that are removed from the event list will get
;;;2173   					added to the pending ready list as the scheduler is still
;;;2174   					suspended. */
;;;2175   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2176   					{
;;;2177   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;2178   						{
;;;2179   							/* The task waiting has a higher priority so record that a
;;;2180   							context	switch is required. */
;;;2181   							vTaskMissedYield();
;;;2182   						}
;;;2183   						else
;;;2184   						{
;;;2185   							mtCOVERAGE_TEST_MARKER();
;;;2186   						}
;;;2187   					}
;;;2188   					else
;;;2189   					{
;;;2190   						break;
;;;2191   					}
;;;2192   				}
;;;2193   			}
;;;2194   			#else /* configUSE_QUEUE_SETS */
;;;2195   			{
;;;2196   				/* Tasks that are removed from the event list will get added to
;;;2197   				the pending ready list as the scheduler is still suspended. */
;;;2198   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;2199   				{
;;;2200   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000010  4627              MOV      r7,r4
000012  3724              ADDS     r7,r7,#0x24
000014  e00b              B        |L8.46|
                  |L8.22|
000016  6a60              LDR      r0,[r4,#0x24]         ;2198
000018  2800              CMP      r0,#0                 ;2198
00001a  d00a              BEQ      |L8.50|
00001c  4638              MOV      r0,r7
00001e  f7fffffe          BL       xTaskRemoveFromEventList
000022  2800              CMP      r0,#0
000024  d001              BEQ      |L8.42|
;;;2201   					{
;;;2202   						/* The task waiting has a higher priority so record that
;;;2203   						a context switch is required. */
;;;2204   						vTaskMissedYield();
000026  f7fffffe          BL       vTaskMissedYield
                  |L8.42|
;;;2205   					}
;;;2206   					else
;;;2207   					{
;;;2208   						mtCOVERAGE_TEST_MARKER();
;;;2209   					}
;;;2210   				}
;;;2211   				else
;;;2212   				{
;;;2213   					break;
;;;2214   				}
;;;2215   			}
;;;2216   			#endif /* configUSE_QUEUE_SETS */
;;;2217   
;;;2218   			--cTxLock;
00002a  1e6d              SUBS     r5,r5,#1
00002c  b26d              SXTB     r5,r5
                  |L8.46|
00002e  2d00              CMP      r5,#0                 ;2150
000030  dcf1              BGT      |L8.22|
                  |L8.50|
;;;2219   		}
;;;2220   
;;;2221   		pxQueue->cTxLock = queueUNLOCKED;
000032  2700              MOVS     r7,#0
000034  43ff              MVNS     r7,r7
000036  7177              STRB     r7,[r6,#5]
;;;2222   	}
;;;2223   	taskEXIT_CRITICAL();
000038  f7fffffe          BL       vPortExitCritical
;;;2224   
;;;2225   	/* Do the same for the Rx lock. */
;;;2226   	taskENTER_CRITICAL();
00003c  f7fffffe          BL       vPortEnterCritical
;;;2227   	{
;;;2228   		int8_t cRxLock = pxQueue->cRxLock;
000040  2504              MOVS     r5,#4
000042  5775              LDRSB    r5,[r6,r5]
;;;2229   
;;;2230   		while( cRxLock > queueLOCKED_UNMODIFIED )
;;;2231   		{
;;;2232   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;2233   			{
;;;2234   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000044  4620              MOV      r0,r4
000046  3010              ADDS     r0,r0,#0x10
000048  9000              STR      r0,[sp,#0]            ;2213
00004a  e00b              B        |L8.100|
                  |L8.76|
00004c  6920              LDR      r0,[r4,#0x10]         ;2232
00004e  2800              CMP      r0,#0                 ;2232
000050  d00a              BEQ      |L8.104|
000052  9800              LDR      r0,[sp,#0]
000054  f7fffffe          BL       xTaskRemoveFromEventList
000058  2800              CMP      r0,#0
00005a  d001              BEQ      |L8.96|
;;;2235   				{
;;;2236   					vTaskMissedYield();
00005c  f7fffffe          BL       vTaskMissedYield
                  |L8.96|
;;;2237   				}
;;;2238   				else
;;;2239   				{
;;;2240   					mtCOVERAGE_TEST_MARKER();
;;;2241   				}
;;;2242   
;;;2243   				--cRxLock;
000060  1e6d              SUBS     r5,r5,#1
000062  b26d              SXTB     r5,r5
                  |L8.100|
000064  2d00              CMP      r5,#0                 ;2230
000066  dcf1              BGT      |L8.76|
                  |L8.104|
;;;2244   			}
;;;2245   			else
;;;2246   			{
;;;2247   				break;
;;;2248   			}
;;;2249   		}
;;;2250   
;;;2251   		pxQueue->cRxLock = queueUNLOCKED;
000068  7137              STRB     r7,[r6,#4]
;;;2252   	}
;;;2253   	taskEXIT_CRITICAL();
00006a  f7fffffe          BL       vPortExitCritical
;;;2254   }
00006e  bdf8              POP      {r3-r7,pc}
;;;2255   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaiting||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaiting PROC
;;;1894   
;;;1895   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1896   {
000002  4604              MOV      r4,r0
;;;1897   UBaseType_t uxReturn;
;;;1898   
;;;1899   	configASSERT( xQueue );
;;;1900   
;;;1901   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1902   	{
;;;1903   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000008  6ba4              LDR      r4,[r4,#0x38]
;;;1904   	}
;;;1905   	taskEXIT_CRITICAL();
00000a  f7fffffe          BL       vPortExitCritical
;;;1906   
;;;1907   	return uxReturn;
00000e  4620              MOV      r0,r4
;;;1908   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000010  bd10              POP      {r4,pc}
;;;1909   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueMessagesWaitingFromISR||, CODE, READONLY, ALIGN=1

                  uxQueueMessagesWaitingFromISR PROC
;;;1928   
;;;1929   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
000000  6b80              LDR      r0,[r0,#0x38]
;;;1930   {
;;;1931   UBaseType_t uxReturn;
;;;1932   
;;;1933   	configASSERT( xQueue );
;;;1934   
;;;1935   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
;;;1936   
;;;1937   	return uxReturn;
;;;1938   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000002  4770              BX       lr
;;;1939   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.uxQueueSpacesAvailable||, CODE, READONLY, ALIGN=1

                  uxQueueSpacesAvailable PROC
;;;1910   
;;;1911   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1912   {
000002  4604              MOV      r4,r0
;;;1913   UBaseType_t uxReturn;
;;;1914   Queue_t *pxQueue;
;;;1915   
;;;1916   	pxQueue = ( Queue_t * ) xQueue;
;;;1917   	configASSERT( pxQueue );
;;;1918   
;;;1919   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1920   	{
;;;1921   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
000008  6ba1              LDR      r1,[r4,#0x38]
00000a  6be0              LDR      r0,[r4,#0x3c]
00000c  1a44              SUBS     r4,r0,r1
;;;1922   	}
;;;1923   	taskEXIT_CRITICAL();
00000e  f7fffffe          BL       vPortExitCritical
;;;1924   
;;;1925   	return uxReturn;
000012  4620              MOV      r0,r4
;;;1926   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000014  bd10              POP      {r4,pc}
;;;1927   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vQueueDelete||, CODE, READONLY, ALIGN=1

                  vQueueDelete PROC
;;;1940   
;;;1941   void vQueueDelete( QueueHandle_t xQueue )
000000  b510              PUSH     {r4,lr}
;;;1942   {
;;;1943   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1944   
;;;1945   	configASSERT( pxQueue );
;;;1946   	traceQUEUE_DELETE( pxQueue );
;;;1947   
;;;1948   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1949   	{
;;;1950   		vQueueUnregisterQueue( pxQueue );
;;;1951   	}
;;;1952   	#endif
;;;1953   
;;;1954   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1955   	{
;;;1956   		/* The queue can only have been allocated dynamically - free it
;;;1957   		again. */
;;;1958   		vPortFree( pxQueue );
;;;1959   	}
;;;1960   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1961   	{
;;;1962   		/* The queue could have been allocated statically or dynamically, so
;;;1963   		check before attempting to free the memory. */
;;;1964   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
000002  2146              MOVS     r1,#0x46
000004  5c09              LDRB     r1,[r1,r0]
000006  2900              CMP      r1,#0
000008  d101              BNE      |L12.14|
;;;1965   		{
;;;1966   			vPortFree( pxQueue );
00000a  f7fffffe          BL       vPortFree
                  |L12.14|
;;;1967   		}
;;;1968   		else
;;;1969   		{
;;;1970   			mtCOVERAGE_TEST_MARKER();
;;;1971   		}
;;;1972   	}
;;;1973   	#else
;;;1974   	{
;;;1975   		/* The queue must have been statically allocated, so is not going to be
;;;1976   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;1977   		( void ) pxQueue;
;;;1978   	}
;;;1979   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;1980   }
00000e  bd10              POP      {r4,pc}
;;;1981   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueCreateCountingSemaphore||, CODE, READONLY, ALIGN=1

                  xQueueCreateCountingSemaphore PROC
;;;698    
;;;699    	QueueHandle_t xQueueCreateCountingSemaphore( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount )
000000  b510              PUSH     {r4,lr}
;;;700    	{
000002  460c              MOV      r4,r1
;;;701    	QueueHandle_t xHandle;
;;;702    
;;;703    		configASSERT( uxMaxCount != 0 );
;;;704    		configASSERT( uxInitialCount <= uxMaxCount );
;;;705    
;;;706    		xHandle = xQueueGenericCreate( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000004  2202              MOVS     r2,#2
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       xQueueGenericCreate
;;;707    
;;;708    		if( xHandle != NULL )
00000c  2800              CMP      r0,#0
00000e  d000              BEQ      |L13.18|
;;;709    		{
;;;710    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
000010  6384              STR      r4,[r0,#0x38]
                  |L13.18|
;;;711    
;;;712    			traceCREATE_COUNTING_SEMAPHORE();
;;;713    		}
;;;714    		else
;;;715    		{
;;;716    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;717    		}
;;;718    
;;;719    		return xHandle;
;;;720    	}
000012  bd10              POP      {r4,pc}
;;;721    
                          ENDP


                          AREA ||i.xQueueCreateCountingSemaphoreStatic||, CODE, READONLY, ALIGN=1

                  xQueueCreateCountingSemaphoreStatic PROC
;;;670    
;;;671    	QueueHandle_t xQueueCreateCountingSemaphoreStatic( const UBaseType_t uxMaxCount, const UBaseType_t uxInitialCount, StaticQueue_t *pxStaticQueue )
000000  b538              PUSH     {r3-r5,lr}
;;;672    	{
000002  460c              MOV      r4,r1
;;;673    	QueueHandle_t xHandle;
;;;674    
;;;675    		configASSERT( uxMaxCount != 0 );
;;;676    		configASSERT( uxInitialCount <= uxMaxCount );
;;;677    
;;;678    		xHandle = xQueueGenericCreateStatic( uxMaxCount, queueSEMAPHORE_QUEUE_ITEM_LENGTH, NULL, pxStaticQueue, queueQUEUE_TYPE_COUNTING_SEMAPHORE );
000004  2102              MOVS     r1,#2
000006  4613              MOV      r3,r2
000008  2200              MOVS     r2,#0
00000a  9100              STR      r1,[sp,#0]
00000c  4611              MOV      r1,r2
00000e  f7fffffe          BL       xQueueGenericCreateStatic
;;;679    
;;;680    		if( xHandle != NULL )
000012  2800              CMP      r0,#0
000014  d000              BEQ      |L14.24|
;;;681    		{
;;;682    			( ( Queue_t * ) xHandle )->uxMessagesWaiting = uxInitialCount;
000016  6384              STR      r4,[r0,#0x38]
                  |L14.24|
;;;683    
;;;684    			traceCREATE_COUNTING_SEMAPHORE();
;;;685    		}
;;;686    		else
;;;687    		{
;;;688    			traceCREATE_COUNTING_SEMAPHORE_FAILED();
;;;689    		}
;;;690    
;;;691    		return xHandle;
;;;692    	}
000018  bd38              POP      {r3-r5,pc}
;;;693    
                          ENDP


                          AREA ||i.xQueueCreateMutex||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutex PROC
;;;481    
;;;482    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
000000  b510              PUSH     {r4,lr}
;;;483    	{
;;;484    	Queue_t *pxNewQueue;
;;;485    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
;;;486    
;;;487    		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
000002  4602              MOV      r2,r0
000004  2100              MOVS     r1,#0
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       xQueueGenericCreate
00000c  4604              MOV      r4,r0
;;;488    		prvInitialiseMutex( pxNewQueue );
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       prvInitialiseMutex
;;;489    
;;;490    		return pxNewQueue;
000014  4620              MOV      r0,r4
;;;491    	}
000016  bd10              POP      {r4,pc}
;;;492    
                          ENDP


                          AREA ||i.xQueueCreateMutexStatic||, CODE, READONLY, ALIGN=1

                  xQueueCreateMutexStatic PROC
;;;497    
;;;498    	QueueHandle_t xQueueCreateMutexStatic( const uint8_t ucQueueType, StaticQueue_t *pxStaticQueue )
000000  b538              PUSH     {r3-r5,lr}
;;;499    	{
;;;500    	Queue_t *pxNewQueue;
;;;501    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
;;;502    
;;;503    		/* Prevent compiler warnings about unused parameters if
;;;504    		configUSE_TRACE_FACILITY does not equal 1. */
;;;505    		( void ) ucQueueType;
;;;506    
;;;507    		pxNewQueue = ( Queue_t * ) xQueueGenericCreateStatic( uxMutexLength, uxMutexSize, NULL, pxStaticQueue, ucQueueType );
000002  460b              MOV      r3,r1
000004  2200              MOVS     r2,#0
000006  9000              STR      r0,[sp,#0]
000008  4611              MOV      r1,r2
00000a  2001              MOVS     r0,#1
00000c  f7fffffe          BL       xQueueGenericCreateStatic
000010  4604              MOV      r4,r0
;;;508    		prvInitialiseMutex( pxNewQueue );
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       prvInitialiseMutex
;;;509    
;;;510    		return pxNewQueue;
000018  4620              MOV      r0,r4
;;;511    	}
00001a  bd38              POP      {r3-r5,pc}
;;;512    
                          ENDP


                          AREA ||i.xQueueGenericCreate||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreate PROC
;;;357    
;;;358    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000000  b5f8              PUSH     {r3-r7,lr}
;;;359    	{
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4617              MOV      r7,r2
;;;360    	Queue_t *pxNewQueue;
;;;361    	size_t xQueueSizeInBytes;
;;;362    	uint8_t *pucQueueStorage;
;;;363    
;;;364    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
;;;365    
;;;366    		if( uxItemSize == ( UBaseType_t ) 0 )
000008  2d00              CMP      r5,#0
00000a  d014              BEQ      |L17.54|
;;;367    		{
;;;368    			/* There is not going to be a queue storage area. */
;;;369    			xQueueSizeInBytes = ( size_t ) 0;
;;;370    		}
;;;371    		else
;;;372    		{
;;;373    			/* Allocate enough space to hold the maximum number of items that
;;;374    			can be in the queue at any time. */
;;;375    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00000c  4630              MOV      r0,r6
00000e  4368              MULS     r0,r5,r0
                  |L17.16|
;;;376    		}
;;;377    
;;;378    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
000010  3048              ADDS     r0,r0,#0x48
000012  f7fffffe          BL       pvPortMalloc
000016  4604              MOV      r4,r0
;;;379    
;;;380    		if( pxNewQueue != NULL )
000018  0020              MOVS     r0,r4
00001a  d00a              BEQ      |L17.50|
;;;381    		{
;;;382    			/* Jump past the queue structure to find the location of the queue
;;;383    			storage area. */
;;;384    			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
00001c  4622              MOV      r2,r4
00001e  3248              ADDS     r2,r2,#0x48
;;;385    
;;;386    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;387    			{
;;;388    				/* Queues can be created either statically or dynamically, so
;;;389    				note this task was created dynamically in case it is later
;;;390    				deleted. */
;;;391    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
000020  2100              MOVS     r1,#0
000022  2046              MOVS     r0,#0x46
000024  5501              STRB     r1,[r0,r4]
;;;392    			}
;;;393    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;394    
;;;395    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
000026  463b              MOV      r3,r7
000028  4629              MOV      r1,r5
00002a  4630              MOV      r0,r6
00002c  9400              STR      r4,[sp,#0]
00002e  f7fffffe          BL       prvInitialiseNewQueue
                  |L17.50|
;;;396    		}
;;;397    		else
;;;398    		{
;;;399    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;400    		}
;;;401    
;;;402    		return pxNewQueue;
000032  4620              MOV      r0,r4
;;;403    	}
000034  bdf8              POP      {r3-r7,pc}
                  |L17.54|
000036  2000              MOVS     r0,#0                 ;369
000038  e7ea              B        |L17.16|
;;;404    
                          ENDP


                          AREA ||i.xQueueGenericCreateStatic||, CODE, READONLY, ALIGN=1

                  xQueueGenericCreateStatic PROC
;;;301    
;;;302    	QueueHandle_t xQueueGenericCreateStatic( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, uint8_t *pucQueueStorage, StaticQueue_t *pxStaticQueue, const uint8_t ucQueueType )
000000  b5f8              PUSH     {r3-r7,lr}
;;;303    	{
000002  461c              MOV      r4,r3
000004  9b06              LDR      r3,[sp,#0x18]
;;;304    	Queue_t *pxNewQueue;
;;;305    
;;;306    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
;;;307    
;;;308    		/* The StaticQueue_t structure and the queue storage area must be
;;;309    		supplied. */
;;;310    		configASSERT( pxStaticQueue != NULL );
;;;311    
;;;312    		/* A queue storage area should be provided if the item size is not 0, and
;;;313    		should not be provided if the item size is 0. */
;;;314    		configASSERT( !( ( pucQueueStorage != NULL ) && ( uxItemSize == 0 ) ) );
;;;315    		configASSERT( !( ( pucQueueStorage == NULL ) && ( uxItemSize != 0 ) ) );
;;;316    
;;;317    		#if( configASSERT_DEFINED == 1 )
;;;318    		{
;;;319    			/* Sanity check that the size of the structure used to declare a
;;;320    			variable of type StaticQueue_t or StaticSemaphore_t equals the size of
;;;321    			the real queue and semaphore structures. */
;;;322    			volatile size_t xSize = sizeof( StaticQueue_t );
;;;323    			configASSERT( xSize == sizeof( Queue_t ) );
;;;324    		}
;;;325    		#endif /* configASSERT_DEFINED */
;;;326    
;;;327    		/* The address of a statically allocated queue was passed in, use it.
;;;328    		The address of a statically allocated storage area was also passed in
;;;329    		but is already set. */
;;;330    		pxNewQueue = ( Queue_t * ) pxStaticQueue; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
;;;331    
;;;332    		if( pxNewQueue != NULL )
000006  2c00              CMP      r4,#0
000008  d005              BEQ      |L18.22|
;;;333    		{
;;;334    			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;335    			{
;;;336    				/* Queues can be allocated wither statically or dynamically, so
;;;337    				note this queue was allocated statically in case the queue is
;;;338    				later deleted. */
;;;339    				pxNewQueue->ucStaticallyAllocated = pdTRUE;
00000a  2601              MOVS     r6,#1
00000c  2546              MOVS     r5,#0x46
00000e  552e              STRB     r6,[r5,r4]
;;;340    			}
;;;341    			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;342    
;;;343    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
000010  9400              STR      r4,[sp,#0]
000012  f7fffffe          BL       prvInitialiseNewQueue
                  |L18.22|
;;;344    		}
;;;345    		else
;;;346    		{
;;;347    			traceQUEUE_CREATE_FAILED( ucQueueType );
;;;348    		}
;;;349    
;;;350    		return pxNewQueue;
000016  4620              MOV      r0,r4
;;;351    	}
000018  bdf8              POP      {r3-r7,pc}
;;;352    
                          ENDP


                          AREA ||i.xQueueGenericReset||, CODE, READONLY, ALIGN=1

                  xQueueGenericReset PROC
;;;246    
;;;247    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;248    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;249    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;250    
;;;251    	configASSERT( pxQueue );
;;;252    
;;;253    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;254    	{
;;;255    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
00000a  6c21              LDR      r1,[r4,#0x40]
00000c  6be0              LDR      r0,[r4,#0x3c]
00000e  4348              MULS     r0,r1,r0
000010  6821              LDR      r1,[r4,#0]
000012  1840              ADDS     r0,r0,r1
000014  6060              STR      r0,[r4,#4]
;;;256    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000016  2000              MOVS     r0,#0
000018  63a0              STR      r0,[r4,#0x38]
;;;257    		pxQueue->pcWriteTo = pxQueue->pcHead;
00001a  6820              LDR      r0,[r4,#0]
00001c  60a0              STR      r0,[r4,#8]
;;;258    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00001e  6be0              LDR      r0,[r4,#0x3c]
000020  6c21              LDR      r1,[r4,#0x40]
000022  1e40              SUBS     r0,r0,#1
000024  4348              MULS     r0,r1,r0
000026  6821              LDR      r1,[r4,#0]
000028  1840              ADDS     r0,r0,r1
00002a  60e0              STR      r0,[r4,#0xc]
;;;259    		pxQueue->cRxLock = queueUNLOCKED;
00002c  2000              MOVS     r0,#0
00002e  43c0              MVNS     r0,r0
000030  4625              MOV      r5,r4
000032  3540              ADDS     r5,r5,#0x40
000034  7128              STRB     r0,[r5,#4]
;;;260    		pxQueue->cTxLock = queueUNLOCKED;
000036  7168              STRB     r0,[r5,#5]
;;;261    
;;;262    		if( xNewQueue == pdFALSE )
;;;263    		{
;;;264    			/* If there are tasks blocked waiting to read from the queue, then
;;;265    			the tasks will remain blocked as after this function exits the queue
;;;266    			will still be empty.  If there are tasks blocked waiting to write to
;;;267    			the queue, then one should be unblocked as after this function exits
;;;268    			it will be possible to write to it. */
;;;269    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;270    			{
;;;271    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000038  4620              MOV      r0,r4
00003a  3010              ADDS     r0,r0,#0x10
00003c  2e00              CMP      r6,#0                 ;262
00003e  d009              BEQ      |L19.84|
;;;272    				{
;;;273    					queueYIELD_IF_USING_PREEMPTION();
;;;274    				}
;;;275    				else
;;;276    				{
;;;277    					mtCOVERAGE_TEST_MARKER();
;;;278    				}
;;;279    			}
;;;280    			else
;;;281    			{
;;;282    				mtCOVERAGE_TEST_MARKER();
;;;283    			}
;;;284    		}
;;;285    		else
;;;286    		{
;;;287    			/* Ensure the event queues start in the correct state. */
;;;288    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
000040  f7fffffe          BL       vListInitialise
;;;289    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000044  4620              MOV      r0,r4
000046  3024              ADDS     r0,r0,#0x24
000048  f7fffffe          BL       vListInitialise
                  |L19.76|
;;;290    		}
;;;291    	}
;;;292    	taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
;;;293    
;;;294    	/* A value is returned for calling semantic consistency with previous
;;;295    	versions. */
;;;296    	return pdPASS;
000050  2001              MOVS     r0,#1
;;;297    }
000052  bd70              POP      {r4-r6,pc}
                  |L19.84|
000054  6921              LDR      r1,[r4,#0x10]         ;269
000056  2900              CMP      r1,#0                 ;269
000058  d0f8              BEQ      |L19.76|
00005a  f7fffffe          BL       xTaskRemoveFromEventList
00005e  2800              CMP      r0,#0                 ;271
000060  d0f4              BEQ      |L19.76|
000062  f7fffffe          BL       vPortYield
000066  e7f1              B        |L19.76|
;;;298    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericSend||, CODE, READONLY, ALIGN=1

                  xQueueGenericSend PROC
;;;724    
;;;725    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
000000  b5ff              PUSH     {r0-r7,lr}
;;;726    {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
000006  461f              MOV      r7,r3
;;;727    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
000008  2500              MOVS     r5,#0
;;;728    TimeOut_t xTimeOut;
;;;729    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;730    
;;;731    	configASSERT( pxQueue );
;;;732    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;733    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;734    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;735    	{
;;;736    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;737    	}
;;;738    	#endif
;;;739    
;;;740    
;;;741    	/* This function relaxes the coding standard somewhat to allow return
;;;742    	statements within the function itself.  This is done in the interest
;;;743    	of execution time efficiency. */
;;;744    	for( ;; )
00000a  2600              MOVS     r6,#0
                  |L20.12|
;;;745    	{
;;;746    		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;747    		{
;;;748    			/* Is there room on the queue now?  The running task must be the
;;;749    			highest priority task wanting to access the queue.  If the head item
;;;750    			in the queue is to be overwritten then it does not matter if the
;;;751    			queue is full. */
;;;752    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000010  6ba0              LDR      r0,[r4,#0x38]
000012  6be1              LDR      r1,[r4,#0x3c]
000014  4288              CMP      r0,r1
000016  d307              BCC      |L20.40|
000018  2f02              CMP      r7,#2
00001a  d005              BEQ      |L20.40|
;;;753    			{
;;;754    				traceQUEUE_SEND( pxQueue );
;;;755    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;756    
;;;757    				#if ( configUSE_QUEUE_SETS == 1 )
;;;758    				{
;;;759    					if( pxQueue->pxQueueSetContainer != NULL )
;;;760    					{
;;;761    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;762    						{
;;;763    							/* The queue is a member of a queue set, and posting
;;;764    							to the queue set caused a higher priority task to
;;;765    							unblock. A context switch is required. */
;;;766    							queueYIELD_IF_USING_PREEMPTION();
;;;767    						}
;;;768    						else
;;;769    						{
;;;770    							mtCOVERAGE_TEST_MARKER();
;;;771    						}
;;;772    					}
;;;773    					else
;;;774    					{
;;;775    						/* If there was a task waiting for data to arrive on the
;;;776    						queue then unblock it now. */
;;;777    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;778    						{
;;;779    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;780    							{
;;;781    								/* The unblocked task has a priority higher than
;;;782    								our own so yield immediately.  Yes it is ok to
;;;783    								do this from within the critical section - the
;;;784    								kernel takes care of that. */
;;;785    								queueYIELD_IF_USING_PREEMPTION();
;;;786    							}
;;;787    							else
;;;788    							{
;;;789    								mtCOVERAGE_TEST_MARKER();
;;;790    							}
;;;791    						}
;;;792    						else if( xYieldRequired != pdFALSE )
;;;793    						{
;;;794    							/* This path is a special case that will only get
;;;795    							executed if the task was holding multiple mutexes
;;;796    							and the mutexes were given back in an order that is
;;;797    							different to that in which they were taken. */
;;;798    							queueYIELD_IF_USING_PREEMPTION();
;;;799    						}
;;;800    						else
;;;801    						{
;;;802    							mtCOVERAGE_TEST_MARKER();
;;;803    						}
;;;804    					}
;;;805    				}
;;;806    				#else /* configUSE_QUEUE_SETS */
;;;807    				{
;;;808    					/* If there was a task waiting for data to arrive on the
;;;809    					queue then unblock it now. */
;;;810    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;811    					{
;;;812    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;813    						{
;;;814    							/* The unblocked task has a priority higher than
;;;815    							our own so yield immediately.  Yes it is ok to do
;;;816    							this from within the critical section - the kernel
;;;817    							takes care of that. */
;;;818    							queueYIELD_IF_USING_PREEMPTION();
;;;819    						}
;;;820    						else
;;;821    						{
;;;822    							mtCOVERAGE_TEST_MARKER();
;;;823    						}
;;;824    					}
;;;825    					else if( xYieldRequired != pdFALSE )
;;;826    					{
;;;827    						/* This path is a special case that will only get
;;;828    						executed if the task was holding multiple mutexes and
;;;829    						the mutexes were given back in an order that is
;;;830    						different to that in which they were taken. */
;;;831    						queueYIELD_IF_USING_PREEMPTION();
;;;832    					}
;;;833    					else
;;;834    					{
;;;835    						mtCOVERAGE_TEST_MARKER();
;;;836    					}
;;;837    				}
;;;838    				#endif /* configUSE_QUEUE_SETS */
;;;839    
;;;840    				taskEXIT_CRITICAL();
;;;841    				return pdPASS;
;;;842    			}
;;;843    			else
;;;844    			{
;;;845    				if( xTicksToWait == ( TickType_t ) 0 )
00001c  9805              LDR      r0,[sp,#0x14]
00001e  2800              CMP      r0,#0
000020  d01c              BEQ      |L20.92|
;;;846    				{
;;;847    					/* The queue was full and no block time is specified (or
;;;848    					the block time has expired) so leave now. */
;;;849    					taskEXIT_CRITICAL();
;;;850    
;;;851    					/* Return to the original privilege level before exiting
;;;852    					the function. */
;;;853    					traceQUEUE_SEND_FAILED( pxQueue );
;;;854    					return errQUEUE_FULL;
;;;855    				}
;;;856    				else if( xEntryTimeSet == pdFALSE )
000022  2d00              CMP      r5,#0
000024  d01e              BEQ      |L20.100|
000026  e021              B        |L20.108|
                  |L20.40|
000028  463a              MOV      r2,r7                 ;755
00002a  4620              MOV      r0,r4                 ;755
00002c  9904              LDR      r1,[sp,#0x10]         ;755
00002e  f7fffffe          BL       prvCopyDataToQueue
000032  6a61              LDR      r1,[r4,#0x24]         ;810
000034  2900              CMP      r1,#0                 ;810
000036  d008              BEQ      |L20.74|
000038  4620              MOV      r0,r4                 ;812
00003a  3024              ADDS     r0,r0,#0x24           ;812
00003c  f7fffffe          BL       xTaskRemoveFromEventList
000040  2800              CMP      r0,#0                 ;812
000042  d006              BEQ      |L20.82|
000044  f7fffffe          BL       vPortYield
000048  e003              B        |L20.82|
                  |L20.74|
00004a  2800              CMP      r0,#0                 ;825
00004c  d001              BEQ      |L20.82|
00004e  f7fffffe          BL       vPortYield
                  |L20.82|
000052  f7fffffe          BL       vPortExitCritical
000056  2001              MOVS     r0,#1                 ;841
                  |L20.88|
;;;857    				{
;;;858    					/* The queue was full and a block time was specified so
;;;859    					configure the timeout structure. */
;;;860    					vTaskInternalSetTimeOutState( &xTimeOut );
;;;861    					xEntryTimeSet = pdTRUE;
;;;862    				}
;;;863    				else
;;;864    				{
;;;865    					/* Entry time was already set. */
;;;866    					mtCOVERAGE_TEST_MARKER();
;;;867    				}
;;;868    			}
;;;869    		}
;;;870    		taskEXIT_CRITICAL();
;;;871    
;;;872    		/* Interrupts and other tasks can send to and receive from the queue
;;;873    		now the critical section has been exited. */
;;;874    
;;;875    		vTaskSuspendAll();
;;;876    		prvLockQueue( pxQueue );
;;;877    
;;;878    		/* Update the timeout state to see if it has expired yet. */
;;;879    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;880    		{
;;;881    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;882    			{
;;;883    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;884    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;885    
;;;886    				/* Unlocking the queue means queue events can effect the
;;;887    				event list.  It is possible that interrupts occurring now
;;;888    				remove this task from the event list again - but as the
;;;889    				scheduler is suspended the task will go onto the pending
;;;890    				ready last instead of the actual ready list. */
;;;891    				prvUnlockQueue( pxQueue );
;;;892    
;;;893    				/* Resuming the scheduler will move tasks from the pending
;;;894    				ready list into the ready list - so it is feasible that this
;;;895    				task is already in a ready list before it yields - in which
;;;896    				case the yield will not cause a context switch unless there
;;;897    				is also a higher priority task in the pending ready list. */
;;;898    				if( xTaskResumeAll() == pdFALSE )
;;;899    				{
;;;900    					portYIELD_WITHIN_API();
;;;901    				}
;;;902    			}
;;;903    			else
;;;904    			{
;;;905    				/* Try again. */
;;;906    				prvUnlockQueue( pxQueue );
;;;907    				( void ) xTaskResumeAll();
;;;908    			}
;;;909    		}
;;;910    		else
;;;911    		{
;;;912    			/* The timeout has expired. */
;;;913    			prvUnlockQueue( pxQueue );
;;;914    			( void ) xTaskResumeAll();
;;;915    
;;;916    			traceQUEUE_SEND_FAILED( pxQueue );
;;;917    			return errQUEUE_FULL;
;;;918    		}
;;;919    	}
;;;920    }
000058  b007              ADD      sp,sp,#0x1c
00005a  bdf0              POP      {r4-r7,pc}
                  |L20.92|
00005c  f7fffffe          BL       vPortExitCritical
000060  2000              MOVS     r0,#0                 ;854
000062  e7f9              B        |L20.88|
                  |L20.100|
000064  a801              ADD      r0,sp,#4              ;860
000066  f7fffffe          BL       vTaskInternalSetTimeOutState
00006a  2501              MOVS     r5,#1                 ;861
                  |L20.108|
00006c  f7fffffe          BL       vPortExitCritical
000070  f7fffffe          BL       vTaskSuspendAll
000074  f7fffffe          BL       vPortEnterCritical
000078  4620              MOV      r0,r4                 ;876
00007a  3040              ADDS     r0,r0,#0x40           ;876
00007c  2104              MOVS     r1,#4                 ;876
00007e  5641              LDRSB    r1,[r0,r1]            ;876
000080  1c49              ADDS     r1,r1,#1              ;876
000082  d100              BNE      |L20.134|
000084  7106              STRB     r6,[r0,#4]            ;876
                  |L20.134|
000086  2105              MOVS     r1,#5                 ;876
000088  5641              LDRSB    r1,[r0,r1]            ;876
00008a  1c49              ADDS     r1,r1,#1              ;876
00008c  d100              BNE      |L20.144|
00008e  7146              STRB     r6,[r0,#5]            ;876
                  |L20.144|
000090  f7fffffe          BL       vPortExitCritical
000094  a905              ADD      r1,sp,#0x14           ;879
000096  a801              ADD      r0,sp,#4              ;879
000098  f7fffffe          BL       xTaskCheckForTimeOut
00009c  2800              CMP      r0,#0                 ;879
00009e  d006              BEQ      |L20.174|
0000a0  4620              MOV      r0,r4                 ;913
0000a2  f7fffffe          BL       prvUnlockQueue
0000a6  f7fffffe          BL       xTaskResumeAll
0000aa  2000              MOVS     r0,#0                 ;917
0000ac  e7d4              B        |L20.88|
                  |L20.174|
0000ae  4620              MOV      r0,r4                 ;881
0000b0  f7fffffe          BL       prvIsQueueFull
0000b4  2800              CMP      r0,#0                 ;881
0000b6  d00e              BEQ      |L20.214|
0000b8  4620              MOV      r0,r4                 ;884
0000ba  3010              ADDS     r0,r0,#0x10           ;884
0000bc  9905              LDR      r1,[sp,#0x14]         ;884
0000be  f7fffffe          BL       vTaskPlaceOnEventList
0000c2  4620              MOV      r0,r4                 ;891
0000c4  f7fffffe          BL       prvUnlockQueue
0000c8  f7fffffe          BL       xTaskResumeAll
0000cc  2800              CMP      r0,#0                 ;898
0000ce  d19d              BNE      |L20.12|
0000d0  f7fffffe          BL       vPortYield
0000d4  e79a              B        |L20.12|
                  |L20.214|
0000d6  4620              MOV      r0,r4                 ;906
0000d8  f7fffffe          BL       prvUnlockQueue
0000dc  f7fffffe          BL       xTaskResumeAll
0000e0  e794              B        |L20.12|
;;;921    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGenericSendFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGenericSendFromISR PROC
;;;922    
;;;923    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
000000  b5ff              PUSH     {r0-r7,lr}
;;;924    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4616              MOV      r6,r2
;;;925    BaseType_t xReturn;
;;;926    UBaseType_t uxSavedInterruptStatus;
;;;927    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;928    
;;;929    	configASSERT( pxQueue );
;;;930    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;931    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
;;;932    
;;;933    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;934    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;935    	above the maximum system call priority are kept permanently enabled, even
;;;936    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;937    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;938    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;939    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;940    	assigned a priority above the configured maximum system call priority.
;;;941    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;942    	that have been assigned a priority at or (logically) below the maximum
;;;943    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;944    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;945    	More information (albeit Cortex-M specific) is provided on the following
;;;946    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;947    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;948    
;;;949    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;950    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;951    	read, instead return a flag to say whether a context switch is required or
;;;952    	not (i.e. has a task with a higher priority than us been woken by this
;;;953    	post). */
;;;954    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000008  f7fffffe          BL       ulSetInterruptMaskFromISR
00000c  9000              STR      r0,[sp,#0]
;;;955    	{
;;;956    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
00000e  6ba0              LDR      r0,[r4,#0x38]
000010  6be1              LDR      r1,[r4,#0x3c]
000012  4288              CMP      r0,r1
000014  d309              BCC      |L21.42|
000016  9804              LDR      r0,[sp,#0x10]
000018  2802              CMP      r0,#2
00001a  d006              BEQ      |L21.42|
;;;957    		{
;;;958    			const int8_t cTxLock = pxQueue->cTxLock;
;;;959    
;;;960    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;961    
;;;962    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;963    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;964    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;965    			called here even though the disinherit function does not check if
;;;966    			the scheduler is suspended before accessing the ready lists. */
;;;967    			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;968    
;;;969    			/* The event list is not altered if the queue is locked.  This will
;;;970    			be done when the queue is unlocked later. */
;;;971    			if( cTxLock == queueUNLOCKED )
;;;972    			{
;;;973    				#if ( configUSE_QUEUE_SETS == 1 )
;;;974    				{
;;;975    					if( pxQueue->pxQueueSetContainer != NULL )
;;;976    					{
;;;977    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;978    						{
;;;979    							/* The queue is a member of a queue set, and posting
;;;980    							to the queue set caused a higher priority task to
;;;981    							unblock.  A context switch is required. */
;;;982    							if( pxHigherPriorityTaskWoken != NULL )
;;;983    							{
;;;984    								*pxHigherPriorityTaskWoken = pdTRUE;
;;;985    							}
;;;986    							else
;;;987    							{
;;;988    								mtCOVERAGE_TEST_MARKER();
;;;989    							}
;;;990    						}
;;;991    						else
;;;992    						{
;;;993    							mtCOVERAGE_TEST_MARKER();
;;;994    						}
;;;995    					}
;;;996    					else
;;;997    					{
;;;998    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;999    						{
;;;1000   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1001   							{
;;;1002   								/* The task waiting has a higher priority so
;;;1003   								record that a context switch is required. */
;;;1004   								if( pxHigherPriorityTaskWoken != NULL )
;;;1005   								{
;;;1006   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1007   								}
;;;1008   								else
;;;1009   								{
;;;1010   									mtCOVERAGE_TEST_MARKER();
;;;1011   								}
;;;1012   							}
;;;1013   							else
;;;1014   							{
;;;1015   								mtCOVERAGE_TEST_MARKER();
;;;1016   							}
;;;1017   						}
;;;1018   						else
;;;1019   						{
;;;1020   							mtCOVERAGE_TEST_MARKER();
;;;1021   						}
;;;1022   					}
;;;1023   				}
;;;1024   				#else /* configUSE_QUEUE_SETS */
;;;1025   				{
;;;1026   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1027   					{
;;;1028   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1029   						{
;;;1030   							/* The task waiting has a higher priority so record that a
;;;1031   							context	switch is required. */
;;;1032   							if( pxHigherPriorityTaskWoken != NULL )
;;;1033   							{
;;;1034   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1035   							}
;;;1036   							else
;;;1037   							{
;;;1038   								mtCOVERAGE_TEST_MARKER();
;;;1039   							}
;;;1040   						}
;;;1041   						else
;;;1042   						{
;;;1043   							mtCOVERAGE_TEST_MARKER();
;;;1044   						}
;;;1045   					}
;;;1046   					else
;;;1047   					{
;;;1048   						mtCOVERAGE_TEST_MARKER();
;;;1049   					}
;;;1050   				}
;;;1051   				#endif /* configUSE_QUEUE_SETS */
;;;1052   			}
;;;1053   			else
;;;1054   			{
;;;1055   				/* Increment the lock count so the task that unlocks the queue
;;;1056   				knows that data was posted while it was locked. */
;;;1057   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
;;;1058   			}
;;;1059   
;;;1060   			xReturn = pdPASS;
;;;1061   		}
;;;1062   		else
;;;1063   		{
;;;1064   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1065   			xReturn = errQUEUE_FULL;
00001c  2400              MOVS     r4,#0
                  |L21.30|
;;;1066   		}
;;;1067   	}
;;;1068   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00001e  9800              LDR      r0,[sp,#0]
000020  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1069   
;;;1070   	return xReturn;
000024  4620              MOV      r0,r4
;;;1071   }
000026  b005              ADD      sp,sp,#0x14
000028  bdf0              POP      {r4-r7,pc}
                  |L21.42|
00002a  4620              MOV      r0,r4                 ;958
00002c  3040              ADDS     r0,r0,#0x40           ;958
00002e  2505              MOVS     r5,#5                 ;958
000030  5745              LDRSB    r5,[r0,r5]            ;958
000032  4607              MOV      r7,r0                 ;958
000034  4620              MOV      r0,r4                 ;967
000036  9a04              LDR      r2,[sp,#0x10]         ;967
000038  9902              LDR      r1,[sp,#8]            ;967
00003a  f7fffffe          BL       prvCopyDataToQueue
00003e  1c68              ADDS     r0,r5,#1              ;971
000040  d003              BEQ      |L21.74|
000042  1c6d              ADDS     r5,r5,#1              ;1057
000044  717d              STRB     r5,[r7,#5]            ;1057
                  |L21.70|
000046  2401              MOVS     r4,#1                 ;1060
000048  e7e9              B        |L21.30|
                  |L21.74|
00004a  6a60              LDR      r0,[r4,#0x24]         ;1026
00004c  2800              CMP      r0,#0                 ;1026
00004e  d0fa              BEQ      |L21.70|
000050  4620              MOV      r0,r4                 ;1028
000052  3024              ADDS     r0,r0,#0x24           ;1028
000054  f7fffffe          BL       xTaskRemoveFromEventList
000058  2800              CMP      r0,#0                 ;1028
00005a  d0f4              BEQ      |L21.70|
00005c  2e00              CMP      r6,#0                 ;1032
00005e  d0f2              BEQ      |L21.70|
000060  2001              MOVS     r0,#1                 ;1034
000062  6030              STR      r0,[r6,#0]            ;1034
000064  e7ef              B        |L21.70|
;;;1072   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueGetMutexHolder||, CODE, READONLY, ALIGN=1

                  xQueueGetMutexHolder PROC
;;;517    
;;;518    	void* xQueueGetMutexHolder( QueueHandle_t xSemaphore )
000000  b510              PUSH     {r4,lr}
;;;519    	{
000002  4604              MOV      r4,r0
;;;520    	void *pxReturn;
;;;521    
;;;522    		/* This function is called by xSemaphoreGetMutexHolder(), and should not
;;;523    		be called directly.  Note:  This is a good way of determining if the
;;;524    		calling task is the mutex holder, but not a good way of determining the
;;;525    		identity of the mutex holder, as the holder may change between the
;;;526    		following critical section exiting and the function returning. */
;;;527    		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;528    		{
;;;529    			if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
000008  6820              LDR      r0,[r4,#0]
00000a  2800              CMP      r0,#0
00000c  d004              BEQ      |L22.24|
;;;530    			{
;;;531    				pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
;;;532    			}
;;;533    			else
;;;534    			{
;;;535    				pxReturn = NULL;
00000e  2400              MOVS     r4,#0
                  |L22.16|
;;;536    			}
;;;537    		}
;;;538    		taskEXIT_CRITICAL();
000010  f7fffffe          BL       vPortExitCritical
;;;539    
;;;540    		return pxReturn;
000014  4620              MOV      r0,r4
;;;541    	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
000016  bd10              POP      {r4,pc}
                  |L22.24|
000018  6864              LDR      r4,[r4,#4]            ;531
00001a  e7f9              B        |L22.16|
;;;542    
                          ENDP


                          AREA ||i.xQueueGetMutexHolderFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGetMutexHolderFromISR PROC
;;;547    
;;;548    	void* xQueueGetMutexHolderFromISR( QueueHandle_t xSemaphore )
000000  6801              LDR      r1,[r0,#0]
;;;549    	{
;;;550    	void *pxReturn;
;;;551    
;;;552    		configASSERT( xSemaphore );
;;;553    
;;;554    		/* Mutexes cannot be used in interrupt service routines, so the mutex
;;;555    		holder should not change in an ISR, and therefore a critical section is
;;;556    		not required here. */
;;;557    		if( ( ( Queue_t * ) xSemaphore )->uxQueueType == queueQUEUE_IS_MUTEX )
000002  2900              CMP      r1,#0
000004  d001              BEQ      |L23.10|
;;;558    		{
;;;559    			pxReturn = ( void * ) ( ( Queue_t * ) xSemaphore )->pxMutexHolder;
;;;560    		}
;;;561    		else
;;;562    		{
;;;563    			pxReturn = NULL;
000006  2000              MOVS     r0,#0
;;;564    		}
;;;565    
;;;566    		return pxReturn;
;;;567    	} /*lint !e818 xSemaphore cannot be a pointer to const because it is a typedef. */
000008  4770              BX       lr
                  |L23.10|
00000a  6840              LDR      r0,[r0,#4]            ;559
00000c  4770              BX       lr
;;;568    
                          ENDP


                          AREA ||i.xQueueGiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueGiveFromISR PROC
;;;1073   
;;;1074   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
000000  b570              PUSH     {r4-r6,lr}
;;;1075   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1076   BaseType_t xReturn;
;;;1077   UBaseType_t uxSavedInterruptStatus;
;;;1078   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1079   
;;;1080   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1081   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1082   	read, instead return a flag to say whether a context switch is required or
;;;1083   	not (i.e. has a task with a higher priority than us been woken by this
;;;1084   	post). */
;;;1085   
;;;1086   	configASSERT( pxQueue );
;;;1087   
;;;1088   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1089   	if the item size is not 0. */
;;;1090   	configASSERT( pxQueue->uxItemSize == 0 );
;;;1091   
;;;1092   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1093   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1094   	interrupts, only tasks. */
;;;1095   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
;;;1096   
;;;1097   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1098   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1099   	above the maximum system call priority are kept permanently enabled, even
;;;1100   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1101   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1102   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1103   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1104   	assigned a priority above the configured maximum system call priority.
;;;1105   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1106   	that have been assigned a priority at or (logically) below the maximum
;;;1107   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1108   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1109   	More information (albeit Cortex-M specific) is provided on the following
;;;1110   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1111   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1112   
;;;1113   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000006  f7fffffe          BL       ulSetInterruptMaskFromISR
00000a  4606              MOV      r6,r0
;;;1114   	{
;;;1115   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00000c  6ba1              LDR      r1,[r4,#0x38]
;;;1116   
;;;1117   		/* When the queue is used to implement a semaphore no data is ever
;;;1118   		moved through the queue but it is still valid to see if the queue 'has
;;;1119   		space'. */
;;;1120   		if( uxMessagesWaiting < pxQueue->uxLength )
00000e  6be0              LDR      r0,[r4,#0x3c]
000010  4288              CMP      r0,r1
000012  d919              BLS      |L24.72|
;;;1121   		{
;;;1122   			const int8_t cTxLock = pxQueue->cTxLock;
000014  4622              MOV      r2,r4
000016  3240              ADDS     r2,r2,#0x40
000018  2005              MOVS     r0,#5
00001a  5610              LDRSB    r0,[r2,r0]
;;;1123   
;;;1124   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1125   
;;;1126   			/* A task can only have an inherited priority if it is a mutex
;;;1127   			holder - and if there is a mutex holder then the mutex cannot be
;;;1128   			given from an ISR.  As this is the ISR version of the function it
;;;1129   			can be assumed there is no mutex holder and no need to determine if
;;;1130   			priority disinheritance is needed.  Simply increase the count of
;;;1131   			messages (semaphores) available. */
;;;1132   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + ( UBaseType_t ) 1;
00001c  1c49              ADDS     r1,r1,#1
00001e  63a1              STR      r1,[r4,#0x38]
;;;1133   
;;;1134   			/* The event list is not altered if the queue is locked.  This will
;;;1135   			be done when the queue is unlocked later. */
;;;1136   			if( cTxLock == queueUNLOCKED )
000020  1c41              ADDS     r1,r0,#1
000022  d003              BEQ      |L24.44|
;;;1137   			{
;;;1138   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1139   				{
;;;1140   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1141   					{
;;;1142   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1143   						{
;;;1144   							/* The semaphore is a member of a queue set, and
;;;1145   							posting	to the queue set caused a higher priority
;;;1146   							task to	unblock.  A context switch is required. */
;;;1147   							if( pxHigherPriorityTaskWoken != NULL )
;;;1148   							{
;;;1149   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1150   							}
;;;1151   							else
;;;1152   							{
;;;1153   								mtCOVERAGE_TEST_MARKER();
;;;1154   							}
;;;1155   						}
;;;1156   						else
;;;1157   						{
;;;1158   							mtCOVERAGE_TEST_MARKER();
;;;1159   						}
;;;1160   					}
;;;1161   					else
;;;1162   					{
;;;1163   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1164   						{
;;;1165   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1166   							{
;;;1167   								/* The task waiting has a higher priority so
;;;1168   								record that a context switch is required. */
;;;1169   								if( pxHigherPriorityTaskWoken != NULL )
;;;1170   								{
;;;1171   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1172   								}
;;;1173   								else
;;;1174   								{
;;;1175   									mtCOVERAGE_TEST_MARKER();
;;;1176   								}
;;;1177   							}
;;;1178   							else
;;;1179   							{
;;;1180   								mtCOVERAGE_TEST_MARKER();
;;;1181   							}
;;;1182   						}
;;;1183   						else
;;;1184   						{
;;;1185   							mtCOVERAGE_TEST_MARKER();
;;;1186   						}
;;;1187   					}
;;;1188   				}
;;;1189   				#else /* configUSE_QUEUE_SETS */
;;;1190   				{
;;;1191   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1192   					{
;;;1193   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1194   						{
;;;1195   							/* The task waiting has a higher priority so record that a
;;;1196   							context	switch is required. */
;;;1197   							if( pxHigherPriorityTaskWoken != NULL )
;;;1198   							{
;;;1199   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1200   							}
;;;1201   							else
;;;1202   							{
;;;1203   								mtCOVERAGE_TEST_MARKER();
;;;1204   							}
;;;1205   						}
;;;1206   						else
;;;1207   						{
;;;1208   							mtCOVERAGE_TEST_MARKER();
;;;1209   						}
;;;1210   					}
;;;1211   					else
;;;1212   					{
;;;1213   						mtCOVERAGE_TEST_MARKER();
;;;1214   					}
;;;1215   				}
;;;1216   				#endif /* configUSE_QUEUE_SETS */
;;;1217   			}
;;;1218   			else
;;;1219   			{
;;;1220   				/* Increment the lock count so the task that unlocks the queue
;;;1221   				knows that data was posted while it was locked. */
;;;1222   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
000024  1c40              ADDS     r0,r0,#1
000026  7150              STRB     r0,[r2,#5]
                  |L24.40|
;;;1223   			}
;;;1224   
;;;1225   			xReturn = pdPASS;
000028  2401              MOVS     r4,#1
;;;1226   		}
00002a  e00e              B        |L24.74|
                  |L24.44|
00002c  6a60              LDR      r0,[r4,#0x24]         ;1191
00002e  2800              CMP      r0,#0                 ;1191
000030  d0fa              BEQ      |L24.40|
000032  4620              MOV      r0,r4                 ;1193
000034  3024              ADDS     r0,r0,#0x24           ;1193
000036  f7fffffe          BL       xTaskRemoveFromEventList
00003a  2800              CMP      r0,#0                 ;1193
00003c  d0f4              BEQ      |L24.40|
00003e  2d00              CMP      r5,#0                 ;1197
000040  d0f2              BEQ      |L24.40|
000042  2001              MOVS     r0,#1                 ;1199
000044  6028              STR      r0,[r5,#0]            ;1199
000046  e7ef              B        |L24.40|
                  |L24.72|
;;;1227   		else
;;;1228   		{
;;;1229   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1230   			xReturn = errQUEUE_FULL;
000048  2400              MOVS     r4,#0
                  |L24.74|
;;;1231   		}
;;;1232   	}
;;;1233   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00004a  4630              MOV      r0,r6
00004c  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1234   
;;;1235   	return xReturn;
000050  4620              MOV      r0,r4
;;;1236   }
000052  bd70              POP      {r4-r6,pc}
;;;1237   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueEmptyFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueEmptyFromISR PROC
;;;2277   
;;;2278   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
000000  6b80              LDR      r0,[r0,#0x38]
;;;2279   {
;;;2280   BaseType_t xReturn;
;;;2281   
;;;2282   	configASSERT( xQueue );
;;;2283   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
000002  2800              CMP      r0,#0
000004  d001              BEQ      |L25.10|
;;;2284   	{
;;;2285   		xReturn = pdTRUE;
;;;2286   	}
;;;2287   	else
;;;2288   	{
;;;2289   		xReturn = pdFALSE;
000006  2000              MOVS     r0,#0
;;;2290   	}
;;;2291   
;;;2292   	return xReturn;
;;;2293   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000008  4770              BX       lr
                  |L25.10|
00000a  2001              MOVS     r0,#1                 ;2285
00000c  4770              BX       lr
;;;2294   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueIsQueueFullFromISR||, CODE, READONLY, ALIGN=1

                  xQueueIsQueueFullFromISR PROC
;;;2316   
;;;2317   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
000000  6b81              LDR      r1,[r0,#0x38]
;;;2318   {
;;;2319   BaseType_t xReturn;
;;;2320   
;;;2321   	configASSERT( xQueue );
;;;2322   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
000002  6bc0              LDR      r0,[r0,#0x3c]
000004  4281              CMP      r1,r0
000006  d101              BNE      |L26.12|
;;;2323   	{
;;;2324   		xReturn = pdTRUE;
000008  2001              MOVS     r0,#1
;;;2325   	}
;;;2326   	else
;;;2327   	{
;;;2328   		xReturn = pdFALSE;
;;;2329   	}
;;;2330   
;;;2331   	return xReturn;
;;;2332   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00000a  4770              BX       lr
                  |L26.12|
00000c  2000              MOVS     r0,#0                 ;2328
00000e  4770              BX       lr
;;;2333   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeek||, CODE, READONLY, ALIGN=1

                  xQueuePeek PROC
;;;1599   
;;;1600   BaseType_t xQueuePeek( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1601   {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
;;;1602   BaseType_t xEntryTimeSet = pdFALSE;
000008  2500              MOVS     r5,#0
;;;1603   TimeOut_t xTimeOut;
;;;1604   int8_t *pcOriginalReadPosition;
;;;1605   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1606   
;;;1607   	/* Check the pointer is not NULL. */
;;;1608   	configASSERT( ( pxQueue ) );
;;;1609   
;;;1610   	/* The buffer into which data is received can only be NULL if the data size
;;;1611   	is zero (so no data is copied into the buffer. */
;;;1612   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1613   
;;;1614   	/* Cannot block if the scheduler is suspended. */
;;;1615   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1616   	{
;;;1617   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1618   	}
;;;1619   	#endif
;;;1620   
;;;1621   
;;;1622   	/* This function relaxes the coding standard somewhat to allow return
;;;1623   	statements within the function itself.  This is done in the interest
;;;1624   	of execution time efficiency. */
;;;1625   
;;;1626   	for( ;; )
00000a  2600              MOVS     r6,#0
                  |L27.12|
;;;1627   	{
;;;1628   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;1629   		{
;;;1630   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000010  6ba0              LDR      r0,[r4,#0x38]
;;;1631   
;;;1632   			/* Is there data in the queue now?  To be running the calling task
;;;1633   			must be the highest priority task wanting to access the queue. */
;;;1634   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000012  2800              CMP      r0,#0
000014  d015              BEQ      |L27.66|
;;;1635   			{
;;;1636   				/* Remember the read position so it can be reset after the data
;;;1637   				is read from the queue as this function is only peeking the
;;;1638   				data, not removing it. */
;;;1639   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
000016  68e5              LDR      r5,[r4,#0xc]
;;;1640   
;;;1641   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000018  4639              MOV      r1,r7
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       prvCopyDataFromQueue
;;;1642   				traceQUEUE_PEEK( pxQueue );
;;;1643   
;;;1644   				/* The data is not being removed, so reset the read pointer. */
;;;1645   				pxQueue->u.pcReadFrom = pcOriginalReadPosition;
000020  60e5              STR      r5,[r4,#0xc]
;;;1646   
;;;1647   				/* The data is being left in the queue, so see if there are
;;;1648   				any other tasks waiting for the data. */
;;;1649   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
000022  6a60              LDR      r0,[r4,#0x24]
000024  2800              CMP      r0,#0
000026  d007              BEQ      |L27.56|
;;;1650   				{
;;;1651   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000028  4620              MOV      r0,r4
00002a  3024              ADDS     r0,r0,#0x24
00002c  f7fffffe          BL       xTaskRemoveFromEventList
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L27.56|
;;;1652   					{
;;;1653   						/* The task waiting has a higher priority than this task. */
;;;1654   						queueYIELD_IF_USING_PREEMPTION();
000034  f7fffffe          BL       vPortYield
                  |L27.56|
;;;1655   					}
;;;1656   					else
;;;1657   					{
;;;1658   						mtCOVERAGE_TEST_MARKER();
;;;1659   					}
;;;1660   				}
;;;1661   				else
;;;1662   				{
;;;1663   					mtCOVERAGE_TEST_MARKER();
;;;1664   				}
;;;1665   
;;;1666   				taskEXIT_CRITICAL();
000038  f7fffffe          BL       vPortExitCritical
;;;1667   				return pdPASS;
00003c  2001              MOVS     r0,#1
                  |L27.62|
;;;1668   			}
;;;1669   			else
;;;1670   			{
;;;1671   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1672   				{
;;;1673   					/* The queue was empty and no block time is specified (or
;;;1674   					the block time has expired) so leave now. */
;;;1675   					taskEXIT_CRITICAL();
;;;1676   					traceQUEUE_PEEK_FAILED( pxQueue );
;;;1677   					return errQUEUE_EMPTY;
;;;1678   				}
;;;1679   				else if( xEntryTimeSet == pdFALSE )
;;;1680   				{
;;;1681   					/* The queue was empty and a block time was specified so
;;;1682   					configure the timeout structure ready to enter the blocked
;;;1683   					state. */
;;;1684   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1685   					xEntryTimeSet = pdTRUE;
;;;1686   				}
;;;1687   				else
;;;1688   				{
;;;1689   					/* Entry time was already set. */
;;;1690   					mtCOVERAGE_TEST_MARKER();
;;;1691   				}
;;;1692   			}
;;;1693   		}
;;;1694   		taskEXIT_CRITICAL();
;;;1695   
;;;1696   		/* Interrupts and other tasks can send to and receive from the queue
;;;1697   		now the critical section has been exited. */
;;;1698   
;;;1699   		vTaskSuspendAll();
;;;1700   		prvLockQueue( pxQueue );
;;;1701   
;;;1702   		/* Update the timeout state to see if it has expired yet. */
;;;1703   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1704   		{
;;;1705   			/* Timeout has not expired yet, check to see if there is data in the
;;;1706   			queue now, and if not enter the Blocked state to wait for data. */
;;;1707   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1708   			{
;;;1709   				traceBLOCKING_ON_QUEUE_PEEK( pxQueue );
;;;1710   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1711   				prvUnlockQueue( pxQueue );
;;;1712   				if( xTaskResumeAll() == pdFALSE )
;;;1713   				{
;;;1714   					portYIELD_WITHIN_API();
;;;1715   				}
;;;1716   				else
;;;1717   				{
;;;1718   					mtCOVERAGE_TEST_MARKER();
;;;1719   				}
;;;1720   			}
;;;1721   			else
;;;1722   			{
;;;1723   				/* There is data in the queue now, so don't enter the blocked
;;;1724   				state, instead return to try and obtain the data. */
;;;1725   				prvUnlockQueue( pxQueue );
;;;1726   				( void ) xTaskResumeAll();
;;;1727   			}
;;;1728   		}
;;;1729   		else
;;;1730   		{
;;;1731   			/* The timeout has expired.  If there is still no data in the queue
;;;1732   			exit, otherwise go back and try to read the data again. */
;;;1733   			prvUnlockQueue( pxQueue );
;;;1734   			( void ) xTaskResumeAll();
;;;1735   
;;;1736   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1737   			{
;;;1738   				traceQUEUE_PEEK_FAILED( pxQueue );
;;;1739   				return errQUEUE_EMPTY;
;;;1740   			}
;;;1741   			else
;;;1742   			{
;;;1743   				mtCOVERAGE_TEST_MARKER();
;;;1744   			}
;;;1745   		}
;;;1746   	}
;;;1747   }
00003e  b005              ADD      sp,sp,#0x14
000040  bdf0              POP      {r4-r7,pc}
                  |L27.66|
000042  9804              LDR      r0,[sp,#0x10]         ;1671
000044  2800              CMP      r0,#0                 ;1671
000046  d002              BEQ      |L27.78|
000048  2d00              CMP      r5,#0                 ;1679
00004a  d004              BEQ      |L27.86|
00004c  e007              B        |L27.94|
                  |L27.78|
00004e  f7fffffe          BL       vPortExitCritical
000052  2000              MOVS     r0,#0                 ;1677
000054  e7f3              B        |L27.62|
                  |L27.86|
000056  4668              MOV      r0,sp                 ;1684
000058  f7fffffe          BL       vTaskInternalSetTimeOutState
00005c  2501              MOVS     r5,#1                 ;1685
                  |L27.94|
00005e  f7fffffe          BL       vPortExitCritical
000062  f7fffffe          BL       vTaskSuspendAll
000066  f7fffffe          BL       vPortEnterCritical
00006a  4620              MOV      r0,r4                 ;1700
00006c  3040              ADDS     r0,r0,#0x40           ;1700
00006e  2104              MOVS     r1,#4                 ;1700
000070  5641              LDRSB    r1,[r0,r1]            ;1700
000072  1c49              ADDS     r1,r1,#1              ;1700
000074  d100              BNE      |L27.120|
000076  7106              STRB     r6,[r0,#4]            ;1700
                  |L27.120|
000078  2105              MOVS     r1,#5                 ;1700
00007a  5641              LDRSB    r1,[r0,r1]            ;1700
00007c  1c49              ADDS     r1,r1,#1              ;1700
00007e  d100              BNE      |L27.130|
000080  7146              STRB     r6,[r0,#5]            ;1700
                  |L27.130|
000082  f7fffffe          BL       vPortExitCritical
000086  a904              ADD      r1,sp,#0x10           ;1703
000088  4668              MOV      r0,sp                 ;1703
00008a  f7fffffe          BL       xTaskCheckForTimeOut
00008e  2800              CMP      r0,#0                 ;1703
000090  d00b              BEQ      |L27.170|
000092  4620              MOV      r0,r4                 ;1733
000094  f7fffffe          BL       prvUnlockQueue
000098  f7fffffe          BL       xTaskResumeAll
00009c  4620              MOV      r0,r4                 ;1736
00009e  f7fffffe          BL       prvIsQueueEmpty
0000a2  2800              CMP      r0,#0                 ;1736
0000a4  d0b2              BEQ      |L27.12|
0000a6  2000              MOVS     r0,#0                 ;1739
0000a8  e7c9              B        |L27.62|
                  |L27.170|
0000aa  4620              MOV      r0,r4                 ;1707
0000ac  f7fffffe          BL       prvIsQueueEmpty
0000b0  2800              CMP      r0,#0                 ;1707
0000b2  d00e              BEQ      |L27.210|
0000b4  4620              MOV      r0,r4                 ;1710
0000b6  3024              ADDS     r0,r0,#0x24           ;1710
0000b8  9904              LDR      r1,[sp,#0x10]         ;1710
0000ba  f7fffffe          BL       vTaskPlaceOnEventList
0000be  4620              MOV      r0,r4                 ;1711
0000c0  f7fffffe          BL       prvUnlockQueue
0000c4  f7fffffe          BL       xTaskResumeAll
0000c8  2800              CMP      r0,#0                 ;1712
0000ca  d19f              BNE      |L27.12|
0000cc  f7fffffe          BL       vPortYield
0000d0  e79c              B        |L27.12|
                  |L27.210|
0000d2  4620              MOV      r0,r4                 ;1725
0000d4  f7fffffe          BL       prvUnlockQueue
0000d8  f7fffffe          BL       xTaskResumeAll
0000dc  e796              B        |L27.12|
;;;1748   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueuePeekFromISR||, CODE, READONLY, ALIGN=1

                  xQueuePeekFromISR PROC
;;;1840   
;;;1841   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
000000  b5f8              PUSH     {r3-r7,lr}
;;;1842   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
;;;1843   BaseType_t xReturn;
;;;1844   UBaseType_t uxSavedInterruptStatus;
;;;1845   int8_t *pcOriginalReadPosition;
;;;1846   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1847   
;;;1848   	configASSERT( pxQueue );
;;;1849   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1850   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
;;;1851   
;;;1852   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1853   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1854   	above the maximum system call priority are kept permanently enabled, even
;;;1855   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1856   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1857   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1858   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1859   	assigned a priority above the configured maximum system call priority.
;;;1860   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1861   	that have been assigned a priority at or (logically) below the maximum
;;;1862   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1863   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1864   	More information (albeit Cortex-M specific) is provided on the following
;;;1865   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1866   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1867   
;;;1868   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000006  f7fffffe          BL       ulSetInterruptMaskFromISR
00000a  4606              MOV      r6,r0
;;;1869   	{
;;;1870   		/* Cannot block in an ISR, so check there is data available. */
;;;1871   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
00000c  6ba0              LDR      r0,[r4,#0x38]
00000e  2800              CMP      r0,#0
000010  d007              BEQ      |L28.34|
;;;1872   		{
;;;1873   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1874   
;;;1875   			/* Remember the read position so it can be reset as nothing is
;;;1876   			actually being removed from the queue. */
;;;1877   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
000012  68e5              LDR      r5,[r4,#0xc]
;;;1878   			prvCopyDataFromQueue( pxQueue, pvBuffer );
000014  4639              MOV      r1,r7
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       prvCopyDataFromQueue
;;;1879   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
00001c  60e5              STR      r5,[r4,#0xc]
;;;1880   
;;;1881   			xReturn = pdPASS;
00001e  2401              MOVS     r4,#1
000020  e000              B        |L28.36|
                  |L28.34|
;;;1882   		}
;;;1883   		else
;;;1884   		{
;;;1885   			xReturn = pdFAIL;
000022  2400              MOVS     r4,#0
                  |L28.36|
;;;1886   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1887   		}
;;;1888   	}
;;;1889   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1890   
;;;1891   	return xReturn;
00002a  4620              MOV      r0,r4
;;;1892   }
00002c  bdf8              POP      {r3-r7,pc}
;;;1893   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceive||, CODE, READONLY, ALIGN=1

                  xQueueReceive PROC
;;;1238   
;;;1239   BaseType_t xQueueReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait )
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1240   {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
;;;1241   BaseType_t xEntryTimeSet = pdFALSE;
000006  2500              MOVS     r5,#0
;;;1242   TimeOut_t xTimeOut;
;;;1243   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1244   
;;;1245   	/* Check the pointer is not NULL. */
;;;1246   	configASSERT( ( pxQueue ) );
;;;1247   
;;;1248   	/* The buffer into which data is received can only be NULL if the data size
;;;1249   	is zero (so no data is copied into the buffer. */
;;;1250   	configASSERT( !( ( ( pvBuffer ) == NULL ) && ( ( pxQueue )->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1251   
;;;1252   	/* Cannot block if the scheduler is suspended. */
;;;1253   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1254   	{
;;;1255   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1256   	}
;;;1257   	#endif
;;;1258   
;;;1259   
;;;1260   	/* This function relaxes the coding standard somewhat to allow return
;;;1261   	statements within the function itself.  This is done in the interest
;;;1262   	of execution time efficiency. */
;;;1263   
;;;1264   	for( ;; )
000008  2600              MOVS     r6,#0
                  |L29.10|
;;;1265   	{
;;;1266   		taskENTER_CRITICAL();
00000a  f7fffffe          BL       vPortEnterCritical
;;;1267   		{
;;;1268   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00000e  6ba7              LDR      r7,[r4,#0x38]
;;;1269   
;;;1270   			/* Is there data in the queue now?  To be running the calling task
;;;1271   			must be the highest priority task wanting to access the queue. */
;;;1272   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000010  2f00              CMP      r7,#0
000012  d015              BEQ      |L29.64|
;;;1273   			{
;;;1274   				/* Data available, remove one item. */
;;;1275   				prvCopyDataFromQueue( pxQueue, pvBuffer );
000014  4620              MOV      r0,r4
000016  9903              LDR      r1,[sp,#0xc]
000018  f7fffffe          BL       prvCopyDataFromQueue
;;;1276   				traceQUEUE_RECEIVE( pxQueue );
;;;1277   				pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
00001c  1e7f              SUBS     r7,r7,#1
00001e  63a7              STR      r7,[r4,#0x38]
;;;1278   
;;;1279   				/* There is now space in the queue, were any tasks waiting to
;;;1280   				post to the queue?  If so, unblock the highest priority waiting
;;;1281   				task. */
;;;1282   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000020  6920              LDR      r0,[r4,#0x10]
000022  2800              CMP      r0,#0
000024  d007              BEQ      |L29.54|
;;;1283   				{
;;;1284   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000026  4620              MOV      r0,r4
000028  3010              ADDS     r0,r0,#0x10
00002a  f7fffffe          BL       xTaskRemoveFromEventList
00002e  2800              CMP      r0,#0
000030  d001              BEQ      |L29.54|
;;;1285   					{
;;;1286   						queueYIELD_IF_USING_PREEMPTION();
000032  f7fffffe          BL       vPortYield
                  |L29.54|
;;;1287   					}
;;;1288   					else
;;;1289   					{
;;;1290   						mtCOVERAGE_TEST_MARKER();
;;;1291   					}
;;;1292   				}
;;;1293   				else
;;;1294   				{
;;;1295   					mtCOVERAGE_TEST_MARKER();
;;;1296   				}
;;;1297   
;;;1298   				taskEXIT_CRITICAL();
000036  f7fffffe          BL       vPortExitCritical
;;;1299   				return pdPASS;
00003a  2001              MOVS     r0,#1
                  |L29.60|
;;;1300   			}
;;;1301   			else
;;;1302   			{
;;;1303   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1304   				{
;;;1305   					/* The queue was empty and no block time is specified (or
;;;1306   					the block time has expired) so leave now. */
;;;1307   					taskEXIT_CRITICAL();
;;;1308   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1309   					return errQUEUE_EMPTY;
;;;1310   				}
;;;1311   				else if( xEntryTimeSet == pdFALSE )
;;;1312   				{
;;;1313   					/* The queue was empty and a block time was specified so
;;;1314   					configure the timeout structure. */
;;;1315   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1316   					xEntryTimeSet = pdTRUE;
;;;1317   				}
;;;1318   				else
;;;1319   				{
;;;1320   					/* Entry time was already set. */
;;;1321   					mtCOVERAGE_TEST_MARKER();
;;;1322   				}
;;;1323   			}
;;;1324   		}
;;;1325   		taskEXIT_CRITICAL();
;;;1326   
;;;1327   		/* Interrupts and other tasks can send to and receive from the queue
;;;1328   		now the critical section has been exited. */
;;;1329   
;;;1330   		vTaskSuspendAll();
;;;1331   		prvLockQueue( pxQueue );
;;;1332   
;;;1333   		/* Update the timeout state to see if it has expired yet. */
;;;1334   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1335   		{
;;;1336   			/* The timeout has not expired.  If the queue is still empty place
;;;1337   			the task on the list of tasks waiting to receive from the queue. */
;;;1338   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1339   			{
;;;1340   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1341   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1342   				prvUnlockQueue( pxQueue );
;;;1343   				if( xTaskResumeAll() == pdFALSE )
;;;1344   				{
;;;1345   					portYIELD_WITHIN_API();
;;;1346   				}
;;;1347   				else
;;;1348   				{
;;;1349   					mtCOVERAGE_TEST_MARKER();
;;;1350   				}
;;;1351   			}
;;;1352   			else
;;;1353   			{
;;;1354   				/* The queue contains data again.  Loop back to try and read the
;;;1355   				data. */
;;;1356   				prvUnlockQueue( pxQueue );
;;;1357   				( void ) xTaskResumeAll();
;;;1358   			}
;;;1359   		}
;;;1360   		else
;;;1361   		{
;;;1362   			/* Timed out.  If there is no data in the queue exit, otherwise loop
;;;1363   			back and attempt to read the data. */
;;;1364   			prvUnlockQueue( pxQueue );
;;;1365   			( void ) xTaskResumeAll();
;;;1366   
;;;1367   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1368   			{
;;;1369   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1370   				return errQUEUE_EMPTY;
;;;1371   			}
;;;1372   			else
;;;1373   			{
;;;1374   				mtCOVERAGE_TEST_MARKER();
;;;1375   			}
;;;1376   		}
;;;1377   	}
;;;1378   }
00003c  b005              ADD      sp,sp,#0x14
00003e  bdf0              POP      {r4-r7,pc}
                  |L29.64|
000040  9804              LDR      r0,[sp,#0x10]         ;1303
000042  2800              CMP      r0,#0                 ;1303
000044  d002              BEQ      |L29.76|
000046  2d00              CMP      r5,#0                 ;1311
000048  d004              BEQ      |L29.84|
00004a  e007              B        |L29.92|
                  |L29.76|
00004c  f7fffffe          BL       vPortExitCritical
000050  2000              MOVS     r0,#0                 ;1309
000052  e7f3              B        |L29.60|
                  |L29.84|
000054  4668              MOV      r0,sp                 ;1315
000056  f7fffffe          BL       vTaskInternalSetTimeOutState
00005a  2501              MOVS     r5,#1                 ;1316
                  |L29.92|
00005c  f7fffffe          BL       vPortExitCritical
000060  f7fffffe          BL       vTaskSuspendAll
000064  f7fffffe          BL       vPortEnterCritical
000068  4620              MOV      r0,r4                 ;1331
00006a  3040              ADDS     r0,r0,#0x40           ;1331
00006c  2104              MOVS     r1,#4                 ;1331
00006e  5641              LDRSB    r1,[r0,r1]            ;1331
000070  1c49              ADDS     r1,r1,#1              ;1331
000072  d100              BNE      |L29.118|
000074  7106              STRB     r6,[r0,#4]            ;1331
                  |L29.118|
000076  2105              MOVS     r1,#5                 ;1331
000078  5641              LDRSB    r1,[r0,r1]            ;1331
00007a  1c49              ADDS     r1,r1,#1              ;1331
00007c  d100              BNE      |L29.128|
00007e  7146              STRB     r6,[r0,#5]            ;1331
                  |L29.128|
000080  f7fffffe          BL       vPortExitCritical
000084  a904              ADD      r1,sp,#0x10           ;1334
000086  4668              MOV      r0,sp                 ;1334
000088  f7fffffe          BL       xTaskCheckForTimeOut
00008c  2800              CMP      r0,#0                 ;1334
00008e  d00b              BEQ      |L29.168|
000090  4620              MOV      r0,r4                 ;1364
000092  f7fffffe          BL       prvUnlockQueue
000096  f7fffffe          BL       xTaskResumeAll
00009a  4620              MOV      r0,r4                 ;1367
00009c  f7fffffe          BL       prvIsQueueEmpty
0000a0  2800              CMP      r0,#0                 ;1367
0000a2  d0b2              BEQ      |L29.10|
0000a4  2000              MOVS     r0,#0                 ;1370
0000a6  e7c9              B        |L29.60|
                  |L29.168|
0000a8  4620              MOV      r0,r4                 ;1338
0000aa  f7fffffe          BL       prvIsQueueEmpty
0000ae  2800              CMP      r0,#0                 ;1338
0000b0  d00e              BEQ      |L29.208|
0000b2  4620              MOV      r0,r4                 ;1341
0000b4  3024              ADDS     r0,r0,#0x24           ;1341
0000b6  9904              LDR      r1,[sp,#0x10]         ;1341
0000b8  f7fffffe          BL       vTaskPlaceOnEventList
0000bc  4620              MOV      r0,r4                 ;1342
0000be  f7fffffe          BL       prvUnlockQueue
0000c2  f7fffffe          BL       xTaskResumeAll
0000c6  2800              CMP      r0,#0                 ;1343
0000c8  d19f              BNE      |L29.10|
0000ca  f7fffffe          BL       vPortYield
0000ce  e79c              B        |L29.10|
                  |L29.208|
0000d0  4620              MOV      r0,r4                 ;1356
0000d2  f7fffffe          BL       prvUnlockQueue
0000d6  f7fffffe          BL       xTaskResumeAll
0000da  e796              B        |L29.10|
;;;1379   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueReceiveFromISR||, CODE, READONLY, ALIGN=1

                  xQueueReceiveFromISR PROC
;;;1749   
;;;1750   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1751   {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
;;;1752   BaseType_t xReturn;
;;;1753   UBaseType_t uxSavedInterruptStatus;
;;;1754   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1755   
;;;1756   	configASSERT( pxQueue );
;;;1757   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
;;;1758   
;;;1759   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1760   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1761   	above the maximum system call priority are kept permanently enabled, even
;;;1762   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1763   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1764   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1765   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1766   	assigned a priority above the configured maximum system call priority.
;;;1767   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1768   	that have been assigned a priority at or (logically) below the maximum
;;;1769   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1770   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1771   	More information (albeit Cortex-M specific) is provided on the following
;;;1772   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1773   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1774   
;;;1775   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000006  f7fffffe          BL       ulSetInterruptMaskFromISR
00000a  9001              STR      r0,[sp,#4]
;;;1776   	{
;;;1777   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00000c  6ba6              LDR      r6,[r4,#0x38]
;;;1778   
;;;1779   		/* Cannot block in an ISR, so check there is data available. */
;;;1780   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00000e  2e00              CMP      r6,#0
000010  d020              BEQ      |L30.84|
;;;1781   		{
;;;1782   			const int8_t cRxLock = pxQueue->cRxLock;
000012  4620              MOV      r0,r4
000014  3040              ADDS     r0,r0,#0x40
000016  2504              MOVS     r5,#4
000018  5745              LDRSB    r5,[r0,r5]
00001a  4607              MOV      r7,r0
;;;1783   
;;;1784   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1785   
;;;1786   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00001c  4620              MOV      r0,r4
00001e  9903              LDR      r1,[sp,#0xc]
000020  f7fffffe          BL       prvCopyDataFromQueue
;;;1787   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - ( UBaseType_t ) 1;
000024  1e76              SUBS     r6,r6,#1
000026  63a6              STR      r6,[r4,#0x38]
;;;1788   
;;;1789   			/* If the queue is locked the event list will not be modified.
;;;1790   			Instead update the lock count so the task that unlocks the queue
;;;1791   			will know that an ISR has removed data while the queue was
;;;1792   			locked. */
;;;1793   			if( cRxLock == queueUNLOCKED )
000028  1c68              ADDS     r0,r5,#1
00002a  d003              BEQ      |L30.52|
;;;1794   			{
;;;1795   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1796   				{
;;;1797   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1798   					{
;;;1799   						/* The task waiting has a higher priority than us so
;;;1800   						force a context switch. */
;;;1801   						if( pxHigherPriorityTaskWoken != NULL )
;;;1802   						{
;;;1803   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1804   						}
;;;1805   						else
;;;1806   						{
;;;1807   							mtCOVERAGE_TEST_MARKER();
;;;1808   						}
;;;1809   					}
;;;1810   					else
;;;1811   					{
;;;1812   						mtCOVERAGE_TEST_MARKER();
;;;1813   					}
;;;1814   				}
;;;1815   				else
;;;1816   				{
;;;1817   					mtCOVERAGE_TEST_MARKER();
;;;1818   				}
;;;1819   			}
;;;1820   			else
;;;1821   			{
;;;1822   				/* Increment the lock count so the task that unlocks the queue
;;;1823   				knows that data was removed while it was locked. */
;;;1824   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
00002c  1c6d              ADDS     r5,r5,#1
00002e  713d              STRB     r5,[r7,#4]
                  |L30.48|
;;;1825   			}
;;;1826   
;;;1827   			xReturn = pdPASS;
000030  2401              MOVS     r4,#1
;;;1828   		}
000032  e010              B        |L30.86|
                  |L30.52|
000034  6920              LDR      r0,[r4,#0x10]         ;1795
000036  2800              CMP      r0,#0                 ;1795
000038  d0fa              BEQ      |L30.48|
00003a  4620              MOV      r0,r4                 ;1797
00003c  3010              ADDS     r0,r0,#0x10           ;1797
00003e  f7fffffe          BL       xTaskRemoveFromEventList
000042  2800              CMP      r0,#0                 ;1797
000044  d0f4              BEQ      |L30.48|
000046  9804              LDR      r0,[sp,#0x10]         ;1801
000048  2800              CMP      r0,#0                 ;1801
00004a  d0f1              BEQ      |L30.48|
00004c  9804              LDR      r0,[sp,#0x10]         ;1803
00004e  2101              MOVS     r1,#1                 ;1803
000050  6001              STR      r1,[r0,#0]            ;1803
000052  e7ed              B        |L30.48|
                  |L30.84|
;;;1829   		else
;;;1830   		{
;;;1831   			xReturn = pdFAIL;
000054  2400              MOVS     r4,#0
                  |L30.86|
;;;1832   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1833   		}
;;;1834   	}
;;;1835   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000056  9801              LDR      r0,[sp,#4]
000058  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1836   
;;;1837   	return xReturn;
00005c  4620              MOV      r0,r4
;;;1838   }
00005e  b005              ADD      sp,sp,#0x14
000060  bdf0              POP      {r4-r7,pc}
;;;1839   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xQueueSemaphoreTake||, CODE, READONLY, ALIGN=1

                  xQueueSemaphoreTake PROC
;;;1380   
;;;1381   BaseType_t xQueueSemaphoreTake( QueueHandle_t xQueue, TickType_t xTicksToWait )
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;1382   {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
;;;1383   BaseType_t xEntryTimeSet = pdFALSE;
000006  2500              MOVS     r5,#0
;;;1384   TimeOut_t xTimeOut;
;;;1385   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1386   
;;;1387   #if( configUSE_MUTEXES == 1 )
;;;1388   	BaseType_t xInheritanceOccurred = pdFALSE;
000008  2700              MOVS     r7,#0
;;;1389   #endif
;;;1390   
;;;1391   	/* Check the queue pointer is not NULL. */
;;;1392   	configASSERT( ( pxQueue ) );
;;;1393   
;;;1394   	/* Check this really is a semaphore, in which case the item size will be
;;;1395   	0. */
;;;1396   	configASSERT( pxQueue->uxItemSize == 0 );
;;;1397   
;;;1398   	/* Cannot block if the scheduler is suspended. */
;;;1399   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1400   	{
;;;1401   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;1402   	}
;;;1403   	#endif
;;;1404   
;;;1405   
;;;1406   	/* This function relaxes the coding standard somewhat to allow return
;;;1407   	statements within the function itself.  This is done in the interest
;;;1408   	of execution time efficiency. */
;;;1409   
;;;1410   	for( ;; )
00000a  2600              MOVS     r6,#0
                  |L31.12|
;;;1411   	{
;;;1412   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;1413   		{
;;;1414   			/* Semaphores are queues with an item size of 0, and where the
;;;1415   			number of messages in the queue is the semaphore's count value. */
;;;1416   			const UBaseType_t uxSemaphoreCount = pxQueue->uxMessagesWaiting;
000010  6ba0              LDR      r0,[r4,#0x38]
;;;1417   
;;;1418   			/* Is there data in the queue now?  To be running the calling task
;;;1419   			must be the highest priority task wanting to access the queue. */
;;;1420   			if( uxSemaphoreCount > ( UBaseType_t ) 0 )
000012  2800              CMP      r0,#0
000014  d017              BEQ      |L31.70|
;;;1421   			{
;;;1422   				traceQUEUE_RECEIVE( pxQueue );
;;;1423   
;;;1424   				/* Semaphores are queues with a data size of zero and where the
;;;1425   				messages waiting is the semaphore's count.  Reduce the count. */
;;;1426   				pxQueue->uxMessagesWaiting = uxSemaphoreCount - ( UBaseType_t ) 1;
000016  1e40              SUBS     r0,r0,#1
000018  63a0              STR      r0,[r4,#0x38]
;;;1427   
;;;1428   				#if ( configUSE_MUTEXES == 1 )
;;;1429   				{
;;;1430   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
00001a  6820              LDR      r0,[r4,#0]
00001c  2800              CMP      r0,#0
00001e  d102              BNE      |L31.38|
;;;1431   					{
;;;1432   						/* Record the information required to implement
;;;1433   						priority inheritance should it become necessary. */
;;;1434   						pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
000020  f7fffffe          BL       pvTaskIncrementMutexHeldCount
000024  6060              STR      r0,[r4,#4]
                  |L31.38|
;;;1435   					}
;;;1436   					else
;;;1437   					{
;;;1438   						mtCOVERAGE_TEST_MARKER();
;;;1439   					}
;;;1440   				}
;;;1441   				#endif /* configUSE_MUTEXES */
;;;1442   
;;;1443   				/* Check to see if other tasks are blocked waiting to give the
;;;1444   				semaphore, and if so, unblock the highest priority such task. */
;;;1445   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
000026  6920              LDR      r0,[r4,#0x10]
000028  2800              CMP      r0,#0
00002a  d007              BEQ      |L31.60|
;;;1446   				{
;;;1447   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
00002c  4620              MOV      r0,r4
00002e  3010              ADDS     r0,r0,#0x10
000030  f7fffffe          BL       xTaskRemoveFromEventList
000034  2800              CMP      r0,#0
000036  d001              BEQ      |L31.60|
;;;1448   					{
;;;1449   						queueYIELD_IF_USING_PREEMPTION();
000038  f7fffffe          BL       vPortYield
                  |L31.60|
;;;1450   					}
;;;1451   					else
;;;1452   					{
;;;1453   						mtCOVERAGE_TEST_MARKER();
;;;1454   					}
;;;1455   				}
;;;1456   				else
;;;1457   				{
;;;1458   					mtCOVERAGE_TEST_MARKER();
;;;1459   				}
;;;1460   
;;;1461   				taskEXIT_CRITICAL();
00003c  f7fffffe          BL       vPortExitCritical
;;;1462   				return pdPASS;
000040  2001              MOVS     r0,#1
                  |L31.66|
;;;1463   			}
;;;1464   			else
;;;1465   			{
;;;1466   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1467   				{
;;;1468   					/* For inheritance to have occurred there must have been an
;;;1469   					initial timeout, and an adjusted timeout cannot become 0, as
;;;1470   					if it were 0 the function would have exited. */
;;;1471   					#if( configUSE_MUTEXES == 1 )
;;;1472   					{
;;;1473   						configASSERT( xInheritanceOccurred == pdFALSE );
;;;1474   					}
;;;1475   					#endif /* configUSE_MUTEXES */
;;;1476   
;;;1477   					/* The semaphore count was 0 and no block time is specified
;;;1478   					(or the block time has expired) so exit now. */
;;;1479   					taskEXIT_CRITICAL();
;;;1480   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1481   					return errQUEUE_EMPTY;
;;;1482   				}
;;;1483   				else if( xEntryTimeSet == pdFALSE )
;;;1484   				{
;;;1485   					/* The semaphore count was 0 and a block time was specified
;;;1486   					so configure the timeout structure ready to block. */
;;;1487   					vTaskInternalSetTimeOutState( &xTimeOut );
;;;1488   					xEntryTimeSet = pdTRUE;
;;;1489   				}
;;;1490   				else
;;;1491   				{
;;;1492   					/* Entry time was already set. */
;;;1493   					mtCOVERAGE_TEST_MARKER();
;;;1494   				}
;;;1495   			}
;;;1496   		}
;;;1497   		taskEXIT_CRITICAL();
;;;1498   
;;;1499   		/* Interrupts and other tasks can give to and take from the semaphore
;;;1500   		now the critical section has been exited. */
;;;1501   
;;;1502   		vTaskSuspendAll();
;;;1503   		prvLockQueue( pxQueue );
;;;1504   
;;;1505   		/* Update the timeout state to see if it has expired yet. */
;;;1506   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1507   		{
;;;1508   			/* A block time is specified and not expired.  If the semaphore
;;;1509   			count is 0 then enter the Blocked state to wait for a semaphore to
;;;1510   			become available.  As semaphores are implemented with queues the
;;;1511   			queue being empty is equivalent to the semaphore count being 0. */
;;;1512   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1513   			{
;;;1514   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1515   
;;;1516   				#if ( configUSE_MUTEXES == 1 )
;;;1517   				{
;;;1518   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1519   					{
;;;1520   						taskENTER_CRITICAL();
;;;1521   						{
;;;1522   							xInheritanceOccurred = xTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1523   						}
;;;1524   						taskEXIT_CRITICAL();
;;;1525   					}
;;;1526   					else
;;;1527   					{
;;;1528   						mtCOVERAGE_TEST_MARKER();
;;;1529   					}
;;;1530   				}
;;;1531   				#endif
;;;1532   
;;;1533   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1534   				prvUnlockQueue( pxQueue );
;;;1535   				if( xTaskResumeAll() == pdFALSE )
;;;1536   				{
;;;1537   					portYIELD_WITHIN_API();
;;;1538   				}
;;;1539   				else
;;;1540   				{
;;;1541   					mtCOVERAGE_TEST_MARKER();
;;;1542   				}
;;;1543   			}
;;;1544   			else
;;;1545   			{
;;;1546   				/* There was no timeout and the semaphore count was not 0, so
;;;1547   				attempt to take the semaphore again. */
;;;1548   				prvUnlockQueue( pxQueue );
;;;1549   				( void ) xTaskResumeAll();
;;;1550   			}
;;;1551   		}
;;;1552   		else
;;;1553   		{
;;;1554   			/* Timed out. */
;;;1555   			prvUnlockQueue( pxQueue );
;;;1556   			( void ) xTaskResumeAll();
;;;1557   
;;;1558   			/* If the semaphore count is 0 exit now as the timeout has
;;;1559   			expired.  Otherwise return to attempt to take the semaphore that is
;;;1560   			known to be available.  As semaphores are implemented by queues the
;;;1561   			queue being empty is equivalent to the semaphore count being 0. */
;;;1562   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1563   			{
;;;1564   				#if ( configUSE_MUTEXES == 1 )
;;;1565   				{
;;;1566   					/* xInheritanceOccurred could only have be set if
;;;1567   					pxQueue->uxQueueType == queueQUEUE_IS_MUTEX so no need to
;;;1568   					test the mutex type again to check it is actually a mutex. */
;;;1569   					if( xInheritanceOccurred != pdFALSE )
;;;1570   					{
;;;1571   						taskENTER_CRITICAL();
;;;1572   						{
;;;1573   							UBaseType_t uxHighestWaitingPriority;
;;;1574   
;;;1575   							/* This task blocking on the mutex caused another
;;;1576   							task to inherit this task's priority.  Now this task
;;;1577   							has timed out the priority should be disinherited
;;;1578   							again, but only as low as the next highest priority
;;;1579   							task that is waiting for the same mutex. */
;;;1580   							uxHighestWaitingPriority = prvGetDisinheritPriorityAfterTimeout( pxQueue );
;;;1581   							vTaskPriorityDisinheritAfterTimeout( ( void * ) pxQueue->pxMutexHolder, uxHighestWaitingPriority );
;;;1582   						}
;;;1583   						taskEXIT_CRITICAL();
;;;1584   					}
;;;1585   				}
;;;1586   				#endif /* configUSE_MUTEXES */
;;;1587   
;;;1588   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1589   				return errQUEUE_EMPTY;
;;;1590   			}
;;;1591   			else
;;;1592   			{
;;;1593   				mtCOVERAGE_TEST_MARKER();
;;;1594   			}
;;;1595   		}
;;;1596   	}
;;;1597   }
000042  b005              ADD      sp,sp,#0x14
000044  bdf0              POP      {r4-r7,pc}
                  |L31.70|
000046  9804              LDR      r0,[sp,#0x10]         ;1466
000048  2800              CMP      r0,#0                 ;1466
00004a  d002              BEQ      |L31.82|
00004c  2d00              CMP      r5,#0                 ;1483
00004e  d004              BEQ      |L31.90|
000050  e007              B        |L31.98|
                  |L31.82|
000052  f7fffffe          BL       vPortExitCritical
000056  2000              MOVS     r0,#0                 ;1481
000058  e7f3              B        |L31.66|
                  |L31.90|
00005a  a801              ADD      r0,sp,#4              ;1487
00005c  f7fffffe          BL       vTaskInternalSetTimeOutState
000060  2501              MOVS     r5,#1                 ;1488
                  |L31.98|
000062  f7fffffe          BL       vPortExitCritical
000066  f7fffffe          BL       vTaskSuspendAll
00006a  f7fffffe          BL       vPortEnterCritical
00006e  4620              MOV      r0,r4                 ;1503
000070  3040              ADDS     r0,r0,#0x40           ;1503
000072  2104              MOVS     r1,#4                 ;1503
000074  5641              LDRSB    r1,[r0,r1]            ;1503
000076  1c49              ADDS     r1,r1,#1              ;1503
000078  d100              BNE      |L31.124|
00007a  7106              STRB     r6,[r0,#4]            ;1503
                  |L31.124|
00007c  2105              MOVS     r1,#5                 ;1503
00007e  5641              LDRSB    r1,[r0,r1]            ;1503
000080  1c49              ADDS     r1,r1,#1              ;1503
000082  d100              BNE      |L31.134|
000084  7146              STRB     r6,[r0,#5]            ;1503
                  |L31.134|
000086  f7fffffe          BL       vPortExitCritical
00008a  a904              ADD      r1,sp,#0x10           ;1506
00008c  a801              ADD      r0,sp,#4              ;1506
00008e  f7fffffe          BL       xTaskCheckForTimeOut
000092  2800              CMP      r0,#0                 ;1506
000094  d018              BEQ      |L31.200|
000096  4620              MOV      r0,r4                 ;1555
000098  f7fffffe          BL       prvUnlockQueue
00009c  f7fffffe          BL       xTaskResumeAll
0000a0  4620              MOV      r0,r4                 ;1562
0000a2  f7fffffe          BL       prvIsQueueEmpty
0000a6  2800              CMP      r0,#0                 ;1562
0000a8  d0b0              BEQ      |L31.12|
0000aa  2f00              CMP      r7,#0                 ;1569
0000ac  d00a              BEQ      |L31.196|
0000ae  f7fffffe          BL       vPortEnterCritical
0000b2  4620              MOV      r0,r4                 ;1580
0000b4  f7fffffe          BL       prvGetDisinheritPriorityAfterTimeout
0000b8  4601              MOV      r1,r0                 ;1580
0000ba  6860              LDR      r0,[r4,#4]            ;1581
0000bc  f7fffffe          BL       vTaskPriorityDisinheritAfterTimeout
0000c0  f7fffffe          BL       vPortExitCritical
                  |L31.196|
0000c4  2000              MOVS     r0,#0                 ;1589
0000c6  e7bc              B        |L31.66|
                  |L31.200|
0000c8  4620              MOV      r0,r4                 ;1512
0000ca  f7fffffe          BL       prvIsQueueEmpty
0000ce  2800              CMP      r0,#0                 ;1512
0000d0  d019              BEQ      |L31.262|
0000d2  6820              LDR      r0,[r4,#0]            ;1518
0000d4  2800              CMP      r0,#0                 ;1518
0000d6  d107              BNE      |L31.232|
0000d8  f7fffffe          BL       vPortEnterCritical
0000dc  6860              LDR      r0,[r4,#4]            ;1522
0000de  f7fffffe          BL       xTaskPriorityInherit
0000e2  4607              MOV      r7,r0                 ;1522
0000e4  f7fffffe          BL       vPortExitCritical
                  |L31.232|
0000e8  4620              MOV      r0,r4                 ;1533
0000ea  3024              ADDS     r0,r0,#0x24           ;1533
0000ec  9904              LDR      r1,[sp,#0x10]         ;1533
0000ee  f7fffffe          BL       vTaskPlaceOnEventList
0000f2  4620              MOV      r0,r4                 ;1534
0000f4  f7fffffe          BL       prvUnlockQueue
0000f8  f7fffffe          BL       xTaskResumeAll
0000fc  2800              CMP      r0,#0                 ;1535
0000fe  d185              BNE      |L31.12|
000100  f7fffffe          BL       vPortYield
000104  e782              B        |L31.12|
                  |L31.262|
000106  4620              MOV      r0,r4                 ;1548
000108  f7fffffe          BL       prvUnlockQueue
00010c  f7fffffe          BL       xTaskResumeAll
000110  e77c              B        |L31.12|
;;;1598   /*-----------------------------------------------------------*/
                          ENDP


;*** Start embedded assembler ***

#line 1 "Common\\CMSIS-FreeRTOS\\10.0.1\\Source\\queue.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_48e2f297____REV16|
#line 492 "C:\\Users\\bbb\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___7_queue_c_48e2f297____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_queue_c_48e2f297____REVSH|
#line 507
|__asm___7_queue_c_48e2f297____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
