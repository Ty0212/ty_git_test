; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\event_groups.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\event_groups.d --cpu=Cortex-M0 --apcs=interwork -O1 --diag_suppress=9931 -I.\APP -I.\APP\TN2115s_libs -I.\Common\CMSIS-FreeRTOS\10.0.1\Source\include -I.\Common\RTE\RTOS -I.\Common\CMSIS-FreeRTOS\10.0.1\CMSIS\RTOS2\FreeRTOS\Include -I.\Common\CMSIS-FreeRTOS\10.0.1\Source\portable\RVDS\ARM_CM0 -I.\APP\EINK -I.\Device_desc -I.\Common\CMSIS-FreeRTOS\10.0.1\Source -I.\Common\RTE\Device\ARMCM0 -I.\RTE\_soc_m0 -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\Device\ARM\ARMCM0\Include -D__MICROLIB -D__UVISION_VERSION=529 -D_RTE_ -DARMCM0 --omf_browse=.\objects\event_groups.crf Common\CMSIS-FreeRTOS\10.0.1\Source\event_groups.c]
                          THUMB

                          AREA ||i.prvTestWaitCondition||, CODE, READONLY, ALIGN=1

                  prvTestWaitCondition PROC
;;;655    
;;;656    static BaseType_t prvTestWaitCondition( const EventBits_t uxCurrentEventBits, const EventBits_t uxBitsToWaitFor, const BaseType_t xWaitForAllBits )
000000  4603              MOV      r3,r0
;;;657    {
;;;658    BaseType_t xWaitConditionMet = pdFALSE;
000002  2000              MOVS     r0,#0
;;;659    
;;;660    	if( xWaitForAllBits == pdFALSE )
000004  2a00              CMP      r2,#0
000006  d003              BEQ      |L1.16|
;;;661    	{
;;;662    		/* Task only has to wait for one bit within uxBitsToWaitFor to be
;;;663    		set.  Is one already set? */
;;;664    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) != ( EventBits_t ) 0 )
;;;665    		{
;;;666    			xWaitConditionMet = pdTRUE;
;;;667    		}
;;;668    		else
;;;669    		{
;;;670    			mtCOVERAGE_TEST_MARKER();
;;;671    		}
;;;672    	}
;;;673    	else
;;;674    	{
;;;675    		/* Task has to wait for all the bits in uxBitsToWaitFor to be set.
;;;676    		Are they set already? */
;;;677    		if( ( uxCurrentEventBits & uxBitsToWaitFor ) == uxBitsToWaitFor )
000008  4399              BICS     r1,r1,r3
00000a  d100              BNE      |L1.14|
;;;678    		{
;;;679    			xWaitConditionMet = pdTRUE;
00000c  2001              MOVS     r0,#1
                  |L1.14|
;;;680    		}
;;;681    		else
;;;682    		{
;;;683    			mtCOVERAGE_TEST_MARKER();
;;;684    		}
;;;685    	}
;;;686    
;;;687    	return xWaitConditionMet;
;;;688    }
00000e  4770              BX       lr
                  |L1.16|
000010  420b              TST      r3,r1                 ;664
000012  d0fc              BEQ      |L1.14|
000014  2001              MOVS     r0,#1                 ;666
000016  4770              BX       lr
;;;689    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupClearBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupClearBitsCallback PROC
;;;649    an interrupt. */
;;;650    void vEventGroupClearBitsCallback( void *pvEventGroup, const uint32_t ulBitsToClear )
000000  b510              PUSH     {r4,lr}
;;;651    {
;;;652    	( void ) xEventGroupClearBits( pvEventGroup, ( EventBits_t ) ulBitsToClear );
000002  f7fffffe          BL       xEventGroupClearBits
;;;653    }
000006  bd10              POP      {r4,pc}
;;;654    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupDelete||, CODE, READONLY, ALIGN=1

                  vEventGroupDelete PROC
;;;597    
;;;598    void vEventGroupDelete( EventGroupHandle_t xEventGroup )
000000  b570              PUSH     {r4-r6,lr}
;;;599    {
000002  4605              MOV      r5,r0
;;;600    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;601    const List_t *pxTasksWaitingForBits = &( pxEventBits->xTasksWaitingForBits );
000004  1d2c              ADDS     r4,r5,#4
;;;602    
;;;603    	vTaskSuspendAll();
000006  f7fffffe          BL       vTaskSuspendAll
;;;604    	{
;;;605    		traceEVENT_GROUP_DELETE( xEventGroup );
;;;606    
;;;607    		while( listCURRENT_LIST_LENGTH( pxTasksWaitingForBits ) > ( UBaseType_t ) 0 )
;;;608    		{
;;;609    			/* Unblock the task, returning 0 as the event list is being deleted
;;;610    			and cannot therefore have any bits set. */
;;;611    			configASSERT( pxTasksWaitingForBits->xListEnd.pxNext != ( const ListItem_t * ) &( pxTasksWaitingForBits->xListEnd ) );
;;;612    			vTaskRemoveFromUnorderedEventList( pxTasksWaitingForBits->xListEnd.pxNext, eventUNBLOCKED_DUE_TO_BIT_SET );
00000a  2601              MOVS     r6,#1
00000c  0676              LSLS     r6,r6,#25
00000e  e003              B        |L3.24|
                  |L3.16|
000010  4631              MOV      r1,r6
000012  68e0              LDR      r0,[r4,#0xc]
000014  f7fffffe          BL       vTaskRemoveFromUnorderedEventList
                  |L3.24|
000018  6820              LDR      r0,[r4,#0]            ;607
00001a  2800              CMP      r0,#0                 ;607
00001c  d1f8              BNE      |L3.16|
;;;613    		}
;;;614    
;;;615    		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;616    		{
;;;617    			/* The event group can only have been allocated dynamically - free
;;;618    			it again. */
;;;619    			vPortFree( pxEventBits );
;;;620    		}
;;;621    		#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;622    		{
;;;623    			/* The event group could have been allocated statically or
;;;624    			dynamically, so check before attempting to free the memory. */
;;;625    			if( pxEventBits->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
00001e  7e28              LDRB     r0,[r5,#0x18]
000020  2800              CMP      r0,#0
000022  d102              BNE      |L3.42|
;;;626    			{
;;;627    				vPortFree( pxEventBits );
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       vPortFree
                  |L3.42|
;;;628    			}
;;;629    			else
;;;630    			{
;;;631    				mtCOVERAGE_TEST_MARKER();
;;;632    			}
;;;633    		}
;;;634    		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;635    	}
;;;636    	( void ) xTaskResumeAll();
00002a  f7fffffe          BL       xTaskResumeAll
;;;637    }
00002e  bd70              POP      {r4-r6,pc}
;;;638    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vEventGroupSetBitsCallback||, CODE, READONLY, ALIGN=1

                  vEventGroupSetBitsCallback PROC
;;;641    an interrupt. */
;;;642    void vEventGroupSetBitsCallback( void *pvEventGroup, const uint32_t ulBitsToSet )
000000  b510              PUSH     {r4,lr}
;;;643    {
;;;644    	( void ) xEventGroupSetBits( pvEventGroup, ( EventBits_t ) ulBitsToSet );
000002  f7fffffe          BL       xEventGroupSetBits
;;;645    }
000006  bd10              POP      {r4,pc}
;;;646    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupClearBits||, CODE, READONLY, ALIGN=1

                  xEventGroupClearBits PROC
;;;445    
;;;446    EventBits_t xEventGroupClearBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToClear )
000000  b570              PUSH     {r4-r6,lr}
;;;447    {
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;448    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;449    EventBits_t uxReturn;
;;;450    
;;;451    	/* Check the user is not attempting to clear the bits used by the kernel
;;;452    	itself. */
;;;453    	configASSERT( xEventGroup );
;;;454    	configASSERT( ( uxBitsToClear & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
;;;455    
;;;456    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;457    	{
;;;458    		traceEVENT_GROUP_CLEAR_BITS( xEventGroup, uxBitsToClear );
;;;459    
;;;460    		/* The value returned is the event group value prior to the bits being
;;;461    		cleared. */
;;;462    		uxReturn = pxEventBits->uxEventBits;
00000a  6825              LDR      r5,[r4,#0]
;;;463    
;;;464    		/* Clear the bits. */
;;;465    		pxEventBits->uxEventBits &= ~uxBitsToClear;
00000c  4628              MOV      r0,r5
00000e  43b0              BICS     r0,r0,r6
000010  6020              STR      r0,[r4,#0]
;;;466    	}
;;;467    	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;468    
;;;469    	return uxReturn;
000016  4628              MOV      r0,r5
;;;470    }
000018  bd70              POP      {r4-r6,pc}
;;;471    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupCreate||, CODE, READONLY, ALIGN=1

                  xEventGroupCreate PROC
;;;141    
;;;142    	EventGroupHandle_t xEventGroupCreate( void )
000000  b570              PUSH     {r4-r6,lr}
;;;143    	{
;;;144    	EventGroup_t *pxEventBits;
;;;145    
;;;146    		/* Allocate the event group. */
;;;147    		pxEventBits = ( EventGroup_t * ) pvPortMalloc( sizeof( EventGroup_t ) );
000002  201c              MOVS     r0,#0x1c
000004  f7fffffe          BL       pvPortMalloc
000008  4604              MOV      r4,r0
;;;148    
;;;149    		if( pxEventBits != NULL )
00000a  2c00              CMP      r4,#0
00000c  d005              BEQ      |L6.26|
;;;150    		{
;;;151    			pxEventBits->uxEventBits = 0;
00000e  2500              MOVS     r5,#0
000010  6025              STR      r5,[r4,#0]
;;;152    			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
000012  1d20              ADDS     r0,r4,#4
000014  f7fffffe          BL       vListInitialise
;;;153    
;;;154    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;155    			{
;;;156    				/* Both static and dynamic allocation can be used, so note this
;;;157    				event group was allocated statically in case the event group is
;;;158    				later deleted. */
;;;159    				pxEventBits->ucStaticallyAllocated = pdFALSE;
000018  7625              STRB     r5,[r4,#0x18]
                  |L6.26|
;;;160    			}
;;;161    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;162    
;;;163    			traceEVENT_GROUP_CREATE( pxEventBits );
;;;164    		}
;;;165    		else
;;;166    		{
;;;167    			traceEVENT_GROUP_CREATE_FAILED();
;;;168    		}
;;;169    
;;;170    		return ( EventGroupHandle_t ) pxEventBits;
00001a  4620              MOV      r0,r4
;;;171    	}
00001c  bd70              POP      {r4-r6,pc}
;;;172    
                          ENDP


                          AREA ||i.xEventGroupCreateStatic||, CODE, READONLY, ALIGN=1

                  xEventGroupCreateStatic PROC
;;;92     
;;;93     	EventGroupHandle_t xEventGroupCreateStatic( StaticEventGroup_t *pxEventGroupBuffer )
000000  b510              PUSH     {r4,lr}
;;;94     	{
000002  4604              MOV      r4,r0
;;;95     	EventGroup_t *pxEventBits;
;;;96     
;;;97     		/* A StaticEventGroup_t object must be provided. */
;;;98     		configASSERT( pxEventGroupBuffer );
;;;99     
;;;100    		#if( configASSERT_DEFINED == 1 )
;;;101    		{
;;;102    			/* Sanity check that the size of the structure used to declare a
;;;103    			variable of type StaticEventGroup_t equals the size of the real
;;;104    			event group structure. */
;;;105    			volatile size_t xSize = sizeof( StaticEventGroup_t );
;;;106    			configASSERT( xSize == sizeof( EventGroup_t ) );
;;;107    		}
;;;108    		#endif /* configASSERT_DEFINED */
;;;109    
;;;110    		/* The user has provided a statically allocated event group - use it. */
;;;111    		pxEventBits = ( EventGroup_t * ) pxEventGroupBuffer; /*lint !e740 EventGroup_t and StaticEventGroup_t are guaranteed to have the same size and alignment requirement - checked by configASSERT(). */
;;;112    
;;;113    		if( pxEventBits != NULL )
000004  2c00              CMP      r4,#0
000006  d006              BEQ      |L7.22|
;;;114    		{
;;;115    			pxEventBits->uxEventBits = 0;
000008  2000              MOVS     r0,#0
00000a  6020              STR      r0,[r4,#0]
;;;116    			vListInitialise( &( pxEventBits->xTasksWaitingForBits ) );
00000c  1d20              ADDS     r0,r4,#4
00000e  f7fffffe          BL       vListInitialise
;;;117    
;;;118    			#if( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
;;;119    			{
;;;120    				/* Both static and dynamic allocation can be used, so note that
;;;121    				this event group was created statically in case the event group
;;;122    				is later deleted. */
;;;123    				pxEventBits->ucStaticallyAllocated = pdTRUE;
000012  2001              MOVS     r0,#1
000014  7620              STRB     r0,[r4,#0x18]
                  |L7.22|
;;;124    			}
;;;125    			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;126    
;;;127    			traceEVENT_GROUP_CREATE( pxEventBits );
;;;128    		}
;;;129    		else
;;;130    		{
;;;131    			traceEVENT_GROUP_CREATE_FAILED();
;;;132    		}
;;;133    
;;;134    		return ( EventGroupHandle_t ) pxEventBits;
000016  4620              MOV      r0,r4
;;;135    	}
000018  bd10              POP      {r4,pc}
;;;136    
                          ENDP


                          AREA ||i.xEventGroupGetBitsFromISR||, CODE, READONLY, ALIGN=1

                  xEventGroupGetBitsFromISR PROC
;;;487    
;;;488    EventBits_t xEventGroupGetBitsFromISR( EventGroupHandle_t xEventGroup )
000000  b510              PUSH     {r4,lr}
;;;489    {
000002  4604              MOV      r4,r0
;;;490    UBaseType_t uxSavedInterruptStatus;
;;;491    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;492    EventBits_t uxReturn;
;;;493    
;;;494    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000004  f7fffffe          BL       ulSetInterruptMaskFromISR
;;;495    	{
;;;496    		uxReturn = pxEventBits->uxEventBits;
000008  6824              LDR      r4,[r4,#0]
;;;497    	}
;;;498    	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00000a  f7fffffe          BL       vClearInterruptMaskFromISR
;;;499    
;;;500    	return uxReturn;
00000e  4620              MOV      r0,r4
;;;501    }
000010  bd10              POP      {r4,pc}
;;;502    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSetBits||, CODE, READONLY, ALIGN=1

                  xEventGroupSetBits PROC
;;;503    
;;;504    EventBits_t xEventGroupSetBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet )
000000  b5fe              PUSH     {r1-r7,lr}
;;;505    {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
;;;506    ListItem_t *pxListItem, *pxNext;
;;;507    ListItem_t const *pxListEnd;
;;;508    List_t *pxList;
;;;509    EventBits_t uxBitsToClear = 0, uxBitsWaitedFor, uxControlBits;
000006  2500              MOVS     r5,#0
;;;510    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;511    BaseType_t xMatchFound = pdFALSE;
;;;512    
;;;513    	/* Check the user is not attempting to set the bits used by the kernel
;;;514    	itself. */
;;;515    	configASSERT( xEventGroup );
;;;516    	configASSERT( ( uxBitsToSet & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
;;;517    
;;;518    	pxList = &( pxEventBits->xTasksWaitingForBits );
000008  1d26              ADDS     r6,r4,#4
;;;519    	pxListEnd = listGET_END_MARKER( pxList ); /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
00000a  4630              MOV      r0,r6
00000c  3008              ADDS     r0,r0,#8
00000e  9000              STR      r0,[sp,#0]
;;;520    	vTaskSuspendAll();
000010  f7fffffe          BL       vTaskSuspendAll
;;;521    	{
;;;522    		traceEVENT_GROUP_SET_BITS( xEventGroup, uxBitsToSet );
;;;523    
;;;524    		pxListItem = listGET_HEAD_ENTRY( pxList );
000014  68f0              LDR      r0,[r6,#0xc]
;;;525    
;;;526    		/* Set the bits. */
;;;527    		pxEventBits->uxEventBits |= uxBitsToSet;
000016  6821              LDR      r1,[r4,#0]
000018  4339              ORRS     r1,r1,r7
00001a  6021              STR      r1,[r4,#0]
;;;528    
;;;529    		/* See if the new bit value should unblock any tasks. */
;;;530    		while( pxListItem != pxListEnd )
00001c  e01f              B        |L9.94|
                  |L9.30|
;;;531    		{
;;;532    			pxNext = listGET_NEXT( pxListItem );
00001e  6841              LDR      r1,[r0,#4]
000020  9101              STR      r1,[sp,#4]
;;;533    			uxBitsWaitedFor = listGET_LIST_ITEM_VALUE( pxListItem );
000022  6801              LDR      r1,[r0,#0]
;;;534    			xMatchFound = pdFALSE;
000024  2200              MOVS     r2,#0
;;;535    
;;;536    			/* Split the bits waited for from the control bits. */
;;;537    			uxControlBits = uxBitsWaitedFor & eventEVENT_BITS_CONTROL_BYTES;
000026  0e0b              LSRS     r3,r1,#24
000028  061b              LSLS     r3,r3,#24
;;;538    			uxBitsWaitedFor &= ~eventEVENT_BITS_CONTROL_BYTES;
00002a  0209              LSLS     r1,r1,#8
00002c  0a09              LSRS     r1,r1,#8
;;;539    
;;;540    			if( ( uxControlBits & eventWAIT_FOR_ALL_BITS ) == ( EventBits_t ) 0 )
00002e  015e              LSLS     r6,r3,#5
000030  d404              BMI      |L9.60|
;;;541    			{
;;;542    				/* Just looking for single bit being set. */
;;;543    				if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) != ( EventBits_t ) 0 )
000032  6826              LDR      r6,[r4,#0]
000034  420e              TST      r6,r1
000036  d006              BEQ      |L9.70|
;;;544    				{
;;;545    					xMatchFound = pdTRUE;
000038  2201              MOVS     r2,#1
00003a  e004              B        |L9.70|
                  |L9.60|
;;;546    				}
;;;547    				else
;;;548    				{
;;;549    					mtCOVERAGE_TEST_MARKER();
;;;550    				}
;;;551    			}
;;;552    			else if( ( uxBitsWaitedFor & pxEventBits->uxEventBits ) == uxBitsWaitedFor )
00003c  6826              LDR      r6,[r4,#0]
00003e  460f              MOV      r7,r1
000040  43b7              BICS     r7,r7,r6
000042  d100              BNE      |L9.70|
;;;553    			{
;;;554    				/* All bits are set. */
;;;555    				xMatchFound = pdTRUE;
000044  2201              MOVS     r2,#1
                  |L9.70|
;;;556    			}
;;;557    			else
;;;558    			{
;;;559    				/* Need all bits to be set, but not all the bits were set. */
;;;560    			}
;;;561    
;;;562    			if( xMatchFound != pdFALSE )
000046  2a00              CMP      r2,#0
000048  d008              BEQ      |L9.92|
;;;563    			{
;;;564    				/* The bits match.  Should the bits be cleared on exit? */
;;;565    				if( ( uxControlBits & eventCLEAR_EVENTS_ON_EXIT_BIT ) != ( EventBits_t ) 0 )
00004a  01da              LSLS     r2,r3,#7
00004c  d500              BPL      |L9.80|
;;;566    				{
;;;567    					uxBitsToClear |= uxBitsWaitedFor;
00004e  430d              ORRS     r5,r5,r1
                  |L9.80|
;;;568    				}
;;;569    				else
;;;570    				{
;;;571    					mtCOVERAGE_TEST_MARKER();
;;;572    				}
;;;573    
;;;574    				/* Store the actual event flag value in the task's event list
;;;575    				item before removing the task from the event list.  The
;;;576    				eventUNBLOCKED_DUE_TO_BIT_SET bit is set so the task knows
;;;577    				that is was unblocked due to its required bits matching, rather
;;;578    				than because it timed out. */
;;;579    				vTaskRemoveFromUnorderedEventList( pxListItem, pxEventBits->uxEventBits | eventUNBLOCKED_DUE_TO_BIT_SET );
000050  2201              MOVS     r2,#1
000052  6821              LDR      r1,[r4,#0]
000054  0652              LSLS     r2,r2,#25
000056  4311              ORRS     r1,r1,r2
000058  f7fffffe          BL       vTaskRemoveFromUnorderedEventList
                  |L9.92|
;;;580    			}
;;;581    
;;;582    			/* Move onto the next list item.  Note pxListItem->pxNext is not
;;;583    			used here as the list item may have been removed from the event list
;;;584    			and inserted into the ready/pending reading list. */
;;;585    			pxListItem = pxNext;
00005c  9801              LDR      r0,[sp,#4]
                  |L9.94|
00005e  9900              LDR      r1,[sp,#0]            ;530
000060  4288              CMP      r0,r1                 ;530
000062  d1dc              BNE      |L9.30|
;;;586    		}
;;;587    
;;;588    		/* Clear any bits that matched when the eventCLEAR_EVENTS_ON_EXIT_BIT
;;;589    		bit was set in the control word. */
;;;590    		pxEventBits->uxEventBits &= ~uxBitsToClear;
000064  6820              LDR      r0,[r4,#0]
000066  43a8              BICS     r0,r0,r5
000068  6020              STR      r0,[r4,#0]
;;;591    	}
;;;592    	( void ) xTaskResumeAll();
00006a  f7fffffe          BL       xTaskResumeAll
;;;593    
;;;594    	return pxEventBits->uxEventBits;
00006e  6820              LDR      r0,[r4,#0]
;;;595    }
000070  bdfe              POP      {r1-r7,pc}
;;;596    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupSync||, CODE, READONLY, ALIGN=1

                  xEventGroupSync PROC
;;;175    
;;;176    EventBits_t xEventGroupSync( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToSet, const EventBits_t uxBitsToWaitFor, TickType_t xTicksToWait )
000000  b5ff              PUSH     {r0-r7,lr}
;;;177    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  4615              MOV      r5,r2
000008  461f              MOV      r7,r3
;;;178    EventBits_t uxOriginalBitValue, uxReturn;
;;;179    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;180    BaseType_t xAlreadyYielded;
;;;181    BaseType_t xTimeoutOccurred = pdFALSE;
;;;182    
;;;183    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
;;;184    	configASSERT( uxBitsToWaitFor != 0 );
;;;185    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;186    	{
;;;187    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;188    	}
;;;189    	#endif
;;;190    
;;;191    	vTaskSuspendAll();
00000a  f7fffffe          BL       vTaskSuspendAll
;;;192    	{
;;;193    		uxOriginalBitValue = pxEventBits->uxEventBits;
00000e  6826              LDR      r6,[r4,#0]
;;;194    
;;;195    		( void ) xEventGroupSetBits( xEventGroup, uxBitsToSet );
000010  4620              MOV      r0,r4
000012  9902              LDR      r1,[sp,#8]
000014  f7fffffe          BL       xEventGroupSetBits
;;;196    
;;;197    		if( ( ( uxOriginalBitValue | uxBitsToSet ) & uxBitsToWaitFor ) == uxBitsToWaitFor )
000018  9802              LDR      r0,[sp,#8]
00001a  4306              ORRS     r6,r6,r0
00001c  4628              MOV      r0,r5
00001e  43b0              BICS     r0,r0,r6
000020  d00b              BEQ      |L10.58|
;;;198    		{
;;;199    			/* All the rendezvous bits are now set - no need to block. */
;;;200    			uxReturn = ( uxOriginalBitValue | uxBitsToSet );
;;;201    
;;;202    			/* Rendezvous always clear the bits.  They will have been cleared
;;;203    			already unless this is the only task in the rendezvous. */
;;;204    			pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
;;;205    
;;;206    			xTicksToWait = 0;
;;;207    		}
;;;208    		else
;;;209    		{
;;;210    			if( xTicksToWait != ( TickType_t ) 0 )
000022  2f00              CMP      r7,#0
000024  d00e              BEQ      |L10.68|
;;;211    			{
;;;212    				traceEVENT_GROUP_SYNC_BLOCK( xEventGroup, uxBitsToSet, uxBitsToWaitFor );
;;;213    
;;;214    				/* Store the bits that the calling task is waiting for in the
;;;215    				task's event list item so the kernel knows when a match is
;;;216    				found.  Then enter the blocked state. */
;;;217    				vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | eventCLEAR_EVENTS_ON_EXIT_BIT | eventWAIT_FOR_ALL_BITS ), xTicksToWait );
000026  2005              MOVS     r0,#5
000028  4629              MOV      r1,r5
00002a  0600              LSLS     r0,r0,#24
00002c  4301              ORRS     r1,r1,r0
00002e  463a              MOV      r2,r7
000030  1d20              ADDS     r0,r4,#4
000032  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;218    
;;;219    				/* This assignment is obsolete as uxReturn will get set after
;;;220    				the task unblocks, but some compilers mistakenly generate a
;;;221    				warning about uxReturn being returned without being set if the
;;;222    				assignment is omitted. */
;;;223    				uxReturn = 0;
000036  2600              MOVS     r6,#0
000038  e005              B        |L10.70|
                  |L10.58|
00003a  6820              LDR      r0,[r4,#0]            ;204
00003c  43a8              BICS     r0,r0,r5              ;204
00003e  6020              STR      r0,[r4,#0]            ;204
000040  2700              MOVS     r7,#0                 ;206
000042  e000              B        |L10.70|
                  |L10.68|
;;;224    			}
;;;225    			else
;;;226    			{
;;;227    				/* The rendezvous bits were not set, but no block time was
;;;228    				specified - just return the current event bit value. */
;;;229    				uxReturn = pxEventBits->uxEventBits;
000044  6826              LDR      r6,[r4,#0]
                  |L10.70|
;;;230    				xTimeoutOccurred = pdTRUE;
;;;231    			}
;;;232    		}
;;;233    	}
;;;234    	xAlreadyYielded = xTaskResumeAll();
000046  f7fffffe          BL       xTaskResumeAll
;;;235    
;;;236    	if( xTicksToWait != ( TickType_t ) 0 )
00004a  2f00              CMP      r7,#0
00004c  d015              BEQ      |L10.122|
;;;237    	{
;;;238    		if( xAlreadyYielded == pdFALSE )
00004e  2800              CMP      r0,#0
000050  d101              BNE      |L10.86|
;;;239    		{
;;;240    			portYIELD_WITHIN_API();
000052  f7fffffe          BL       vPortYield
                  |L10.86|
;;;241    		}
;;;242    		else
;;;243    		{
;;;244    			mtCOVERAGE_TEST_MARKER();
;;;245    		}
;;;246    
;;;247    		/* The task blocked to wait for its required bits to be set - at this
;;;248    		point either the required bits were set or the block time expired.  If
;;;249    		the required bits were set they will have been stored in the task's
;;;250    		event list item, and they should now be retrieved then cleared. */
;;;251    		uxReturn = uxTaskResetEventItemValue();
000056  f7fffffe          BL       uxTaskResetEventItemValue
00005a  4606              MOV      r6,r0
;;;252    
;;;253    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
00005c  01b0              LSLS     r0,r6,#6
00005e  d40a              BMI      |L10.118|
;;;254    		{
;;;255    			/* The task timed out, just return the current event bit value. */
;;;256    			taskENTER_CRITICAL();
000060  f7fffffe          BL       vPortEnterCritical
;;;257    			{
;;;258    				uxReturn = pxEventBits->uxEventBits;
000064  6826              LDR      r6,[r4,#0]
;;;259    
;;;260    				/* Although the task got here because it timed out before the
;;;261    				bits it was waiting for were set, it is possible that since it
;;;262    				unblocked another task has set the bits.  If this is the case
;;;263    				then it needs to clear the bits before exiting. */
;;;264    				if( ( uxReturn & uxBitsToWaitFor ) == uxBitsToWaitFor )
000066  4628              MOV      r0,r5
000068  43b0              BICS     r0,r0,r6
00006a  d102              BNE      |L10.114|
;;;265    				{
;;;266    					pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00006c  4630              MOV      r0,r6
00006e  43a8              BICS     r0,r0,r5
000070  6020              STR      r0,[r4,#0]
                  |L10.114|
;;;267    				}
;;;268    				else
;;;269    				{
;;;270    					mtCOVERAGE_TEST_MARKER();
;;;271    				}
;;;272    			}
;;;273    			taskEXIT_CRITICAL();
000072  f7fffffe          BL       vPortExitCritical
                  |L10.118|
;;;274    
;;;275    			xTimeoutOccurred = pdTRUE;
;;;276    		}
;;;277    		else
;;;278    		{
;;;279    			/* The task unblocked because the bits were set. */
;;;280    		}
;;;281    
;;;282    		/* Control bits might be set as the task had blocked should not be
;;;283    		returned. */
;;;284    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
000076  0236              LSLS     r6,r6,#8
000078  0a36              LSRS     r6,r6,#8
                  |L10.122|
;;;285    	}
;;;286    
;;;287    	traceEVENT_GROUP_SYNC_END( xEventGroup, uxBitsToSet, uxBitsToWaitFor, xTimeoutOccurred );
;;;288    
;;;289    	/* Prevent compiler warnings when trace macros are not used. */
;;;290    	( void ) xTimeoutOccurred;
;;;291    
;;;292    	return uxReturn;
00007a  4630              MOV      r0,r6
;;;293    }
00007c  b005              ADD      sp,sp,#0x14
00007e  bdf0              POP      {r4-r7,pc}
;;;294    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.xEventGroupWaitBits||, CODE, READONLY, ALIGN=1

                  xEventGroupWaitBits PROC
;;;295    
;;;296    EventBits_t xEventGroupWaitBits( EventGroupHandle_t xEventGroup, const EventBits_t uxBitsToWaitFor, const BaseType_t xClearOnExit, const BaseType_t xWaitForAllBits, TickType_t xTicksToWait )
000000  b5ff              PUSH     {r0-r7,lr}
;;;297    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;298    EventGroup_t *pxEventBits = ( EventGroup_t * ) xEventGroup;
;;;299    EventBits_t uxReturn, uxControlBits = 0;
000008  2500              MOVS     r5,#0
;;;300    BaseType_t xWaitConditionMet, xAlreadyYielded;
;;;301    BaseType_t xTimeoutOccurred = pdFALSE;
;;;302    
;;;303    	/* Check the user is not attempting to wait on the bits used by the kernel
;;;304    	itself, and that at least one bit is being requested. */
;;;305    	configASSERT( xEventGroup );
;;;306    	configASSERT( ( uxBitsToWaitFor & eventEVENT_BITS_CONTROL_BYTES ) == 0 );
;;;307    	configASSERT( uxBitsToWaitFor != 0 );
;;;308    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;309    	{
;;;310    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
;;;311    	}
;;;312    	#endif
;;;313    
;;;314    	vTaskSuspendAll();
00000a  f7fffffe          BL       vTaskSuspendAll
;;;315    	{
;;;316    		const EventBits_t uxCurrentEventBits = pxEventBits->uxEventBits;
00000e  6827              LDR      r7,[r4,#0]
;;;317    
;;;318    		/* Check to see if the wait condition is already met or not. */
;;;319    		xWaitConditionMet = prvTestWaitCondition( uxCurrentEventBits, uxBitsToWaitFor, xWaitForAllBits );
000010  4631              MOV      r1,r6
000012  4638              MOV      r0,r7
000014  9a04              LDR      r2,[sp,#0x10]
000016  f7fffffe          BL       prvTestWaitCondition
;;;320    
;;;321    		if( xWaitConditionMet != pdFALSE )
00001a  2800              CMP      r0,#0
00001c  d009              BEQ      |L11.50|
;;;322    		{
;;;323    			/* The wait condition has already been met so there is no need to
;;;324    			block. */
;;;325    			uxReturn = uxCurrentEventBits;
00001e  463d              MOV      r5,r7
;;;326    			xTicksToWait = ( TickType_t ) 0;
000020  2000              MOVS     r0,#0
000022  900a              STR      r0,[sp,#0x28]
;;;327    
;;;328    			/* Clear the wait bits if requested to do so. */
;;;329    			if( xClearOnExit != pdFALSE )
000024  9803              LDR      r0,[sp,#0xc]
000026  2800              CMP      r0,#0
000028  d018              BEQ      |L11.92|
;;;330    			{
;;;331    				pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
00002a  6820              LDR      r0,[r4,#0]
00002c  43b0              BICS     r0,r0,r6
00002e  6020              STR      r0,[r4,#0]
000030  e014              B        |L11.92|
                  |L11.50|
;;;332    			}
;;;333    			else
;;;334    			{
;;;335    				mtCOVERAGE_TEST_MARKER();
;;;336    			}
;;;337    		}
;;;338    		else if( xTicksToWait == ( TickType_t ) 0 )
000032  980a              LDR      r0,[sp,#0x28]
000034  2800              CMP      r0,#0
000036  d019              BEQ      |L11.108|
;;;339    		{
;;;340    			/* The wait condition has not been met, but no block time was
;;;341    			specified, so just return the current value. */
;;;342    			uxReturn = uxCurrentEventBits;
;;;343    			xTimeoutOccurred = pdTRUE;
;;;344    		}
;;;345    		else
;;;346    		{
;;;347    			/* The task is going to block to wait for its required bits to be
;;;348    			set.  uxControlBits are used to remember the specified behaviour of
;;;349    			this call to xEventGroupWaitBits() - for use when the event bits
;;;350    			unblock the task. */
;;;351    			if( xClearOnExit != pdFALSE )
000038  9803              LDR      r0,[sp,#0xc]
00003a  2800              CMP      r0,#0
00003c  d001              BEQ      |L11.66|
;;;352    			{
;;;353    				uxControlBits |= eventCLEAR_EVENTS_ON_EXIT_BIT;
00003e  2501              MOVS     r5,#1
000040  062d              LSLS     r5,r5,#24
                  |L11.66|
;;;354    			}
;;;355    			else
;;;356    			{
;;;357    				mtCOVERAGE_TEST_MARKER();
;;;358    			}
;;;359    
;;;360    			if( xWaitForAllBits != pdFALSE )
000042  9804              LDR      r0,[sp,#0x10]
000044  2800              CMP      r0,#0
000046  d002              BEQ      |L11.78|
;;;361    			{
;;;362    				uxControlBits |= eventWAIT_FOR_ALL_BITS;
000048  2001              MOVS     r0,#1
00004a  0680              LSLS     r0,r0,#26
00004c  4305              ORRS     r5,r5,r0
                  |L11.78|
;;;363    			}
;;;364    			else
;;;365    			{
;;;366    				mtCOVERAGE_TEST_MARKER();
;;;367    			}
;;;368    
;;;369    			/* Store the bits that the calling task is waiting for in the
;;;370    			task's event list item so the kernel knows when a match is
;;;371    			found.  Then enter the blocked state. */
;;;372    			vTaskPlaceOnUnorderedEventList( &( pxEventBits->xTasksWaitingForBits ), ( uxBitsToWaitFor | uxControlBits ), xTicksToWait );
00004e  4631              MOV      r1,r6
000050  4329              ORRS     r1,r1,r5
000052  1d20              ADDS     r0,r4,#4
000054  9a0a              LDR      r2,[sp,#0x28]
000056  f7fffffe          BL       vTaskPlaceOnUnorderedEventList
;;;373    
;;;374    			/* This is obsolete as it will get set after the task unblocks, but
;;;375    			some compilers mistakenly generate a warning about the variable
;;;376    			being returned without being set if it is not done. */
;;;377    			uxReturn = 0;
00005a  2500              MOVS     r5,#0
                  |L11.92|
;;;378    
;;;379    			traceEVENT_GROUP_WAIT_BITS_BLOCK( xEventGroup, uxBitsToWaitFor );
;;;380    		}
;;;381    	}
;;;382    	xAlreadyYielded = xTaskResumeAll();
00005c  f7fffffe          BL       xTaskResumeAll
;;;383    
;;;384    	if( xTicksToWait != ( TickType_t ) 0 )
000060  990a              LDR      r1,[sp,#0x28]
000062  2900              CMP      r1,#0
000064  d01f              BEQ      |L11.166|
;;;385    	{
;;;386    		if( xAlreadyYielded == pdFALSE )
000066  2800              CMP      r0,#0
000068  d002              BEQ      |L11.112|
00006a  e003              B        |L11.116|
                  |L11.108|
00006c  463d              MOV      r5,r7                 ;342
00006e  e7f5              B        |L11.92|
                  |L11.112|
;;;387    		{
;;;388    			portYIELD_WITHIN_API();
000070  f7fffffe          BL       vPortYield
                  |L11.116|
;;;389    		}
;;;390    		else
;;;391    		{
;;;392    			mtCOVERAGE_TEST_MARKER();
;;;393    		}
;;;394    
;;;395    		/* The task blocked to wait for its required bits to be set - at this
;;;396    		point either the required bits were set or the block time expired.  If
;;;397    		the required bits were set they will have been stored in the task's
;;;398    		event list item, and they should now be retrieved then cleared. */
;;;399    		uxReturn = uxTaskResetEventItemValue();
000074  f7fffffe          BL       uxTaskResetEventItemValue
000078  4605              MOV      r5,r0
;;;400    
;;;401    		if( ( uxReturn & eventUNBLOCKED_DUE_TO_BIT_SET ) == ( EventBits_t ) 0 )
00007a  01a8              LSLS     r0,r5,#6
00007c  d411              BMI      |L11.162|
;;;402    		{
;;;403    			taskENTER_CRITICAL();
00007e  f7fffffe          BL       vPortEnterCritical
;;;404    			{
;;;405    				/* The task timed out, just return the current event bit value. */
;;;406    				uxReturn = pxEventBits->uxEventBits;
000082  6825              LDR      r5,[r4,#0]
;;;407    
;;;408    				/* It is possible that the event bits were updated between this
;;;409    				task leaving the Blocked state and running again. */
;;;410    				if( prvTestWaitCondition( uxReturn, uxBitsToWaitFor, xWaitForAllBits ) != pdFALSE )
000084  4631              MOV      r1,r6
000086  4628              MOV      r0,r5
000088  9a04              LDR      r2,[sp,#0x10]
00008a  f7fffffe          BL       prvTestWaitCondition
00008e  2800              CMP      r0,#0
000090  d005              BEQ      |L11.158|
;;;411    				{
;;;412    					if( xClearOnExit != pdFALSE )
000092  9803              LDR      r0,[sp,#0xc]
000094  2800              CMP      r0,#0
000096  d002              BEQ      |L11.158|
;;;413    					{
;;;414    						pxEventBits->uxEventBits &= ~uxBitsToWaitFor;
000098  6820              LDR      r0,[r4,#0]
00009a  43b0              BICS     r0,r0,r6
00009c  6020              STR      r0,[r4,#0]
                  |L11.158|
;;;415    					}
;;;416    					else
;;;417    					{
;;;418    						mtCOVERAGE_TEST_MARKER();
;;;419    					}
;;;420    				}
;;;421    				else
;;;422    				{
;;;423    					mtCOVERAGE_TEST_MARKER();
;;;424    				}
;;;425    				xTimeoutOccurred = pdTRUE;
;;;426    			}
;;;427    			taskEXIT_CRITICAL();
00009e  f7fffffe          BL       vPortExitCritical
                  |L11.162|
;;;428    		}
;;;429    		else
;;;430    		{
;;;431    			/* The task unblocked because the bits were set. */
;;;432    		}
;;;433    
;;;434    		/* The task blocked so control bits may have been set. */
;;;435    		uxReturn &= ~eventEVENT_BITS_CONTROL_BYTES;
0000a2  022d              LSLS     r5,r5,#8
0000a4  0a2d              LSRS     r5,r5,#8
                  |L11.166|
;;;436    	}
;;;437    	traceEVENT_GROUP_WAIT_BITS_END( xEventGroup, uxBitsToWaitFor, xTimeoutOccurred );
;;;438    
;;;439    	/* Prevent compiler warnings when trace macros are not used. */
;;;440    	( void ) xTimeoutOccurred;
;;;441    
;;;442    	return uxReturn;
0000a6  4628              MOV      r0,r5
;;;443    }
0000a8  b005              ADD      sp,sp,#0x14
0000aa  bdf0              POP      {r4-r7,pc}
;;;444    /*-----------------------------------------------------------*/
                          ENDP


;*** Start embedded assembler ***

#line 1 "Common\\CMSIS-FreeRTOS\\10.0.1\\Source\\event_groups.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_event_groups_c_af0fbc0a____REV16|
#line 492 "C:\\Users\\bbb\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___14_event_groups_c_af0fbc0a____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_event_groups_c_af0fbc0a____REVSH|
#line 507
|__asm___14_event_groups_c_af0fbc0a____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
