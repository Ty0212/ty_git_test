; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\port.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\port.d --cpu=Cortex-M0 --apcs=interwork -O1 --diag_suppress=9931 -I.\APP -I.\APP\TN2115s_libs -I.\Common\CMSIS-FreeRTOS\10.0.1\Source\include -I.\Common\RTE\RTOS -I.\Common\CMSIS-FreeRTOS\10.0.1\CMSIS\RTOS2\FreeRTOS\Include -I.\Common\CMSIS-FreeRTOS\10.0.1\Source\portable\RVDS\ARM_CM0 -I.\APP\EINK -I.\Device_desc -I.\Common\CMSIS-FreeRTOS\10.0.1\Source -I.\Common\RTE\Device\ARMCM0 -I.\RTE\_soc_m0 -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\Device\ARM\ARMCM0\Include -D__MICROLIB -D__UVISION_VERSION=529 -D_RTE_ -DARMCM0 --omf_browse=.\objects\port.crf Common\CMSIS-FreeRTOS\10.0.1\Source\portable\RVDS\ARM_CM0\port.c]
                          THUMB

                          AREA ||i.prvSetupTimerInterrupt||, CODE, READONLY, ALIGN=1

                  prvSetupTimerInterrupt PROC
;;;295     */
;;;296    __weak void prvSetupTimerInterrupt( void )
000000  b510              PUSH     {r4,lr}
;;;297    {
;;;298    	osTick_Setup (configTICK_RATE_HZ);
000002  207d              MOVS     r0,#0x7d
000004  00c0              LSLS     r0,r0,#3
000006  f7fffffe          BL       osTick_Setup
;;;299    }
00000a  bd10              POP      {r4,pc}
;;;300    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvTaskExitError||, CODE, READONLY, ALIGN=1

                  prvTaskExitError PROC
;;;104    
;;;105    static void prvTaskExitError( void )
000000  b672              CPSID    i
                  |L2.2|
;;;106    {
;;;107    	/* A function that implements a task must not exit or attempt to return to
;;;108    	its caller as there is nothing to return to.  If a task wants to exit it
;;;109    	should instead call vTaskDelete( NULL ).
;;;110    
;;;111    	Artificially force an assert() to be triggered if configASSERT() is
;;;112    	defined, then stop here so application writers can catch the error. */
;;;113    	configASSERT( uxCriticalNesting == ~0UL );
;;;114    	portDISABLE_INTERRUPTS();
;;;115    	for( ;; );
000002  e7fe              B        |L2.2|
;;;116    }
;;;117    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.pxPortInitialiseStack||, CODE, READONLY, ALIGN=2

                  pxPortInitialiseStack PROC
;;;86      */
;;;87     StackType_t *pxPortInitialiseStack( StackType_t *pxTopOfStack, TaskFunction_t pxCode, void *pvParameters )
000000  1f00              SUBS     r0,r0,#4
;;;88     {
;;;89     	/* Simulate the stack frame as it would be created by a context switch
;;;90     	interrupt. */
;;;91     	pxTopOfStack--; /* Offset added to account for the way the MCU uses the stack on entry/exit of interrupts. */
;;;92     	*pxTopOfStack = portINITIAL_XPSR;	/* xPSR */
000002  2301              MOVS     r3,#1
000004  061b              LSLS     r3,r3,#24
000006  6003              STR      r3,[r0,#0]
000008  1f00              SUBS     r0,r0,#4
;;;93     	pxTopOfStack--;
;;;94     	*pxTopOfStack = ( StackType_t ) pxCode;	/* PC */
00000a  6001              STR      r1,[r0,#0]
00000c  1f00              SUBS     r0,r0,#4
;;;95     	pxTopOfStack--;
;;;96     	*pxTopOfStack = ( StackType_t ) prvTaskExitError;	/* LR */
00000e  4903              LDR      r1,|L3.28|
000010  6001              STR      r1,[r0,#0]
000012  3814              SUBS     r0,r0,#0x14
;;;97     	pxTopOfStack -= 5;	/* R12, R3, R2 and R1. */
;;;98     	*pxTopOfStack = ( StackType_t ) pvParameters;	/* R0 */
000014  6002              STR      r2,[r0,#0]
000016  3820              SUBS     r0,r0,#0x20
;;;99     	pxTopOfStack -= 8; /* R11..R4. */
;;;100    
;;;101    	return pxTopOfStack;
;;;102    }
000018  4770              BX       lr
;;;103    /*-----------------------------------------------------------*/
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      prvTaskExitError

                          AREA ||i.vApplicationGetIdleTaskMemory||, CODE, READONLY, ALIGN=2

                  vApplicationGetIdleTaskMemory PROC
;;;313    */
;;;314    void vApplicationGetIdleTaskMemory (StaticTask_t **ppxIdleTaskTCBBuffer, StackType_t **ppxIdleTaskStackBuffer, uint32_t *pulIdleTaskStackSize) {
000000  4b03              LDR      r3,|L4.16|
;;;315      *ppxIdleTaskTCBBuffer   = &Idle_TCB;
000002  6003              STR      r3,[r0,#0]
;;;316      *ppxIdleTaskStackBuffer = &Idle_Stack[0];
000004  4618              MOV      r0,r3
000006  3054              ADDS     r0,r0,#0x54
000008  6008              STR      r0,[r1,#0]
;;;317      *pulIdleTaskStackSize   = (uint32_t)configMINIMAL_STACK_SIZE;
00000a  2080              MOVS     r0,#0x80
00000c  6010              STR      r0,[r2,#0]
;;;318    }
00000e  4770              BX       lr
;;;319    
                          ENDP

                  |L4.16|
                          DCD      NoInit

                          AREA ||i.vApplicationGetTimerTaskMemory||, CODE, READONLY, ALIGN=2

                  vApplicationGetTimerTaskMemory PROC
;;;323    */
;;;324    void vApplicationGetTimerTaskMemory (StaticTask_t **ppxTimerTaskTCBBuffer, StackType_t **ppxTimerTaskStackBuffer, uint32_t *pulTimerTaskStackSize) {
000000  4b03              LDR      r3,|L5.16|
;;;325      *ppxTimerTaskTCBBuffer   = &Timer_TCB;
000002  6003              STR      r3,[r0,#0]
;;;326      *ppxTimerTaskStackBuffer = &Timer_Stack[0];
000004  4618              MOV      r0,r3
000006  3054              ADDS     r0,r0,#0x54
000008  6008              STR      r0,[r1,#0]
;;;327      *pulTimerTaskStackSize   = (uint32_t)configTIMER_TASK_STACK_DEPTH;
00000a  2050              MOVS     r0,#0x50
00000c  6010              STR      r0,[r2,#0]
;;;328    }
00000e  4770              BX       lr
                          ENDP

                  |L5.16|
                          DCD      NoInit+0x254

                          AREA ||i.vPortEndScheduler||, CODE, READONLY, ALIGN=1

                  vPortEndScheduler PROC
;;;173    
;;;174    void vPortEndScheduler( void )
000000  4770              BX       lr
;;;175    {
;;;176    	/* Not implemented in ports where there is nothing to return to.
;;;177    	Artificially force an assert. */
;;;178    	configASSERT( uxCriticalNesting == 1000UL );
;;;179    }
;;;180    /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.vPortEnterCritical||, CODE, READONLY, ALIGN=2

                  vPortEnterCritical PROC
;;;193    
;;;194    void vPortEnterCritical( void )
000000  b672              CPSID    i
;;;195    {
;;;196        portDISABLE_INTERRUPTS();
;;;197        uxCriticalNesting++;
000002  4804              LDR      r0,|L7.20|
000004  6801              LDR      r1,[r0,#0]  ; uxCriticalNesting
000006  1c49              ADDS     r1,r1,#1
000008  6001              STR      r1,[r0,#0]  ; uxCriticalNesting
;;;198    	__dsb( portSY_FULL_READ_WRITE );
00000a  f3bf8f4f          DSB      
;;;199    	__isb( portSY_FULL_READ_WRITE );
00000e  f3bf8f6f          ISB      
;;;200    }
000012  4770              BX       lr
;;;201    /*-----------------------------------------------------------*/
                          ENDP

                  |L7.20|
                          DCD      ||.data||

                          AREA ||i.vPortExitCritical||, CODE, READONLY, ALIGN=2

                  vPortExitCritical PROC
;;;202    
;;;203    void vPortExitCritical( void )
000000  4903              LDR      r1,|L8.16|
;;;204    {
;;;205    	configASSERT( uxCriticalNesting );
;;;206        uxCriticalNesting--;
000002  6808              LDR      r0,[r1,#0]  ; uxCriticalNesting
000004  1e40              SUBS     r0,r0,#1
000006  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;207        if( uxCriticalNesting == 0 )
000008  2800              CMP      r0,#0
00000a  d100              BNE      |L8.14|
;;;208        {
;;;209            portENABLE_INTERRUPTS();
00000c  b662              CPSIE    i
                  |L8.14|
;;;210        }
;;;211    }
00000e  4770              BX       lr
;;;212    /*-----------------------------------------------------------*/
                          ENDP

                  |L8.16|
                          DCD      ||.data||

                          AREA ||i.vPortYield||, CODE, READONLY, ALIGN=2

                  vPortYield PROC
;;;181    
;;;182    void vPortYield( void )
000000  2001              MOVS     r0,#1
;;;183    {
;;;184    	/* Set a PendSV to request a context switch. */
;;;185    	*( portNVIC_INT_CTRL ) = portNVIC_PENDSVSET;
000002  4904              LDR      r1,|L9.20|
000004  0700              LSLS     r0,r0,#28
000006  6048              STR      r0,[r1,#4]
;;;186    
;;;187    	/* Barriers are normally not required but do ensure the code is completely
;;;188    	within the specified behaviour for the architecture. */
;;;189    	__dsb( portSY_FULL_READ_WRITE );
000008  f3bf8f4f          DSB      
;;;190    	__isb( portSY_FULL_READ_WRITE );
00000c  f3bf8f6f          ISB      
;;;191    }
000010  4770              BX       lr
;;;192    /*-----------------------------------------------------------*/
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0xe000ed00

                          AREA ||i.xPortStartScheduler||, CODE, READONLY, ALIGN=2

                  xPortStartScheduler PROC
;;;152     */
;;;153    BaseType_t xPortStartScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;154    {
;;;155    	/* Make PendSV, CallSV and SysTick the same priroity as the kernel. */
;;;156    	*(portNVIC_SYSPRI2) |= portNVIC_PENDSV_PRI;
000002  4809              LDR      r0,|L10.40|
000004  6a01              LDR      r1,[r0,#0x20]
000006  22ff              MOVS     r2,#0xff
000008  0412              LSLS     r2,r2,#16
00000a  4311              ORRS     r1,r1,r2
00000c  6201              STR      r1,[r0,#0x20]
;;;157    	*(portNVIC_SYSPRI2) |= portNVIC_SYSTICK_PRI;
00000e  6a01              LDR      r1,[r0,#0x20]
000010  0212              LSLS     r2,r2,#8
000012  4311              ORRS     r1,r1,r2
000014  6201              STR      r1,[r0,#0x20]
;;;158    
;;;159    	/* Start the timer that generates the tick ISR.  Interrupts are disabled
;;;160    	here already. */
;;;161    	prvSetupTimerInterrupt();
000016  f7fffffe          BL       prvSetupTimerInterrupt
;;;162    
;;;163    	/* Initialise the critical nesting count ready for the first task. */
;;;164    	uxCriticalNesting = 0;
00001a  4904              LDR      r1,|L10.44|
00001c  2000              MOVS     r0,#0
00001e  6008              STR      r0,[r1,#0]  ; uxCriticalNesting
;;;165    
;;;166    	/* Start the first task. */
;;;167    	prvPortStartFirstTask();
000020  f7fffffe          BL       __asm___6_port_c_39a90d8d__prvPortStartFirstTask
;;;168    
;;;169    	/* Should not get here! */
;;;170    	return 0;
000024  2000              MOVS     r0,#0
;;;171    }
000026  bd10              POP      {r4,pc}
;;;172    /*-----------------------------------------------------------*/
                          ENDP

                  |L10.40|
                          DCD      0xe000ed00
                  |L10.44|
                          DCD      ||.data||

                          AREA ||i.xPortSysTickHandler||, CODE, READONLY, ALIGN=2

                  xPortSysTickHandler PROC
;;;274    
;;;275    void xPortSysTickHandler( void )
000000  b510              PUSH     {r4,lr}
;;;276    {
;;;277    uint32_t ulPreviousMask;
;;;278    
;;;279    	ulPreviousMask = portSET_INTERRUPT_MASK_FROM_ISR();
000002  f7fffffe          BL       ulSetInterruptMaskFromISR
000006  4604              MOV      r4,r0
;;;280    	{
;;;281    		/* Increment the RTOS tick. */
;;;282    		if( xTaskIncrementTick() != pdFALSE )
000008  f7fffffe          BL       xTaskIncrementTick
00000c  2800              CMP      r0,#0
00000e  d003              BEQ      |L11.24|
;;;283    		{
;;;284    			/* Pend a context switch. */
;;;285    			*(portNVIC_INT_CTRL) = portNVIC_PENDSVSET;
000010  2001              MOVS     r0,#1
000012  4903              LDR      r1,|L11.32|
000014  0700              LSLS     r0,r0,#28
000016  6048              STR      r0,[r1,#4]
                  |L11.24|
;;;286    		}
;;;287    	}
;;;288    	portCLEAR_INTERRUPT_MASK_FROM_ISR( ulPreviousMask );
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       vClearInterruptMaskFromISR
;;;289    }
00001e  bd10              POP      {r4,pc}
;;;290    /*-----------------------------------------------------------*/
                          ENDP

                  |L11.32|
                          DCD      0xe000ed00

                          AREA ||.data||, DATA, ALIGN=2

                  uxCriticalNesting
                          DCD      0xaaaaaaaa

                          AREA NoInit, DATA, NOINIT, ALIGN=2

                  Idle_TCB
                          %        84
                  Idle_Stack
                          %        512
                  Timer_TCB
                          %        84
                  Timer_Stack
                          %        320

;*** Start embedded assembler ***

#line 1 "Common\\CMSIS-FreeRTOS\\10.0.1\\Source\\portable\\RVDS\\ARM_CM0\\port.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d____REV16|
#line 492 "C:\\Users\\bbb\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___6_port_c_39a90d8d____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d____REVSH|
#line 507
|__asm___6_port_c_39a90d8d____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |__asm___6_port_c_39a90d8d__prvPortStartFirstTask|
#line 121 "Common\\CMSIS-FreeRTOS\\10.0.1\\Source\\portable\\RVDS\\ARM_CM0\\port.c"
|__asm___6_port_c_39a90d8d__prvPortStartFirstTask| PROC
#line 122

 extern pxCurrentTCB

 PRESERVE8

#line 129
 

 ldr r3, =pxCurrentTCB  
 ldr r1, [r3]
 ldr r0, [r1]  
 adds r0, #32  
 msr psp, r0  
 movs r0, #2  
 msr CONTROL, r0
 isb
 pop {r0-r5}  
 mov lr, r5  
 pop {r3}  
 pop {r2}  
 cpsie i  
 bx r3  

 ALIGN
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |ulSetInterruptMaskFromISR|
#line 214
|ulSetInterruptMaskFromISR| PROC
#line 215

 mrs r0, PRIMASK
 cpsid i
 bx lr
	ENDP
	AREA ||.emb_text||, CODE
	THUMB
	EXPORT |vClearInterruptMaskFromISR|
#line 222
|vClearInterruptMaskFromISR| PROC
#line 223

 msr PRIMASK, r0
 bx lr
	ENDP
	AREA ||.ARM.__at_0x2400||, CODE
	THUMB
	EXPORT |PendSV_Handler|
#line 229
|PendSV_Handler| PROC
#line 230

 extern vTaskSwitchContext
 extern pxCurrentTCB

 PRESERVE8

 mrs r0, psp

 ldr r3, =pxCurrentTCB  
 ldr r2, [r3]

 subs r0, #32  
 str r0, [r2]  
 stmia r0!, {r4-r7}  
 mov r4, r8  
 mov r5, r9
 mov r6, r10
 mov r7, r11
 stmia r0!, {r4-r7}

 push {r3, r14}
 cpsid i
 bl vTaskSwitchContext
 cpsie i
 pop {r2, r3}  

 ldr r1, [r2]
 ldr r0, [r1]  
 adds r0, #16  
 ldmia r0!, {r4-r7}  
 mov r8, r4
 mov r9, r5
 mov r10, r6
 mov r11, r7

 msr psp, r0  

 subs r0, #32  
 ldmia r0!, {r4-r7}  

 bx r3
 ALIGN
	ENDP

;*** End   embedded assembler ***
