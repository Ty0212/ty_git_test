; generated by Component: ARM Compiler 5.06 update 6 (build 750) Tool: ArmCC [4d3637]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\objects\tasks.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\tasks.d --cpu=Cortex-M0 --apcs=interwork -O1 --diag_suppress=9931 -I.\APP -I.\APP\TN2115s_libs -I.\Common\CMSIS-FreeRTOS\10.0.1\Source\include -I.\Common\RTE\RTOS -I.\Common\CMSIS-FreeRTOS\10.0.1\CMSIS\RTOS2\FreeRTOS\Include -I.\Common\CMSIS-FreeRTOS\10.0.1\Source\portable\RVDS\ARM_CM0 -I.\APP\EINK -I.\Device_desc -I.\Common\CMSIS-FreeRTOS\10.0.1\Source -I.\Common\RTE\Device\ARMCM0 -I.\RTE\_soc_m0 -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\CMSIS\Core\Include -IC:\Users\bbb\AppData\Local\Arm\Packs\ARM\CMSIS\5.6.0\Device\ARM\ARMCM0\Include -D__MICROLIB -D__UVISION_VERSION=529 -D_RTE_ -DARMCM0 --omf_browse=.\objects\tasks.crf Common\CMSIS-FreeRTOS\10.0.1\Source\tasks.c]
                          THUMB

                          AREA ||i.eTaskGetState||, CODE, READONLY, ALIGN=2

                  eTaskGetState PROC
;;;1332   
;;;1333   	eTaskState eTaskGetState( TaskHandle_t xTask )
000000  b570              PUSH     {r4-r6,lr}
;;;1334   	{
000002  4605              MOV      r5,r0
;;;1335   	eTaskState eReturn;
;;;1336   	List_t *pxStateList;
;;;1337   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
;;;1338   
;;;1339   		configASSERT( pxTCB );
;;;1340   
;;;1341   		if( pxTCB == pxCurrentTCB )
000004  4e13              LDR      r6,|L1.84|
000006  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
000008  4285              CMP      r5,r0
00000a  d101              BNE      |L1.16|
;;;1342   		{
;;;1343   			/* The task calling this function is querying its own state. */
;;;1344   			eReturn = eRunning;
00000c  2000              MOVS     r0,#0
;;;1345   		}
;;;1346   		else
;;;1347   		{
;;;1348   			taskENTER_CRITICAL();
;;;1349   			{
;;;1350   				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
;;;1351   			}
;;;1352   			taskEXIT_CRITICAL();
;;;1353   
;;;1354   			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
;;;1355   			{
;;;1356   				/* The task being queried is referenced from one of the Blocked
;;;1357   				lists. */
;;;1358   				eReturn = eBlocked;
;;;1359   			}
;;;1360   
;;;1361   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1362   				else if( pxStateList == &xSuspendedTaskList )
;;;1363   				{
;;;1364   					/* The task being queried is referenced from the suspended
;;;1365   					list.  Is it genuinely suspended or is it block
;;;1366   					indefinitely? */
;;;1367   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
;;;1368   					{
;;;1369   						eReturn = eSuspended;
;;;1370   					}
;;;1371   					else
;;;1372   					{
;;;1373   						eReturn = eBlocked;
;;;1374   					}
;;;1375   				}
;;;1376   			#endif
;;;1377   
;;;1378   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1379   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
;;;1380   				{
;;;1381   					/* The task being queried is referenced from the deleted
;;;1382   					tasks list, or it is not referenced from any lists at
;;;1383   					all. */
;;;1384   					eReturn = eDeleted;
;;;1385   				}
;;;1386   			#endif
;;;1387   
;;;1388   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1389   			{
;;;1390   				/* If the task is not in any other state, it must be in the
;;;1391   				Ready (including pending ready) state. */
;;;1392   				eReturn = eReady;
;;;1393   			}
;;;1394   		}
;;;1395   
;;;1396   		return eReturn;
;;;1397   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00000e  bd70              POP      {r4-r6,pc}
                  |L1.16|
000010  f7fffffe          BL       vPortEnterCritical
000014  696c              LDR      r4,[r5,#0x14]         ;1350
000016  f7fffffe          BL       vPortExitCritical
00001a  6b70              LDR      r0,[r6,#0x34]         ;1354  ; pxDelayedTaskList
00001c  4284              CMP      r4,r0                 ;1354
00001e  d002              BEQ      |L1.38|
000020  6bb0              LDR      r0,[r6,#0x38]         ;1354  ; pxOverflowDelayedTaskList
000022  4284              CMP      r4,r0                 ;1354
000024  d101              BNE      |L1.42|
                  |L1.38|
000026  2002              MOVS     r0,#2                 ;1358
000028  bd70              POP      {r4-r6,pc}
                  |L1.42|
00002a  480b              LDR      r0,|L1.88|
00002c  4284              CMP      r4,r0                 ;1362
00002e  d106              BNE      |L1.62|
000030  6aa8              LDR      r0,[r5,#0x28]         ;1367
000032  2800              CMP      r0,#0                 ;1367
000034  d001              BEQ      |L1.58|
000036  2002              MOVS     r0,#2                 ;1373
000038  bd70              POP      {r4-r6,pc}
                  |L1.58|
00003a  2003              MOVS     r0,#3                 ;1369
00003c  bd70              POP      {r4-r6,pc}
                  |L1.62|
00003e  4806              LDR      r0,|L1.88|
000040  3814              SUBS     r0,r0,#0x14           ;1379
000042  4284              CMP      r4,r0                 ;1379
000044  d003              BEQ      |L1.78|
000046  2c00              CMP      r4,#0                 ;1379
000048  d001              BEQ      |L1.78|
00004a  2001              MOVS     r0,#1                 ;1392
00004c  bd70              POP      {r4-r6,pc}
                  |L1.78|
00004e  2004              MOVS     r0,#4                 ;1384
000050  bd70              POP      {r4-r6,pc}
;;;1398   
                          ENDP

000052  0000              DCW      0x0000
                  |L1.84|
                          DCD      ||.data||
                  |L1.88|
                          DCD      NoInit+0x140

                          AREA ||i.pcTaskGetName||, CODE, READONLY, ALIGN=2

                  pcTaskGetName PROC
;;;2268   
;;;2269   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000000  2800              CMP      r0,#0
;;;2270   {
000002  d101              BNE      |L2.8|
;;;2271   TCB_t *pxTCB;
;;;2272   
;;;2273   	/* If null is passed in here then the name of the calling task is being
;;;2274   	queried. */
;;;2275   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
000004  4801              LDR      r0,|L2.12|
000006  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
                  |L2.8|
;;;2276   	configASSERT( pxTCB );
;;;2277   	return &( pxTCB->pcTaskName[ 0 ] );
000008  3034              ADDS     r0,r0,#0x34
;;;2278   }
00000a  4770              BX       lr
;;;2279   /*-----------------------------------------------------------*/
                          ENDP

                  |L2.12|
                          DCD      ||.data||

                          AREA ||i.prvAddCurrentTaskToDelayedList||, CODE, READONLY, ALIGN=2

                  prvAddCurrentTaskToDelayedList PROC
;;;4911   
;;;4912   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
000000  b5f8              PUSH     {r3-r7,lr}
;;;4913   {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
;;;4914   TickType_t xTimeToWake;
;;;4915   const TickType_t xConstTickCount = xTickCount;
000006  4e12              LDR      r6,|L3.80|
000008  68f5              LDR      r5,[r6,#0xc]  ; xTickCount
;;;4916   
;;;4917   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;4918   	{
;;;4919   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;4920   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;4921   		when the task leaves the Blocked state. */
;;;4922   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;4923   	}
;;;4924   	#endif
;;;4925   
;;;4926   	/* Remove the task from the ready list before adding it to the blocked list
;;;4927   	as the same list item is used for both lists. */
;;;4928   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00000a  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00000c  1d00              ADDS     r0,r0,#4
00000e  f7fffffe          BL       uxListRemove
;;;4929   	{
;;;4930   		/* The current task must be in a ready list, so there is no need to
;;;4931   		check, and the port reset macro can be called directly. */
;;;4932   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
;;;4933   	}
;;;4934   	else
;;;4935   	{
;;;4936   		mtCOVERAGE_TEST_MARKER();
;;;4937   	}
;;;4938   
;;;4939   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;4940   	{
;;;4941   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
000012  1c60              ADDS     r0,r4,#1
000014  d107              BNE      |L3.38|
000016  2f00              CMP      r7,#0
000018  d005              BEQ      |L3.38|
;;;4942   		{
;;;4943   			/* Add the task to the suspended task list instead of a delayed task
;;;4944   			list to ensure it is not woken by a timing event.  It will block
;;;4945   			indefinitely. */
;;;4946   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
00001a  6831              LDR      r1,[r6,#0]  ; pxCurrentTCB
00001c  480d              LDR      r0,|L3.84|
00001e  1d09              ADDS     r1,r1,#4
000020  f7fffffe          BL       vListInsertEnd
;;;4947   		}
;;;4948   		else
;;;4949   		{
;;;4950   			/* Calculate the time at which the task should be woken if the event
;;;4951   			does not occur.  This may overflow but this doesn't matter, the
;;;4952   			kernel will manage it correctly. */
;;;4953   			xTimeToWake = xConstTickCount + xTicksToWait;
;;;4954   
;;;4955   			/* The list item will be inserted in wake time order. */
;;;4956   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;4957   
;;;4958   			if( xTimeToWake < xConstTickCount )
;;;4959   			{
;;;4960   				/* Wake time has overflowed.  Place this item in the overflow
;;;4961   				list. */
;;;4962   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4963   			}
;;;4964   			else
;;;4965   			{
;;;4966   				/* The wake time has not overflowed, so the current block list
;;;4967   				is used. */
;;;4968   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4969   
;;;4970   				/* If the task entering the blocked state was placed at the
;;;4971   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;4972   				needs to be updated too. */
;;;4973   				if( xTimeToWake < xNextTaskUnblockTime )
;;;4974   				{
;;;4975   					xNextTaskUnblockTime = xTimeToWake;
;;;4976   				}
;;;4977   				else
;;;4978   				{
;;;4979   					mtCOVERAGE_TEST_MARKER();
;;;4980   				}
;;;4981   			}
;;;4982   		}
;;;4983   	}
;;;4984   	#else /* INCLUDE_vTaskSuspend */
;;;4985   	{
;;;4986   		/* Calculate the time at which the task should be woken if the event
;;;4987   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;4988   		will manage it correctly. */
;;;4989   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;4990   
;;;4991   		/* The list item will be inserted in wake time order. */
;;;4992   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;4993   
;;;4994   		if( xTimeToWake < xConstTickCount )
;;;4995   		{
;;;4996   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;4997   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4998   		}
;;;4999   		else
;;;5000   		{
;;;5001   			/* The wake time has not overflowed, so the current block list is used. */
;;;5002   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;5003   
;;;5004   			/* If the task entering the blocked state was placed at the head of the
;;;5005   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;5006   			too. */
;;;5007   			if( xTimeToWake < xNextTaskUnblockTime )
;;;5008   			{
;;;5009   				xNextTaskUnblockTime = xTimeToWake;
;;;5010   			}
;;;5011   			else
;;;5012   			{
;;;5013   				mtCOVERAGE_TEST_MARKER();
;;;5014   			}
;;;5015   		}
;;;5016   
;;;5017   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;5018   		( void ) xCanBlockIndefinitely;
;;;5019   	}
;;;5020   	#endif /* INCLUDE_vTaskSuspend */
;;;5021   }
000024  bdf8              POP      {r3-r7,pc}
                  |L3.38|
000026  192c              ADDS     r4,r5,r4              ;4953
000028  6830              LDR      r0,[r6,#0]            ;4956  ; pxCurrentTCB
00002a  6044              STR      r4,[r0,#4]            ;4956
00002c  42ac              CMP      r4,r5                 ;4958
00002e  d205              BCS      |L3.60|
000030  6831              LDR      r1,[r6,#0]            ;4962  ; pxCurrentTCB
000032  6bb0              LDR      r0,[r6,#0x38]         ;4962  ; pxOverflowDelayedTaskList
000034  1d09              ADDS     r1,r1,#4              ;4962
000036  f7fffffe          BL       vListInsert
                  |L3.58|
00003a  bdf8              POP      {r3-r7,pc}
                  |L3.60|
00003c  6831              LDR      r1,[r6,#0]            ;4968  ; pxCurrentTCB
00003e  6b70              LDR      r0,[r6,#0x34]         ;4968  ; pxDelayedTaskList
000040  1d09              ADDS     r1,r1,#4              ;4968
000042  f7fffffe          BL       vListInsert
000046  6ab0              LDR      r0,[r6,#0x28]         ;4973  ; xNextTaskUnblockTime
000048  4284              CMP      r4,r0                 ;4973
00004a  d2f6              BCS      |L3.58|
00004c  62b4              STR      r4,[r6,#0x28]         ;4975  ; xNextTaskUnblockTime
00004e  bdf8              POP      {r3-r7,pc}
;;;5022   
                          ENDP

                  |L3.80|
                          DCD      ||.data||
                  |L3.84|
                          DCD      NoInit+0x140

                          AREA ||i.prvAddNewTaskToReadyList||, CODE, READONLY, ALIGN=2

                  prvAddNewTaskToReadyList PROC
;;;1026   
;;;1027   static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  b570              PUSH     {r4-r6,lr}
;;;1028   {
000002  4604              MOV      r4,r0
;;;1029   	/* Ensure interrupts don't access the task lists while the lists are being
;;;1030   	updated. */
;;;1031   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1032   	{
;;;1033   		uxCurrentNumberOfTasks++;
000008  4d19              LDR      r5,|L4.112|
00000a  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
00000c  1c40              ADDS     r0,r0,#1
00000e  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;1034   		if( pxCurrentTCB == NULL )
000010  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000012  2800              CMP      r0,#0
000014  d003              BEQ      |L4.30|
;;;1035   		{
;;;1036   			/* There are no other tasks, or all the other tasks are in
;;;1037   			the suspended state - make this the current task. */
;;;1038   			pxCurrentTCB = pxNewTCB;
;;;1039   
;;;1040   			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
;;;1041   			{
;;;1042   				/* This is the first task to be created so do the preliminary
;;;1043   				initialisation required.  We will not recover if this call
;;;1044   				fails, but we will report the failure. */
;;;1045   				prvInitialiseTaskLists();
;;;1046   			}
;;;1047   			else
;;;1048   			{
;;;1049   				mtCOVERAGE_TEST_MARKER();
;;;1050   			}
;;;1051   		}
;;;1052   		else
;;;1053   		{
;;;1054   			/* If the scheduler is not already running, make this task the
;;;1055   			current task if it is the highest priority task to be created
;;;1056   			so far. */
;;;1057   			if( xSchedulerRunning == pdFALSE )
000016  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000018  2800              CMP      r0,#0
00001a  d007              BEQ      |L4.44|
00001c  e00c              B        |L4.56|
                  |L4.30|
00001e  602c              STR      r4,[r5,#0]            ;1038  ; pxCurrentTCB
000020  68a8              LDR      r0,[r5,#8]            ;1040  ; uxCurrentNumberOfTasks
000022  2801              CMP      r0,#1                 ;1040
000024  d108              BNE      |L4.56|
000026  f7fffffe          BL       prvInitialiseTaskLists
00002a  e005              B        |L4.56|
                  |L4.44|
;;;1058   			{
;;;1059   				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
00002c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00002e  6ae1              LDR      r1,[r4,#0x2c]
000030  6ac0              LDR      r0,[r0,#0x2c]
000032  4288              CMP      r0,r1
000034  d800              BHI      |L4.56|
;;;1060   				{
;;;1061   					pxCurrentTCB = pxNewTCB;
000036  602c              STR      r4,[r5,#0]  ; pxCurrentTCB
                  |L4.56|
;;;1062   				}
;;;1063   				else
;;;1064   				{
;;;1065   					mtCOVERAGE_TEST_MARKER();
;;;1066   				}
;;;1067   			}
;;;1068   			else
;;;1069   			{
;;;1070   				mtCOVERAGE_TEST_MARKER();
;;;1071   			}
;;;1072   		}
;;;1073   
;;;1074   		uxTaskNumber++;
000038  6a68              LDR      r0,[r5,#0x24]  ; uxTaskNumber
00003a  1c40              ADDS     r0,r0,#1
00003c  6268              STR      r0,[r5,#0x24]  ; uxTaskNumber
;;;1075   
;;;1076   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1077   		{
;;;1078   			/* Add a counter into the TCB for tracing only. */
;;;1079   			pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;1080   		}
;;;1081   		#endif /* configUSE_TRACE_FACILITY */
;;;1082   		traceTASK_CREATE( pxNewTCB );
;;;1083   
;;;1084   		prvAddTaskToReadyList( pxNewTCB );
00003e  6ae0              LDR      r0,[r4,#0x2c]
000040  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000042  4288              CMP      r0,r1
000044  d900              BLS      |L4.72|
000046  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L4.72|
000048  2114              MOVS     r1,#0x14
00004a  4348              MULS     r0,r1,r0
00004c  4909              LDR      r1,|L4.116|
00004e  1840              ADDS     r0,r0,r1
000050  1d21              ADDS     r1,r4,#4
000052  f7fffffe          BL       vListInsertEnd
;;;1085   
;;;1086   		portSETUP_TCB( pxNewTCB );
;;;1087   	}
;;;1088   	taskEXIT_CRITICAL();
000056  f7fffffe          BL       vPortExitCritical
;;;1089   
;;;1090   	if( xSchedulerRunning != pdFALSE )
00005a  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
00005c  2800              CMP      r0,#0
00005e  d006              BEQ      |L4.110|
;;;1091   	{
;;;1092   		/* If the created task is of a higher priority than the current task
;;;1093   		then it should run now. */
;;;1094   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
000060  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000062  6ae1              LDR      r1,[r4,#0x2c]
000064  6ac0              LDR      r0,[r0,#0x2c]
000066  4288              CMP      r0,r1
000068  d201              BCS      |L4.110|
;;;1095   		{
;;;1096   			taskYIELD_IF_USING_PREEMPTION();
00006a  f7fffffe          BL       vPortYield
                  |L4.110|
;;;1097   		}
;;;1098   		else
;;;1099   		{
;;;1100   			mtCOVERAGE_TEST_MARKER();
;;;1101   		}
;;;1102   	}
;;;1103   	else
;;;1104   	{
;;;1105   		mtCOVERAGE_TEST_MARKER();
;;;1106   	}
;;;1107   }
00006e  bd70              POP      {r4-r6,pc}
;;;1108   /*-----------------------------------------------------------*/
                          ENDP

                  |L4.112|
                          DCD      ||.data||
                  |L4.116|
                          DCD      NoInit

                          AREA ||i.prvCheckTasksWaitingTermination||, CODE, READONLY, ALIGN=2

                  prvCheckTasksWaitingTermination PROC
;;;3467   
;;;3468   static void prvCheckTasksWaitingTermination( void )
000000  b570              PUSH     {r4-r6,lr}
;;;3469   {
;;;3470   
;;;3471   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3472   
;;;3473   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3474   	{
;;;3475   		TCB_t *pxTCB;
;;;3476   
;;;3477   		/* uxDeletedTasksWaitingCleanUp is used to prevent taskENTER_CRITICAL()
;;;3478   		being called too often in the idle task. */
;;;3479   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
;;;3480   		{
;;;3481   			taskENTER_CRITICAL();
;;;3482   			{
;;;3483   				pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
;;;3484   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;3485   				--uxCurrentNumberOfTasks;
000002  4d0c              LDR      r5,|L5.52|
000004  4e0c              LDR      r6,|L5.56|
000006  e011              B        |L5.44|
                  |L5.8|
000008  f7fffffe          BL       vPortEnterCritical
00000c  68f0              LDR      r0,[r6,#0xc]          ;3483  ; xTasksWaitingTermination
00000e  68c4              LDR      r4,[r0,#0xc]          ;3483
000010  1d20              ADDS     r0,r4,#4              ;3484
000012  f7fffffe          BL       uxListRemove
000016  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
000018  1e40              SUBS     r0,r0,#1
00001a  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;3486   				--uxDeletedTasksWaitingCleanUp;
00001c  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
00001e  1e40              SUBS     r0,r0,#1
000020  6068              STR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
;;;3487   			}
;;;3488   			taskEXIT_CRITICAL();
000022  f7fffffe          BL       vPortExitCritical
;;;3489   
;;;3490   			prvDeleteTCB( pxTCB );
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       prvDeleteTCB
                  |L5.44|
00002c  6868              LDR      r0,[r5,#4]            ;3479  ; uxDeletedTasksWaitingCleanUp
00002e  2800              CMP      r0,#0                 ;3479
000030  d1ea              BNE      |L5.8|
;;;3491   		}
;;;3492   	}
;;;3493   	#endif /* INCLUDE_vTaskDelete */
;;;3494   }
000032  bd70              POP      {r4-r6,pc}
;;;3495   /*-----------------------------------------------------------*/
                          ENDP

                  |L5.52|
                          DCD      ||.data||
                  |L5.56|
                          DCD      NoInit+0x12c

                          AREA ||i.prvDeleteTCB||, CODE, READONLY, ALIGN=1

                  prvDeleteTCB PROC
;;;3675   
;;;3676   	static void prvDeleteTCB( TCB_t *pxTCB )
000000  b510              PUSH     {r4,lr}
;;;3677   	{
000002  4604              MOV      r4,r0
;;;3678   		/* This call is required specifically for the TriCore port.  It must be
;;;3679   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3680   		want to allocate and clean RAM statically. */
;;;3681   		portCLEAN_UP_TCB( pxTCB );
;;;3682   
;;;3683   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3684   		to the task to free any memory allocated at the application level. */
;;;3685   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3686   		{
;;;3687   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3688   		}
;;;3689   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3690   
;;;3691   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3692   		{
;;;3693   			/* The task can only have been allocated dynamically - free both
;;;3694   			the stack and TCB. */
;;;3695   			vPortFree( pxTCB->pxStack );
;;;3696   			vPortFree( pxTCB );
;;;3697   		}
;;;3698   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
;;;3699   		{
;;;3700   			/* The task could have been allocated statically or dynamically, so
;;;3701   			check what was statically allocated before trying to free the
;;;3702   			memory. */
;;;3703   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
000004  2051              MOVS     r0,#0x51
000006  5d00              LDRB     r0,[r0,r4]
000008  2800              CMP      r0,#0
00000a  d005              BEQ      |L6.24|
;;;3704   			{
;;;3705   				/* Both the stack and TCB were allocated dynamically, so both
;;;3706   				must be freed. */
;;;3707   				vPortFree( pxTCB->pxStack );
;;;3708   				vPortFree( pxTCB );
;;;3709   			}
;;;3710   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
00000c  2801              CMP      r0,#1
00000e  d102              BNE      |L6.22|
;;;3711   			{
;;;3712   				/* Only the stack was statically allocated, so the TCB is the
;;;3713   				only memory that must be freed. */
;;;3714   				vPortFree( pxTCB );
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       vPortFree
                  |L6.22|
;;;3715   			}
;;;3716   			else
;;;3717   			{
;;;3718   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3719   				nothing needs to be freed. */
;;;3720   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	);
;;;3721   				mtCOVERAGE_TEST_MARKER();
;;;3722   			}
;;;3723   		}
;;;3724   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3725   	}
000016  bd10              POP      {r4,pc}
                  |L6.24|
000018  6b20              LDR      r0,[r4,#0x30]         ;3707
00001a  f7fffffe          BL       vPortFree
00001e  4620              MOV      r0,r4                 ;3708
000020  f7fffffe          BL       vPortFree
000024  bd10              POP      {r4,pc}
;;;3726   
                          ENDP


                          AREA ||i.prvIdleTask||, CODE, READONLY, ALIGN=2

                  prvIdleTask PROC
;;;3223    */
;;;3224   static portTASK_FUNCTION( prvIdleTask, pvParameters )
000000  4c05              LDR      r4,|L7.24|
                  |L7.2|
;;;3225   {
;;;3226   	/* Stop warnings. */
;;;3227   	( void ) pvParameters;
;;;3228   
;;;3229   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3230   	SCHEDULER IS STARTED. **/
;;;3231   
;;;3232   	/* In case a task that has a secure context deletes itself, in which case
;;;3233   	the idle task is responsible for deleting the task's secure context, if
;;;3234   	any. */
;;;3235   	portTASK_CALLS_SECURE_FUNCTIONS();
;;;3236   
;;;3237   	for( ;; )
;;;3238   	{
;;;3239   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3240   		is responsible for freeing the deleted task's TCB and stack. */
;;;3241   		prvCheckTasksWaitingTermination();
000002  f7fffffe          BL       prvCheckTasksWaitingTermination
;;;3242   
;;;3243   		#if ( configUSE_PREEMPTION == 0 )
;;;3244   		{
;;;3245   			/* If we are not using preemption we keep forcing a task switch to
;;;3246   			see if any other task has become available.  If we are using
;;;3247   			preemption we don't need to do this as any task becoming available
;;;3248   			will automatically get the processor anyway. */
;;;3249   			taskYIELD();
;;;3250   		}
;;;3251   		#endif /* configUSE_PREEMPTION */
;;;3252   
;;;3253   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3254   		{
;;;3255   			/* When using preemption tasks of equal priority will be
;;;3256   			timesliced.  If a task that is sharing the idle priority is ready
;;;3257   			to run then the idle task should yield before the end of the
;;;3258   			timeslice.
;;;3259   
;;;3260   			A critical region is not required here as we are just reading from
;;;3261   			the list, and an occasional incorrect value will not matter.  If
;;;3262   			the ready list at the idle priority contains more than one task
;;;3263   			then a task other than the idle task is ready to execute. */
;;;3264   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
000006  6820              LDR      r0,[r4,#0]  ; pxReadyTasksLists
000008  2801              CMP      r0,#1
00000a  d901              BLS      |L7.16|
;;;3265   			{
;;;3266   				taskYIELD();
00000c  f7fffffe          BL       vPortYield
                  |L7.16|
;;;3267   			}
;;;3268   			else
;;;3269   			{
;;;3270   				mtCOVERAGE_TEST_MARKER();
;;;3271   			}
;;;3272   		}
;;;3273   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3274   
;;;3275   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3276   		{
;;;3277   			extern void vApplicationIdleHook( void );
;;;3278   
;;;3279   			/* Call the user defined function from within the idle task.  This
;;;3280   			allows the application designer to add background functionality
;;;3281   			without the overhead of a separate task.
;;;3282   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3283   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3284   			vApplicationIdleHook();
000010  f7fffffe          BL       vApplicationIdleHook
000014  e7f5              B        |L7.2|
;;;3285   		}
;;;3286   		#endif /* configUSE_IDLE_HOOK */
;;;3287   
;;;3288   		/* This conditional compilation should use inequality to 0, not equality
;;;3289   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3290   		user defined low power mode	implementations require
;;;3291   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3292   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3293   		{
;;;3294   		TickType_t xExpectedIdleTime;
;;;3295   
;;;3296   			/* It is not desirable to suspend then resume the scheduler on
;;;3297   			each iteration of the idle task.  Therefore, a preliminary
;;;3298   			test of the expected idle time is performed without the
;;;3299   			scheduler suspended.  The result here is not necessarily
;;;3300   			valid. */
;;;3301   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3302   
;;;3303   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3304   			{
;;;3305   				vTaskSuspendAll();
;;;3306   				{
;;;3307   					/* Now the scheduler is suspended, the expected idle
;;;3308   					time can be sampled again, and this time its value can
;;;3309   					be used. */
;;;3310   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3311   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3312   
;;;3313   					/* Define the following macro to set xExpectedIdleTime to 0
;;;3314   					if the application does not want
;;;3315   					portSUPPRESS_TICKS_AND_SLEEP() to be called. */
;;;3316   					configPRE_SUPPRESS_TICKS_AND_SLEEP_PROCESSING( xExpectedIdleTime );
;;;3317   
;;;3318   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3319   					{
;;;3320   						traceLOW_POWER_IDLE_BEGIN();
;;;3321   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3322   						traceLOW_POWER_IDLE_END();
;;;3323   					}
;;;3324   					else
;;;3325   					{
;;;3326   						mtCOVERAGE_TEST_MARKER();
;;;3327   					}
;;;3328   				}
;;;3329   				( void ) xTaskResumeAll();
;;;3330   			}
;;;3331   			else
;;;3332   			{
;;;3333   				mtCOVERAGE_TEST_MARKER();
;;;3334   			}
;;;3335   		}
;;;3336   		#endif /* configUSE_TICKLESS_IDLE */
;;;3337   	}
;;;3338   }
;;;3339   /*-----------------------------------------------------------*/
                          ENDP

000016  0000              DCW      0x0000
                  |L7.24|
                          DCD      NoInit

                          AREA ||i.prvInitialiseNewTask||, CODE, READONLY, ALIGN=1

                  prvInitialiseNewTask PROC
;;;822    
;;;823    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000000  b5ff              PUSH     {r0-r7,lr}
;;;824    									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;825    									const uint32_t ulStackDepth,
;;;826    									void * const pvParameters,
;;;827    									UBaseType_t uxPriority,
;;;828    									TaskHandle_t * const pxCreatedTask,
;;;829    									TCB_t *pxNewTCB,
;;;830    									const MemoryRegion_t * const xRegions )
;;;831    {
000002  b081              SUB      sp,sp,#4
000004  9d0a              LDR      r5,[sp,#0x28]
000006  9c0c              LDR      r4,[sp,#0x30]
000008  460e              MOV      r6,r1
00000a  4617              MOV      r7,r2
;;;832    StackType_t *pxTopOfStack;
;;;833    UBaseType_t x;
;;;834    
;;;835    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;836    		/* Should the task be created in privileged mode? */
;;;837    		BaseType_t xRunPrivileged;
;;;838    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;839    		{
;;;840    			xRunPrivileged = pdTRUE;
;;;841    		}
;;;842    		else
;;;843    		{
;;;844    			xRunPrivileged = pdFALSE;
;;;845    		}
;;;846    		uxPriority &= ~portPRIVILEGE_BIT;
;;;847    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;848    
;;;849    	/* Avoid dependency on memset() if it is not required. */
;;;850    	#if( tskSET_NEW_STACKS_TO_KNOWN_VALUE == 1 )
;;;851    	{
;;;852    		/* Fill the stack with a known value to assist debugging. */
;;;853    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
00000c  00b9              LSLS     r1,r7,#2
00000e  22a5              MOVS     r2,#0xa5
000010  6b20              LDR      r0,[r4,#0x30]
000012  f7fffffe          BL       __aeabi_memset
;;;854    	}
;;;855    	#endif /* tskSET_NEW_STACKS_TO_KNOWN_VALUE */
;;;856    
;;;857    	/* Calculate the top of stack address.  This depends on whether the stack
;;;858    	grows from high memory to low (as per the 80x86) or vice versa.
;;;859    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;860    	by the port. */
;;;861    	#if( portSTACK_GROWTH < 0 )
;;;862    	{
;;;863    		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
000016  1e7f              SUBS     r7,r7,#1
000018  6b20              LDR      r0,[r4,#0x30]
00001a  00b9              LSLS     r1,r7,#2
00001c  1840              ADDS     r0,r0,r1
;;;864    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
00001e  08c0              LSRS     r0,r0,#3
000020  00c0              LSLS     r0,r0,#3
000022  9000              STR      r0,[sp,#0]
;;;865    
;;;866    		/* Check the alignment of the calculated top of stack is correct. */
;;;867    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;868    
;;;869    		#if( configRECORD_STACK_HIGH_ADDRESS == 1 )
;;;870    		{
;;;871    			/* Also record the stack's high address, which may assist
;;;872    			debugging. */
;;;873    			pxNewTCB->pxEndOfStack = pxTopOfStack;
;;;874    		}
;;;875    		#endif /* configRECORD_STACK_HIGH_ADDRESS */
;;;876    	}
;;;877    	#else /* portSTACK_GROWTH */
;;;878    	{
;;;879    		pxTopOfStack = pxNewTCB->pxStack;
;;;880    
;;;881    		/* Check the alignment of the stack buffer is correct. */
;;;882    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;883    
;;;884    		/* The other extreme of the stack space is required if stack checking is
;;;885    		performed. */
;;;886    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;887    	}
;;;888    	#endif /* portSTACK_GROWTH */
;;;889    
;;;890    	/* Store the task name in the TCB. */
;;;891    	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000024  2000              MOVS     r0,#0
                  |L8.38|
;;;892    	{
;;;893    		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
000026  1821              ADDS     r1,r4,r0
000028  5c32              LDRB     r2,[r6,r0]
00002a  3120              ADDS     r1,r1,#0x20
00002c  750a              STRB     r2,[r1,#0x14]
;;;894    
;;;895    		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;896    		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;897    		string is not accessible (extremely unlikely). */
;;;898    		if( pcName[ x ] == 0x00 )
00002e  5c31              LDRB     r1,[r6,r0]
000030  2900              CMP      r1,#0
000032  d002              BEQ      |L8.58|
000034  1c40              ADDS     r0,r0,#1              ;891
000036  2810              CMP      r0,#0x10              ;891
000038  d3f5              BCC      |L8.38|
                  |L8.58|
;;;899    		{
;;;900    			break;
;;;901    		}
;;;902    		else
;;;903    		{
;;;904    			mtCOVERAGE_TEST_MARKER();
;;;905    		}
;;;906    	}
;;;907    
;;;908    	/* Ensure the name string is terminated in the case that the string length
;;;909    	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;910    	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
00003a  2600              MOVS     r6,#0
00003c  4620              MOV      r0,r4
00003e  3040              ADDS     r0,r0,#0x40
000040  4607              MOV      r7,r0
000042  70c6              STRB     r6,[r0,#3]
;;;911    
;;;912    	/* This is used as an array index so must ensure it's not too large.  First
;;;913    	remove the privilege bit if one is present. */
;;;914    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000044  2d0c              CMP      r5,#0xc
000046  d300              BCC      |L8.74|
;;;915    	{
;;;916    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000048  250b              MOVS     r5,#0xb
                  |L8.74|
;;;917    	}
;;;918    	else
;;;919    	{
;;;920    		mtCOVERAGE_TEST_MARKER();
;;;921    	}
;;;922    
;;;923    	pxNewTCB->uxPriority = uxPriority;
00004a  62e5              STR      r5,[r4,#0x2c]
;;;924    	#if ( configUSE_MUTEXES == 1 )
;;;925    	{
;;;926    		pxNewTCB->uxBasePriority = uxPriority;
00004c  6465              STR      r5,[r4,#0x44]
;;;927    		pxNewTCB->uxMutexesHeld = 0;
00004e  64a6              STR      r6,[r4,#0x48]
;;;928    	}
;;;929    	#endif /* configUSE_MUTEXES */
;;;930    
;;;931    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       vListInitialiseItem
;;;932    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
000056  4620              MOV      r0,r4
000058  3018              ADDS     r0,r0,#0x18
00005a  f7fffffe          BL       vListInitialiseItem
;;;933    
;;;934    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;935    	back to	the containing TCB from a generic item in a list. */
;;;936    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
00005e  6124              STR      r4,[r4,#0x10]
;;;937    
;;;938    	/* Event lists are always in priority order. */
;;;939    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000060  200c              MOVS     r0,#0xc
000062  1b40              SUBS     r0,r0,r5
000064  61a0              STR      r0,[r4,#0x18]
;;;940    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000066  6264              STR      r4,[r4,#0x24]
;;;941    
;;;942    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;943    	{
;;;944    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;945    	}
;;;946    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;947    
;;;948    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;949    	{
;;;950    		pxNewTCB->pxTaskTag = NULL;
;;;951    	}
;;;952    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;953    
;;;954    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;955    	{
;;;956    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;957    	}
;;;958    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;959    
;;;960    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;961    	{
;;;962    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;963    	}
;;;964    	#else
;;;965    	{
;;;966    		/* Avoid compiler warning about unreferenced parameter. */
;;;967    		( void ) xRegions;
;;;968    	}
;;;969    	#endif
;;;970    
;;;971    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;972    	{
;;;973    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;974    		{
;;;975    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;976    		}
;;;977    	}
;;;978    	#endif
;;;979    
;;;980    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;981    	{
;;;982    		pxNewTCB->ulNotifiedValue = 0;
000068  64e6              STR      r6,[r4,#0x4c]
;;;983    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00006a  743e              STRB     r6,[r7,#0x10]
;;;984    	}
;;;985    	#endif
;;;986    
;;;987    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;988    	{
;;;989    		/* Initialise this task's Newlib reent structure. */
;;;990    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;991    	}
;;;992    	#endif
;;;993    
;;;994    	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;995    	{
;;;996    		pxNewTCB->ucDelayAborted = pdFALSE;
;;;997    	}
;;;998    	#endif
;;;999    
;;;1000   	/* Initialize the TCB stack to look as if the task was already running,
;;;1001   	but had been interrupted by the scheduler.  The return address is set
;;;1002   	to the start of the task function. Once the stack has been initialised
;;;1003   	the top of stack variable is updated. */
;;;1004   	#if( portUSING_MPU_WRAPPERS == 1 )
;;;1005   	{
;;;1006   		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;1007   	}
;;;1008   	#else /* portUSING_MPU_WRAPPERS */
;;;1009   	{
;;;1010   		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
00006c  9a04              LDR      r2,[sp,#0x10]
00006e  9901              LDR      r1,[sp,#4]
000070  9800              LDR      r0,[sp,#0]
000072  f7fffffe          BL       pxPortInitialiseStack
000076  6020              STR      r0,[r4,#0]
;;;1011   	}
;;;1012   	#endif /* portUSING_MPU_WRAPPERS */
;;;1013   
;;;1014   	if( ( void * ) pxCreatedTask != NULL )
000078  980b              LDR      r0,[sp,#0x2c]
00007a  2800              CMP      r0,#0
00007c  d001              BEQ      |L8.130|
;;;1015   	{
;;;1016   		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;1017   		change the created task's priority, delete the created task, etc.*/
;;;1018   		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
00007e  980b              LDR      r0,[sp,#0x2c]
000080  6004              STR      r4,[r0,#0]
                  |L8.130|
;;;1019   	}
;;;1020   	else
;;;1021   	{
;;;1022   		mtCOVERAGE_TEST_MARKER();
;;;1023   	}
;;;1024   }
000082  b005              ADD      sp,sp,#0x14
000084  bdf0              POP      {r4-r7,pc}
;;;1025   /*-----------------------------------------------------------*/
                          ENDP


                          AREA ||i.prvInitialiseTaskLists||, CODE, READONLY, ALIGN=2

                  prvInitialiseTaskLists PROC
;;;3435   
;;;3436   static void prvInitialiseTaskLists( void )
000000  b570              PUSH     {r4-r6,lr}
;;;3437   {
;;;3438   UBaseType_t uxPriority;
;;;3439   
;;;3440   	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
000002  2400              MOVS     r4,#0
;;;3441   	{
;;;3442   		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
000004  4d11              LDR      r5,|L9.76|
                  |L9.6|
000006  2014              MOVS     r0,#0x14
000008  4360              MULS     r0,r4,r0
00000a  1940              ADDS     r0,r0,r5
00000c  f7fffffe          BL       vListInitialise
000010  1c64              ADDS     r4,r4,#1              ;3440
000012  2c0c              CMP      r4,#0xc               ;3440
000014  d3f7              BCC      |L9.6|
;;;3443   	}
;;;3444   
;;;3445   	vListInitialise( &xDelayedTaskList1 );
000016  480d              LDR      r0,|L9.76|
000018  30f0              ADDS     r0,r0,#0xf0
00001a  f7fffffe          BL       vListInitialise
;;;3446   	vListInitialise( &xDelayedTaskList2 );
00001e  480c              LDR      r0,|L9.80|
000020  f7fffffe          BL       vListInitialise
;;;3447   	vListInitialise( &xPendingReadyList );
000024  480a              LDR      r0,|L9.80|
000026  3014              ADDS     r0,r0,#0x14
000028  f7fffffe          BL       vListInitialise
;;;3448   
;;;3449   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3450   	{
;;;3451   		vListInitialise( &xTasksWaitingTermination );
00002c  4808              LDR      r0,|L9.80|
00002e  3028              ADDS     r0,r0,#0x28
000030  f7fffffe          BL       vListInitialise
;;;3452   	}
;;;3453   	#endif /* INCLUDE_vTaskDelete */
;;;3454   
;;;3455   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;3456   	{
;;;3457   		vListInitialise( &xSuspendedTaskList );
000034  4806              LDR      r0,|L9.80|
000036  303c              ADDS     r0,r0,#0x3c
000038  f7fffffe          BL       vListInitialise
;;;3458   	}
;;;3459   	#endif /* INCLUDE_vTaskSuspend */
;;;3460   
;;;3461   	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
;;;3462   	using list2. */
;;;3463   	pxDelayedTaskList = &xDelayedTaskList1;
00003c  4904              LDR      r1,|L9.80|
00003e  4805              LDR      r0,|L9.84|
000040  3914              SUBS     r1,r1,#0x14
000042  6341              STR      r1,[r0,#0x34]  ; pxDelayedTaskList
;;;3464   	pxOverflowDelayedTaskList = &xDelayedTaskList2;
000044  3114              ADDS     r1,r1,#0x14
000046  6381              STR      r1,[r0,#0x38]  ; pxOverflowDelayedTaskList
;;;3465   }
000048  bd70              POP      {r4-r6,pc}
;;;3466   /*-----------------------------------------------------------*/
                          ENDP

00004a  0000              DCW      0x0000
                  |L9.76|
                          DCD      NoInit
                  |L9.80|
                          DCD      NoInit+0x104
                  |L9.84|
                          DCD      ||.data||

                          AREA ||i.prvResetNextTaskUnblockTime||, CODE, READONLY, ALIGN=2

                  prvResetNextTaskUnblockTime PROC
;;;3729   
;;;3730   static void prvResetNextTaskUnblockTime( void )
000000  4807              LDR      r0,|L10.32|
;;;3731   {
;;;3732   TCB_t *pxTCB;
;;;3733   
;;;3734   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
000002  6b41              LDR      r1,[r0,#0x34]  ; pxDelayedTaskList
000004  6809              LDR      r1,[r1,#0]
000006  2900              CMP      r1,#0
000008  d005              BEQ      |L10.22|
;;;3735   	{
;;;3736   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3737   		the maximum possible value so it is	extremely unlikely that the
;;;3738   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3739   		there is an item in the delayed list. */
;;;3740   		xNextTaskUnblockTime = portMAX_DELAY;
;;;3741   	}
;;;3742   	else
;;;3743   	{
;;;3744   		/* The new current delayed list is not empty, get the value of
;;;3745   		the item at the head of the delayed list.  This is the time at
;;;3746   		which the task at the head of the delayed list should be removed
;;;3747   		from the Blocked state. */
;;;3748   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
00000a  6b41              LDR      r1,[r0,#0x34]  ; pxDelayedTaskList
00000c  68c9              LDR      r1,[r1,#0xc]
00000e  68c9              LDR      r1,[r1,#0xc]
;;;3749   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
000010  6849              LDR      r1,[r1,#4]
000012  6281              STR      r1,[r0,#0x28]  ; xNextTaskUnblockTime
;;;3750   	}
;;;3751   }
000014  4770              BX       lr
                  |L10.22|
000016  2100              MOVS     r1,#0                 ;3740
000018  43c9              MVNS     r1,r1                 ;3740
00001a  6281              STR      r1,[r0,#0x28]         ;3740  ; xNextTaskUnblockTime
00001c  4770              BX       lr
;;;3752   /*-----------------------------------------------------------*/
                          ENDP

00001e  0000              DCW      0x0000
                  |L10.32|
                          DCD      ||.data||

                          AREA ||i.prvTaskCheckFreeStackSpace||, CODE, READONLY, ALIGN=1

                  prvTaskCheckFreeStackSpace PROC
;;;3627   
;;;3628   	static uint16_t prvTaskCheckFreeStackSpace( const uint8_t * pucStackByte )
000000  2100              MOVS     r1,#0
;;;3629   	{
000002  e001              B        |L11.8|
                  |L11.4|
;;;3630   	uint32_t ulCount = 0U;
;;;3631   
;;;3632   		while( *pucStackByte == ( uint8_t ) tskSTACK_FILL_BYTE )
;;;3633   		{
;;;3634   			pucStackByte -= portSTACK_GROWTH;
000004  1c40              ADDS     r0,r0,#1
;;;3635   			ulCount++;
000006  1c49              ADDS     r1,r1,#1
                  |L11.8|
000008  7802              LDRB     r2,[r0,#0]            ;3632
00000a  2aa5              CMP      r2,#0xa5              ;3632
00000c  d0fa              BEQ      |L11.4|
;;;3636   		}
;;;3637   
;;;3638   		ulCount /= ( uint32_t ) sizeof( StackType_t ); /*lint !e961 Casting is not redundant on smaller architectures. */
00000e  0888              LSRS     r0,r1,#2
;;;3639   
;;;3640   		return ( uint16_t ) ulCount;
000010  b280              UXTH     r0,r0
;;;3641   	}
000012  4770              BX       lr
;;;3642   
                          ENDP


                          AREA ||i.prvTaskIsTaskSuspended||, CODE, READONLY, ALIGN=2

                  prvTaskIsTaskSuspended PROC
;;;1730   
;;;1731   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
000000  2100              MOVS     r1,#0
;;;1732   	{
;;;1733   	BaseType_t xReturn = pdFALSE;
;;;1734   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
;;;1735   
;;;1736   		/* Accesses xPendingReadyList so must be called from a critical
;;;1737   		section. */
;;;1738   
;;;1739   		/* It does not make sense to check if the calling task is suspended. */
;;;1740   		configASSERT( xTask );
;;;1741   
;;;1742   		/* Is the task being resumed actually in the suspended list? */
;;;1743   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
000002  4b07              LDR      r3,|L12.32|
000004  6942              LDR      r2,[r0,#0x14]
000006  429a              CMP      r2,r3
000008  d107              BNE      |L12.26|
;;;1744   		{
;;;1745   			/* Has the task already been resumed from within an ISR? */
;;;1746   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
00000a  6a80              LDR      r0,[r0,#0x28]
00000c  461a              MOV      r2,r3
00000e  3a28              SUBS     r2,r2,#0x28
000010  4290              CMP      r0,r2
000012  d002              BEQ      |L12.26|
;;;1747   			{
;;;1748   				/* Is it in the suspended list because it is in the	Suspended
;;;1749   				state, or because is is blocked with no timeout? */
;;;1750   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE ) /*lint !e961.  The cast is only redundant when NULL is used. */
000014  2800              CMP      r0,#0
000016  d100              BNE      |L12.26|
;;;1751   				{
;;;1752   					xReturn = pdTRUE;
000018  2101              MOVS     r1,#1
                  |L12.26|
;;;1753   				}
;;;1754   				else
;;;1755   				{
;;;1756   					mtCOVERAGE_TEST_MARKER();
;;;1757   				}
;;;1758   			}
;;;1759   			else
;;;1760   			{
;;;1761   				mtCOVERAGE_TEST_MARKER();
;;;1762   			}
;;;1763   		}
;;;1764   		else
;;;1765   		{
;;;1766   			mtCOVERAGE_TEST_MARKER();
;;;1767   		}
;;;1768   
;;;1769   		return xReturn;
00001a  4608              MOV      r0,r1
;;;1770   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
00001c  4770              BX       lr
;;;1771   
                          ENDP

00001e  0000              DCW      0x0000
                  |L12.32|
                          DCD      NoInit+0x140

                          AREA ||i.pvTaskIncrementMutexHeldCount||, CODE, READONLY, ALIGN=2

                  pvTaskIncrementMutexHeldCount PROC
;;;4397   
;;;4398   	void *pvTaskIncrementMutexHeldCount( void )
000000  4904              LDR      r1,|L13.20|
;;;4399   	{
;;;4400   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4401   		then pxCurrentTCB will be NULL. */
;;;4402   		if( pxCurrentTCB != NULL )
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000004  2800              CMP      r0,#0
000006  d003              BEQ      |L13.16|
;;;4403   		{
;;;4404   			( pxCurrentTCB->uxMutexesHeld )++;
000008  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
00000a  6c82              LDR      r2,[r0,#0x48]
00000c  1c52              ADDS     r2,r2,#1
00000e  6482              STR      r2,[r0,#0x48]
                  |L13.16|
;;;4405   		}
;;;4406   
;;;4407   		return pxCurrentTCB;
000010  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;4408   	}
000012  4770              BX       lr
;;;4409   
                          ENDP

                  |L13.20|
                          DCD      ||.data||

                          AREA ||i.ulTaskNotifyTake||, CODE, READONLY, ALIGN=2

                  ulTaskNotifyTake PROC
;;;4414   
;;;4415   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000000  b570              PUSH     {r4-r6,lr}
;;;4416   	{
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;4417   	uint32_t ulReturn;
;;;4418   
;;;4419   		taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;4420   		{
;;;4421   			/* Only block if the notification count is not already non-zero. */
;;;4422   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
00000a  4d14              LDR      r5,|L14.92|
00000c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000e  6cc0              LDR      r0,[r0,#0x4c]
000010  2800              CMP      r0,#0
000012  d10a              BNE      |L14.42|
;;;4423   			{
;;;4424   				/* Mark this task as waiting for a notification. */
;;;4425   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000014  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000016  2101              MOVS     r1,#1
000018  3040              ADDS     r0,r0,#0x40
00001a  7401              STRB     r1,[r0,#0x10]
;;;4426   
;;;4427   				if( xTicksToWait > ( TickType_t ) 0 )
00001c  2c00              CMP      r4,#0
00001e  d004              BEQ      |L14.42|
;;;4428   				{
;;;4429   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4430   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4431   
;;;4432   					/* All ports are written to allow a yield in a critical
;;;4433   					section (some will yield immediately, others wait until the
;;;4434   					critical section exits) - but it is not something that
;;;4435   					application code should ever do. */
;;;4436   					portYIELD_WITHIN_API();
000026  f7fffffe          BL       vPortYield
                  |L14.42|
;;;4437   				}
;;;4438   				else
;;;4439   				{
;;;4440   					mtCOVERAGE_TEST_MARKER();
;;;4441   				}
;;;4442   			}
;;;4443   			else
;;;4444   			{
;;;4445   				mtCOVERAGE_TEST_MARKER();
;;;4446   			}
;;;4447   		}
;;;4448   		taskEXIT_CRITICAL();
00002a  f7fffffe          BL       vPortExitCritical
;;;4449   
;;;4450   		taskENTER_CRITICAL();
00002e  f7fffffe          BL       vPortEnterCritical
;;;4451   		{
;;;4452   			traceTASK_NOTIFY_TAKE();
;;;4453   			ulReturn = pxCurrentTCB->ulNotifiedValue;
000032  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000034  6cc4              LDR      r4,[r0,#0x4c]
;;;4454   
;;;4455   			if( ulReturn != 0UL )
000036  2100              MOVS     r1,#0
000038  2c00              CMP      r4,#0
00003a  d007              BEQ      |L14.76|
;;;4456   			{
;;;4457   				if( xClearCountOnExit != pdFALSE )
00003c  2e00              CMP      r6,#0
00003e  d002              BEQ      |L14.70|
;;;4458   				{
;;;4459   					pxCurrentTCB->ulNotifiedValue = 0UL;
000040  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000042  64c1              STR      r1,[r0,#0x4c]
000044  e002              B        |L14.76|
                  |L14.70|
;;;4460   				}
;;;4461   				else
;;;4462   				{
;;;4463   					pxCurrentTCB->ulNotifiedValue = ulReturn - ( uint32_t ) 1;
000046  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
000048  1e60              SUBS     r0,r4,#1
00004a  64d0              STR      r0,[r2,#0x4c]
                  |L14.76|
;;;4464   				}
;;;4465   			}
;;;4466   			else
;;;4467   			{
;;;4468   				mtCOVERAGE_TEST_MARKER();
;;;4469   			}
;;;4470   
;;;4471   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
00004c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00004e  3040              ADDS     r0,r0,#0x40
000050  7401              STRB     r1,[r0,#0x10]
;;;4472   		}
;;;4473   		taskEXIT_CRITICAL();
000052  f7fffffe          BL       vPortExitCritical
;;;4474   
;;;4475   		return ulReturn;
000056  4620              MOV      r0,r4
;;;4476   	}
000058  bd70              POP      {r4-r6,pc}
;;;4477   
                          ENDP

00005a  0000              DCW      0x0000
                  |L14.92|
                          DCD      ||.data||

                          AREA ||i.uxTaskGetNumberOfTasks||, CODE, READONLY, ALIGN=2

                  uxTaskGetNumberOfTasks PROC
;;;2260   
;;;2261   UBaseType_t uxTaskGetNumberOfTasks( void )
000000  4801              LDR      r0,|L15.8|
;;;2262   {
;;;2263   	/* A critical section is not required because the variables are of type
;;;2264   	BaseType_t. */
;;;2265   	return uxCurrentNumberOfTasks;
000002  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;2266   }
000004  4770              BX       lr
;;;2267   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L15.8|
                          DCD      ||.data||

                          AREA ||i.uxTaskGetStackHighWaterMark||, CODE, READONLY, ALIGN=2

                  uxTaskGetStackHighWaterMark PROC
;;;3647   
;;;3648   	UBaseType_t uxTaskGetStackHighWaterMark( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;3649   	{
;;;3650   	TCB_t *pxTCB;
;;;3651   	uint8_t *pucEndOfStack;
;;;3652   	UBaseType_t uxReturn;
;;;3653   
;;;3654   		pxTCB = prvGetTCBFromHandle( xTask );
000002  2800              CMP      r0,#0
000004  d101              BNE      |L16.10|
000006  4803              LDR      r0,|L16.20|
000008  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
                  |L16.10|
;;;3655   
;;;3656   		#if portSTACK_GROWTH < 0
;;;3657   		{
;;;3658   			pucEndOfStack = ( uint8_t * ) pxTCB->pxStack;
00000a  6b00              LDR      r0,[r0,#0x30]
;;;3659   		}
;;;3660   		#else
;;;3661   		{
;;;3662   			pucEndOfStack = ( uint8_t * ) pxTCB->pxEndOfStack;
;;;3663   		}
;;;3664   		#endif
;;;3665   
;;;3666   		uxReturn = ( UBaseType_t ) prvTaskCheckFreeStackSpace( pucEndOfStack );
00000c  f7fffffe          BL       prvTaskCheckFreeStackSpace
;;;3667   
;;;3668   		return uxReturn;
;;;3669   	}
000010  bd10              POP      {r4,pc}
;;;3670   
                          ENDP

000012  0000              DCW      0x0000
                  |L16.20|
                          DCD      ||.data||

                          AREA ||i.uxTaskPriorityGet||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGet PROC
;;;1403   
;;;1404   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1405   	{
000002  4604              MOV      r4,r0
;;;1406   	TCB_t *pxTCB;
;;;1407   	UBaseType_t uxReturn;
;;;1408   
;;;1409   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1410   		{
;;;1411   			/* If null is passed in here then it is the priority of the that
;;;1412   			called uxTaskPriorityGet() that is being queried. */
;;;1413   			pxTCB = prvGetTCBFromHandle( xTask );
000008  2c00              CMP      r4,#0
00000a  d101              BNE      |L17.16|
00000c  4803              LDR      r0,|L17.28|
00000e  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L17.16|
;;;1414   			uxReturn = pxTCB->uxPriority;
000010  6ae4              LDR      r4,[r4,#0x2c]
;;;1415   		}
;;;1416   		taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;1417   
;;;1418   		return uxReturn;
000016  4620              MOV      r0,r4
;;;1419   	}
000018  bd10              POP      {r4,pc}
;;;1420   
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      ||.data||

                          AREA ||i.uxTaskPriorityGetFromISR||, CODE, READONLY, ALIGN=2

                  uxTaskPriorityGetFromISR PROC
;;;1425   
;;;1426   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;1427   	{
000002  4604              MOV      r4,r0
;;;1428   	TCB_t *pxTCB;
;;;1429   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1430   
;;;1431   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1432   		maximum	system call (or maximum API call) interrupt priority.
;;;1433   		Interrupts that are	above the maximum system call priority are keep
;;;1434   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1435   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1436   		is defined in FreeRTOSConfig.h then
;;;1437   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1438   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1439   		been assigned a priority above the configured maximum system call
;;;1440   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1441   		from interrupts	that have been assigned a priority at or (logically)
;;;1442   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1443   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1444   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1445   		provided on the following link:
;;;1446   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1447   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1448   
;;;1449   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
000004  f7fffffe          BL       ulSetInterruptMaskFromISR
;;;1450   		{
;;;1451   			/* If null is passed in here then it is the priority of the calling
;;;1452   			task that is being queried. */
;;;1453   			pxTCB = prvGetTCBFromHandle( xTask );
000008  2c00              CMP      r4,#0
00000a  d101              BNE      |L18.16|
00000c  4903              LDR      r1,|L18.28|
00000e  680c              LDR      r4,[r1,#0]  ; pxCurrentTCB
                  |L18.16|
;;;1454   			uxReturn = pxTCB->uxPriority;
000010  6ae4              LDR      r4,[r4,#0x2c]
;;;1455   		}
;;;1456   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
000012  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1457   
;;;1458   		return uxReturn;
000016  4620              MOV      r0,r4
;;;1459   	}
000018  bd10              POP      {r4,pc}
;;;1460   
                          ENDP

00001a  0000              DCW      0x0000
                  |L18.28|
                          DCD      ||.data||

                          AREA ||i.uxTaskResetEventItemValue||, CODE, READONLY, ALIGN=2

                  uxTaskResetEventItemValue PROC
;;;4381   
;;;4382   TickType_t uxTaskResetEventItemValue( void )
000000  4904              LDR      r1,|L19.20|
;;;4383   {
;;;4384   TickType_t uxReturn;
;;;4385   
;;;4386   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000002  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000004  6980              LDR      r0,[r0,#0x18]
;;;4387   
;;;4388   	/* Reset the event list item to its normal value - so it can be used with
;;;4389   	queues and semaphores. */
;;;4390   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000006  680a              LDR      r2,[r1,#0]  ; pxCurrentTCB
000008  230c              MOVS     r3,#0xc
00000a  6ad2              LDR      r2,[r2,#0x2c]
00000c  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
00000e  1a9a              SUBS     r2,r3,r2
000010  618a              STR      r2,[r1,#0x18]
;;;4391   
;;;4392   	return uxReturn;
;;;4393   }
000012  4770              BX       lr
;;;4394   /*-----------------------------------------------------------*/
                          ENDP

                  |L19.20|
                          DCD      ||.data||

                          AREA ||i.vTaskDelay||, CODE, READONLY, ALIGN=1

                  vTaskDelay PROC
;;;1287   
;;;1288   	void vTaskDelay( const TickType_t xTicksToDelay )
000000  b510              PUSH     {r4,lr}
;;;1289   	{
000002  4602              MOV      r2,r0
;;;1290   	BaseType_t xAlreadyYielded = pdFALSE;
000004  2000              MOVS     r0,#0
;;;1291   
;;;1292   		/* A delay time of zero just forces a reschedule. */
;;;1293   		if( xTicksToDelay > ( TickType_t ) 0U )
000006  2a00              CMP      r2,#0
000008  d007              BEQ      |L20.26|
;;;1294   		{
;;;1295   			configASSERT( uxSchedulerSuspended == 0 );
;;;1296   			vTaskSuspendAll();
00000a  f7fffffe          BL       vTaskSuspendAll
;;;1297   			{
;;;1298   				traceTASK_DELAY();
;;;1299   
;;;1300   				/* A task that is removed from the event list while the
;;;1301   				scheduler is suspended will not get placed in the ready
;;;1302   				list or removed from the blocked list until the scheduler
;;;1303   				is resumed.
;;;1304   
;;;1305   				This task cannot be in an event list as it is the currently
;;;1306   				executing task. */
;;;1307   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
00000e  2100              MOVS     r1,#0
000010  4610              MOV      r0,r2
000012  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1308   			}
;;;1309   			xAlreadyYielded = xTaskResumeAll();
000016  f7fffffe          BL       xTaskResumeAll
                  |L20.26|
;;;1310   		}
;;;1311   		else
;;;1312   		{
;;;1313   			mtCOVERAGE_TEST_MARKER();
;;;1314   		}
;;;1315   
;;;1316   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1317   		have put ourselves to sleep. */
;;;1318   		if( xAlreadyYielded == pdFALSE )
00001a  2800              CMP      r0,#0
00001c  d101              BNE      |L20.34|
;;;1319   		{
;;;1320   			portYIELD_WITHIN_API();
00001e  f7fffffe          BL       vPortYield
                  |L20.34|
;;;1321   		}
;;;1322   		else
;;;1323   		{
;;;1324   			mtCOVERAGE_TEST_MARKER();
;;;1325   		}
;;;1326   	}
000022  bd10              POP      {r4,pc}
;;;1327   
                          ENDP


                          AREA ||i.vTaskDelayUntil||, CODE, READONLY, ALIGN=2

                  vTaskDelayUntil PROC
;;;1203   
;;;1204   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
000000  b570              PUSH     {r4-r6,lr}
;;;1205   	{
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1206   	TickType_t xTimeToWake;
;;;1207   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000006  2300              MOVS     r3,#0
;;;1208   
;;;1209   		configASSERT( pxPreviousWakeTime );
;;;1210   		configASSERT( ( xTimeIncrement > 0U ) );
;;;1211   		configASSERT( uxSchedulerSuspended == 0 );
;;;1212   
;;;1213   		vTaskSuspendAll();
000008  f7fffffe          BL       vTaskSuspendAll
;;;1214   		{
;;;1215   			/* Minor optimisation.  The tick count cannot change in this
;;;1216   			block. */
;;;1217   			const TickType_t xConstTickCount = xTickCount;
00000c  480f              LDR      r0,|L21.76|
00000e  68c2              LDR      r2,[r0,#0xc]  ; xTickCount
;;;1218   
;;;1219   			/* Generate the tick time at which the task wants to wake. */
;;;1220   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
000010  682c              LDR      r4,[r5,#0]
000012  19a1              ADDS     r1,r4,r6
;;;1221   
;;;1222   			if( xConstTickCount < *pxPreviousWakeTime )
000014  4294              CMP      r4,r2
000016  d905              BLS      |L21.36|
;;;1223   			{
;;;1224   				/* The tick count has overflowed since this function was
;;;1225   				lasted called.  In this case the only time we should ever
;;;1226   				actually delay is if the wake time has also	overflowed,
;;;1227   				and the wake time is greater than the tick time.  When this
;;;1228   				is the case it is as if neither time had overflowed. */
;;;1229   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
000018  428c              CMP      r4,r1
00001a  d908              BLS      |L21.46|
00001c  4291              CMP      r1,r2
00001e  d906              BLS      |L21.46|
;;;1230   				{
;;;1231   					xShouldDelay = pdTRUE;
000020  2301              MOVS     r3,#1
000022  e004              B        |L21.46|
                  |L21.36|
;;;1232   				}
;;;1233   				else
;;;1234   				{
;;;1235   					mtCOVERAGE_TEST_MARKER();
;;;1236   				}
;;;1237   			}
;;;1238   			else
;;;1239   			{
;;;1240   				/* The tick time has not overflowed.  In this case we will
;;;1241   				delay if either the wake time has overflowed, and/or the
;;;1242   				tick time is less than the wake time. */
;;;1243   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
000024  428c              CMP      r4,r1
000026  d801              BHI      |L21.44|
000028  4291              CMP      r1,r2
00002a  d900              BLS      |L21.46|
                  |L21.44|
;;;1244   				{
;;;1245   					xShouldDelay = pdTRUE;
00002c  2301              MOVS     r3,#1
                  |L21.46|
;;;1246   				}
;;;1247   				else
;;;1248   				{
;;;1249   					mtCOVERAGE_TEST_MARKER();
;;;1250   				}
;;;1251   			}
;;;1252   
;;;1253   			/* Update the wake time ready for the next call. */
;;;1254   			*pxPreviousWakeTime = xTimeToWake;
00002e  6029              STR      r1,[r5,#0]
;;;1255   
;;;1256   			if( xShouldDelay != pdFALSE )
000030  2b00              CMP      r3,#0
000032  d003              BEQ      |L21.60|
;;;1257   			{
;;;1258   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1259   
;;;1260   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1261   				the time to wake, so subtract the current tick count. */
;;;1262   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
000034  1a88              SUBS     r0,r1,r2
000036  2100              MOVS     r1,#0
000038  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L21.60|
;;;1263   			}
;;;1264   			else
;;;1265   			{
;;;1266   				mtCOVERAGE_TEST_MARKER();
;;;1267   			}
;;;1268   		}
;;;1269   		xAlreadyYielded = xTaskResumeAll();
00003c  f7fffffe          BL       xTaskResumeAll
;;;1270   
;;;1271   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1272   		have put ourselves to sleep. */
;;;1273   		if( xAlreadyYielded == pdFALSE )
000040  2800              CMP      r0,#0
000042  d101              BNE      |L21.72|
;;;1274   		{
;;;1275   			portYIELD_WITHIN_API();
000044  f7fffffe          BL       vPortYield
                  |L21.72|
;;;1276   		}
;;;1277   		else
;;;1278   		{
;;;1279   			mtCOVERAGE_TEST_MARKER();
;;;1280   		}
;;;1281   	}
000048  bd70              POP      {r4-r6,pc}
;;;1282   
                          ENDP

00004a  0000              DCW      0x0000
                  |L21.76|
                          DCD      ||.data||

                          AREA ||i.vTaskDelete||, CODE, READONLY, ALIGN=2

                  vTaskDelete PROC
;;;1111   
;;;1112   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000000  b570              PUSH     {r4-r6,lr}
;;;1113   	{
000002  4604              MOV      r4,r0
;;;1114   	TCB_t *pxTCB;
;;;1115   
;;;1116   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1117   		{
;;;1118   			/* If null is passed in here then it is the calling task that is
;;;1119   			being deleted. */
;;;1120   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
000008  4d17              LDR      r5,|L22.104|
00000a  2c00              CMP      r4,#0
00000c  d100              BNE      |L22.16|
00000e  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L22.16|
;;;1121   
;;;1122   			/* Remove task from the ready list. */
;;;1123   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       uxListRemove
;;;1124   			{
;;;1125   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1126   			}
;;;1127   			else
;;;1128   			{
;;;1129   				mtCOVERAGE_TEST_MARKER();
;;;1130   			}
;;;1131   
;;;1132   			/* Is the task waiting on an event also? */
;;;1133   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000016  6aa0              LDR      r0,[r4,#0x28]
000018  2800              CMP      r0,#0
00001a  d003              BEQ      |L22.36|
;;;1134   			{
;;;1135   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001c  4620              MOV      r0,r4
00001e  3018              ADDS     r0,r0,#0x18
000020  f7fffffe          BL       uxListRemove
                  |L22.36|
;;;1136   			}
;;;1137   			else
;;;1138   			{
;;;1139   				mtCOVERAGE_TEST_MARKER();
;;;1140   			}
;;;1141   
;;;1142   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1143   			detect that the task lists need re-generating.  This is done before
;;;1144   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1145   			not return. */
;;;1146   			uxTaskNumber++;
000024  6a68              LDR      r0,[r5,#0x24]  ; uxTaskNumber
000026  1c40              ADDS     r0,r0,#1
000028  6268              STR      r0,[r5,#0x24]  ; uxTaskNumber
;;;1147   
;;;1148   			if( pxTCB == pxCurrentTCB )
00002a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00002c  4284              CMP      r4,r0
00002e  d107              BNE      |L22.64|
;;;1149   			{
;;;1150   				/* A task is deleting itself.  This cannot complete within the
;;;1151   				task itself, as a context switch to another task is required.
;;;1152   				Place the task in the termination list.  The idle task will
;;;1153   				check the termination list and free up any memory allocated by
;;;1154   				the scheduler for the TCB and stack of the deleted task. */
;;;1155   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
000030  1d21              ADDS     r1,r4,#4
000032  480e              LDR      r0,|L22.108|
000034  f7fffffe          BL       vListInsertEnd
;;;1156   
;;;1157   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1158   				there is a task that has been deleted and that it should therefore
;;;1159   				check the xTasksWaitingTermination list. */
;;;1160   				++uxDeletedTasksWaitingCleanUp;
000038  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
00003a  1c40              ADDS     r0,r0,#1
00003c  6068              STR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
00003e  e007              B        |L22.80|
                  |L22.64|
;;;1161   
;;;1162   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1163   				in which Windows specific clean up operations are performed,
;;;1164   				after which it is not possible to yield away from this task -
;;;1165   				hence xYieldPending is used to latch that a context switch is
;;;1166   				required. */
;;;1167   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1168   			}
;;;1169   			else
;;;1170   			{
;;;1171   				--uxCurrentNumberOfTasks;
000040  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
000042  1e40              SUBS     r0,r0,#1
000044  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;1172   				prvDeleteTCB( pxTCB );
000046  4620              MOV      r0,r4
000048  f7fffffe          BL       prvDeleteTCB
;;;1173   
;;;1174   				/* Reset the next expected unblock time in case it referred to
;;;1175   				the task that has just been deleted. */
;;;1176   				prvResetNextTaskUnblockTime();
00004c  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L22.80|
;;;1177   			}
;;;1178   
;;;1179   			traceTASK_DELETE( pxTCB );
;;;1180   		}
;;;1181   		taskEXIT_CRITICAL();
000050  f7fffffe          BL       vPortExitCritical
;;;1182   
;;;1183   		/* Force a reschedule if it is the currently running task that has just
;;;1184   		been deleted. */
;;;1185   		if( xSchedulerRunning != pdFALSE )
000054  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000056  2800              CMP      r0,#0
000058  d004              BEQ      |L22.100|
;;;1186   		{
;;;1187   			if( pxTCB == pxCurrentTCB )
00005a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00005c  4284              CMP      r4,r0
00005e  d101              BNE      |L22.100|
;;;1188   			{
;;;1189   				configASSERT( uxSchedulerSuspended == 0 );
;;;1190   				portYIELD_WITHIN_API();
000060  f7fffffe          BL       vPortYield
                  |L22.100|
;;;1191   			}
;;;1192   			else
;;;1193   			{
;;;1194   				mtCOVERAGE_TEST_MARKER();
;;;1195   			}
;;;1196   		}
;;;1197   	}
000064  bd70              POP      {r4-r6,pc}
;;;1198   
                          ENDP

000066  0000              DCW      0x0000
                  |L22.104|
                          DCD      ||.data||
                  |L22.108|
                          DCD      NoInit+0x12c

                          AREA ||i.vTaskEndScheduler||, CODE, READONLY, ALIGN=2

                  vTaskEndScheduler PROC
;;;2020   
;;;2021   void vTaskEndScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;2022   {
;;;2023   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;2024   	routine so the original ISRs can be restored if necessary.  The port
;;;2025   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;2026   	portDISABLE_INTERRUPTS();
000002  b672              CPSID    i
;;;2027   	xSchedulerRunning = pdFALSE;
000004  2000              MOVS     r0,#0
000006  4902              LDR      r1,|L23.16|
000008  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;2028   	vPortEndScheduler();
00000a  f7fffffe          BL       vPortEndScheduler
;;;2029   }
00000e  bd10              POP      {r4,pc}
;;;2030   /*----------------------------------------------------------*/
                          ENDP

                  |L23.16|
                          DCD      ||.data||

                          AREA ||i.vTaskInternalSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskInternalSetTimeOutState PROC
;;;3097   
;;;3098   void vTaskInternalSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  4902              LDR      r1,|L24.12|
;;;3099   {
;;;3100   	/* For internal use only as it does not use a critical section. */
;;;3101   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000002  6a0a              LDR      r2,[r1,#0x20]  ; xNumOfOverflows
000004  6002              STR      r2,[r0,#0]
;;;3102   	pxTimeOut->xTimeOnEntering = xTickCount;
000006  68c9              LDR      r1,[r1,#0xc]  ; xTickCount
000008  6041              STR      r1,[r0,#4]
;;;3103   }
00000a  4770              BX       lr
;;;3104   /*-----------------------------------------------------------*/
                          ENDP

                  |L24.12|
                          DCD      ||.data||

                          AREA ||i.vTaskMissedYield||, CODE, READONLY, ALIGN=2

                  vTaskMissedYield PROC
;;;3168   
;;;3169   void vTaskMissedYield( void )
000000  4901              LDR      r1,|L25.8|
;;;3170   {
;;;3171   	xYieldPending = pdTRUE;
000002  2001              MOVS     r0,#1
000004  61c8              STR      r0,[r1,#0x1c]  ; xYieldPending
;;;3172   }
000006  4770              BX       lr
;;;3173   /*-----------------------------------------------------------*/
                          ENDP

                  |L25.8|
                          DCD      ||.data||

                          AREA ||i.vTaskNotifyGiveFromISR||, CODE, READONLY, ALIGN=2

                  vTaskNotifyGiveFromISR PROC
;;;4792   
;;;4793   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000000  b5f8              PUSH     {r3-r7,lr}
;;;4794   	{
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;4795   		TCB_t * pxTCB = xTaskToNotify;
;;;4796   		uint8_t ucOriginalNotifyState = pxTCB->ucNotifyState;
000006  4625              MOV      r5,r4
000008  3540              ADDS     r5,r5,#0x40
00000a  7c28              LDRB     r0,[r5,#0x10]
;;;4797   		UBaseType_t uxSavedInterruptStatus;
;;;4798   
;;;4799   		configASSERT( xTaskToNotify );
;;;4800   
;;;4801   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4802   		maximum	system call (or maximum API call) interrupt priority.
;;;4803   		Interrupts that are	above the maximum system call priority are keep
;;;4804   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4805   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4806   		is defined in FreeRTOSConfig.h then
;;;4807   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4808   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4809   		been assigned a priority above the configured maximum system call
;;;4810   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4811   		from interrupts	that have been assigned a priority at or (logically)
;;;4812   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4813   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4814   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4815   		provided on the following link:
;;;4816   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4817   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4818   
;;;4819   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4820   
;;;4821   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000c  f7fffffe          BL       ulSetInterruptMaskFromISR
000010  4607              MOV      r7,r0
;;;4822   		{
;;;4823   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000012  7c28              LDRB     r0,[r5,#0x10]
;;;4824   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000014  2102              MOVS     r1,#2
000016  7429              STRB     r1,[r5,#0x10]
;;;4825   
;;;4826   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4827   			semaphore. */
;;;4828   			( pxTCB->ulNotifiedValue )++;
000018  6ce1              LDR      r1,[r4,#0x4c]
00001a  1c49              ADDS     r1,r1,#1
00001c  64e1              STR      r1,[r4,#0x4c]
;;;4829   
;;;4830   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4831   
;;;4832   			/* If the task is in the blocked state specifically to wait for a
;;;4833   			notification then unblock it now. */
;;;4834   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
00001e  2801              CMP      r0,#1
000020  d123              BNE      |L26.106|
;;;4835   			{
;;;4836   				/* The task should not have been on an event list. */
;;;4837   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4838   
;;;4839   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000022  4d14              LDR      r5,|L26.116|
000024  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000026  2800              CMP      r0,#0
000028  d00e              BEQ      |L26.72|
;;;4840   				{
;;;4841   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;4842   					prvAddTaskToReadyList( pxTCB );
;;;4843   				}
;;;4844   				else
;;;4845   				{
;;;4846   					/* The delayed and ready lists cannot be accessed, so hold
;;;4847   					this task pending until the scheduler is resumed. */
;;;4848   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00002a  4621              MOV      r1,r4
00002c  3118              ADDS     r1,r1,#0x18
00002e  4812              LDR      r0,|L26.120|
000030  f7fffffe          BL       vListInsertEnd
                  |L26.52|
;;;4849   				}
;;;4850   
;;;4851   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000034  6ae0              LDR      r0,[r4,#0x2c]
000036  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000038  6ac9              LDR      r1,[r1,#0x2c]
00003a  4288              CMP      r0,r1
00003c  d915              BLS      |L26.106|
00003e  2001              MOVS     r0,#1                 ;4796
;;;4852   				{
;;;4853   					/* The notified task has a priority above the currently
;;;4854   					executing task so a yield is required. */
;;;4855   					if( pxHigherPriorityTaskWoken != NULL )
000040  2e00              CMP      r6,#0
000042  d011              BEQ      |L26.104|
;;;4856   					{
;;;4857   						*pxHigherPriorityTaskWoken = pdTRUE;
000044  6030              STR      r0,[r6,#0]
000046  e010              B        |L26.106|
                  |L26.72|
000048  1d20              ADDS     r0,r4,#4              ;4841
00004a  f7fffffe          BL       uxListRemove
00004e  6ae0              LDR      r0,[r4,#0x2c]         ;4842
000050  6929              LDR      r1,[r5,#0x10]         ;4842  ; uxTopReadyPriority
000052  4288              CMP      r0,r1                 ;4842
000054  d900              BLS      |L26.88|
000056  6128              STR      r0,[r5,#0x10]         ;4842  ; uxTopReadyPriority
                  |L26.88|
000058  2114              MOVS     r1,#0x14              ;4842
00005a  4348              MULS     r0,r1,r0              ;4842
00005c  4907              LDR      r1,|L26.124|
00005e  1840              ADDS     r0,r0,r1              ;4842
000060  1d21              ADDS     r1,r4,#4              ;4842
000062  f7fffffe          BL       vListInsertEnd
000066  e7e5              B        |L26.52|
                  |L26.104|
;;;4858   					}
;;;4859   					else
;;;4860   					{
;;;4861   						/* Mark that a yield is pending in case the user is not
;;;4862   						using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;4863   						safe FreeRTOS function. */
;;;4864   						xYieldPending = pdTRUE;
000068  61e8              STR      r0,[r5,#0x1c]  ; xYieldPending
                  |L26.106|
;;;4865   					}
;;;4866   				}
;;;4867   				else
;;;4868   				{
;;;4869   					mtCOVERAGE_TEST_MARKER();
;;;4870   				}
;;;4871   			}
;;;4872   		}
;;;4873   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
00006a  4638              MOV      r0,r7
00006c  f7fffffe          BL       vClearInterruptMaskFromISR
;;;4874   	}
000070  bdf8              POP      {r3-r7,pc}
;;;4875   
                          ENDP

000072  0000              DCW      0x0000
                  |L26.116|
                          DCD      ||.data||
                  |L26.120|
                          DCD      NoInit+0x118
                  |L26.124|
                          DCD      NoInit

                          AREA ||i.vTaskPlaceOnEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnEventList PROC
;;;2909   
;;;2910   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
000000  b510              PUSH     {r4,lr}
;;;2911   {
000002  460c              MOV      r4,r1
;;;2912   	configASSERT( pxEventList );
;;;2913   
;;;2914   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2915   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2916   
;;;2917   	/* Place the event list item of the TCB in the appropriate event list.
;;;2918   	This is placed in the list in priority order so the highest priority task
;;;2919   	is the first to be woken by the event.  The queue that contains the event
;;;2920   	list is locked, preventing simultaneous access from interrupts. */
;;;2921   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000004  4904              LDR      r1,|L27.24|
000006  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000008  3118              ADDS     r1,r1,#0x18
00000a  f7fffffe          BL       vListInsert
;;;2922   
;;;2923   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00000e  2101              MOVS     r1,#1
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2924   }
000016  bd10              POP      {r4,pc}
;;;2925   /*-----------------------------------------------------------*/
                          ENDP

                  |L27.24|
                          DCD      ||.data||

                          AREA ||i.vTaskPlaceOnUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskPlaceOnUnorderedEventList PROC
;;;2926   
;;;2927   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000000  b510              PUSH     {r4,lr}
;;;2928   {
000002  4614              MOV      r4,r2
;;;2929   	configASSERT( pxEventList );
;;;2930   
;;;2931   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2932   	the event groups implementation. */
;;;2933   	configASSERT( uxSchedulerSuspended != 0 );
;;;2934   
;;;2935   	/* Store the item value in the event list item.  It is safe to access the
;;;2936   	event list item here as interrupts won't access the event list item of a
;;;2937   	task that is not in the Blocked state. */
;;;2938   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000004  2201              MOVS     r2,#1
000006  07d2              LSLS     r2,r2,#31
000008  4b06              LDR      r3,|L28.36|
00000a  4311              ORRS     r1,r1,r2
00000c  681a              LDR      r2,[r3,#0]  ; pxCurrentTCB
00000e  6191              STR      r1,[r2,#0x18]
;;;2939   
;;;2940   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2941   	list.  It is safe to access the event list here because it is part of an
;;;2942   	event group implementation - and interrupts don't access event groups
;;;2943   	directly (instead they access them indirectly by pending function calls to
;;;2944   	the task level). */
;;;2945   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000010  6819              LDR      r1,[r3,#0]  ; pxCurrentTCB
000012  3118              ADDS     r1,r1,#0x18
000014  f7fffffe          BL       vListInsertEnd
;;;2946   
;;;2947   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000018  2101              MOVS     r1,#1
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;2948   }
000020  bd10              POP      {r4,pc}
;;;2949   /*-----------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L28.36|
                          DCD      ||.data||

                          AREA ||i.vTaskPriorityDisinheritAfterTimeout||, CODE, READONLY, ALIGN=2

                  vTaskPriorityDisinheritAfterTimeout PROC
;;;3967   
;;;3968   	void vTaskPriorityDisinheritAfterTimeout( TaskHandle_t const pxMutexHolder, UBaseType_t uxHighestPriorityWaitingTask )
000000  b570              PUSH     {r4-r6,lr}
;;;3969   	{
000002  460a              MOV      r2,r1
;;;3970   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000004  4604              MOV      r4,r0
;;;3971   	UBaseType_t uxPriorityUsedOnEntry, uxPriorityToUse;
;;;3972   	const UBaseType_t uxOnlyOneMutexHeld = ( UBaseType_t ) 1;
;;;3973   
;;;3974   		if( pxMutexHolder != NULL )
000006  2800              CMP      r0,#0
000008  d026              BEQ      |L29.88|
;;;3975   		{
;;;3976   			/* If pxMutexHolder is not NULL then the holder must hold at least
;;;3977   			one mutex. */
;;;3978   			configASSERT( pxTCB->uxMutexesHeld );
;;;3979   
;;;3980   			/* Determine the priority to which the priority of the task that
;;;3981   			holds the mutex should be set.  This will be the greater of the
;;;3982   			holding task's base priority and the priority of the highest
;;;3983   			priority task that is waiting to obtain the mutex. */
;;;3984   			if( pxTCB->uxBasePriority < uxHighestPriorityWaitingTask )
00000a  6c61              LDR      r1,[r4,#0x44]
00000c  4291              CMP      r1,r2
00000e  d200              BCS      |L29.18|
;;;3985   			{
;;;3986   				uxPriorityToUse = uxHighestPriorityWaitingTask;
000010  4611              MOV      r1,r2
                  |L29.18|
;;;3987   			}
;;;3988   			else
;;;3989   			{
;;;3990   				uxPriorityToUse = pxTCB->uxBasePriority;
;;;3991   			}
;;;3992   
;;;3993   			/* Does the priority need to change? */
;;;3994   			if( pxTCB->uxPriority != uxPriorityToUse )
000012  6ae0              LDR      r0,[r4,#0x2c]
000014  4288              CMP      r0,r1
000016  d01f              BEQ      |L29.88|
;;;3995   			{
;;;3996   				/* Only disinherit if no other mutexes are held.  This is a
;;;3997   				simplification in the priority inheritance implementation.  If
;;;3998   				the task that holds the mutex is also holding other mutexes then
;;;3999   				the other mutexes may have caused the priority inheritance. */
;;;4000   				if( pxTCB->uxMutexesHeld == uxOnlyOneMutexHeld )
000018  6ca2              LDR      r2,[r4,#0x48]
00001a  2a01              CMP      r2,#1
00001c  d11c              BNE      |L29.88|
;;;4001   				{
;;;4002   					/* If a task has timed out because it already holds the
;;;4003   					mutex it was trying to obtain then it cannot of inherited
;;;4004   					its own priority. */
;;;4005   					configASSERT( pxTCB != pxCurrentTCB );
;;;4006   
;;;4007   					/* Disinherit the priority, remembering the previous
;;;4008   					priority to facilitate determining the subject task's
;;;4009   					state. */
;;;4010   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;4011   					uxPriorityUsedOnEntry = pxTCB->uxPriority;
;;;4012   					pxTCB->uxPriority = uxPriorityToUse;
00001e  62e1              STR      r1,[r4,#0x2c]
;;;4013   
;;;4014   					/* Only reset the event list item value if the value is not
;;;4015   					being used for anything else. */
;;;4016   					if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000020  69a2              LDR      r2,[r4,#0x18]
000022  2a00              CMP      r2,#0
000024  db02              BLT      |L29.44|
;;;4017   					{
;;;4018   						listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriorityToUse ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000026  220c              MOVS     r2,#0xc
000028  1a51              SUBS     r1,r2,r1
00002a  61a1              STR      r1,[r4,#0x18]
                  |L29.44|
;;;4019   					}
;;;4020   					else
;;;4021   					{
;;;4022   						mtCOVERAGE_TEST_MARKER();
;;;4023   					}
;;;4024   
;;;4025   					/* If the running task is not the task that holds the mutex
;;;4026   					then the task that holds the mutex could be in either the
;;;4027   					Ready, Blocked or Suspended states.  Only remove the task
;;;4028   					from its current state list if it is in the Ready state as
;;;4029   					the task's priority is going to change and there is one
;;;4030   					Ready list per priority. */
;;;4031   					if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00002c  2214              MOVS     r2,#0x14
00002e  4d0b              LDR      r5,|L29.92|
000030  4350              MULS     r0,r2,r0
000032  6961              LDR      r1,[r4,#0x14]
000034  1940              ADDS     r0,r0,r5
000036  4281              CMP      r1,r0
000038  d10e              BNE      |L29.88|
;;;4032   					{
;;;4033   						if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00003a  1d20              ADDS     r0,r4,#4
00003c  f7fffffe          BL       uxListRemove
;;;4034   						{
;;;4035   							taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;4036   						}
;;;4037   						else
;;;4038   						{
;;;4039   							mtCOVERAGE_TEST_MARKER();
;;;4040   						}
;;;4041   
;;;4042   						prvAddTaskToReadyList( pxTCB );
000040  4907              LDR      r1,|L29.96|
000042  6ae0              LDR      r0,[r4,#0x2c]
000044  690a              LDR      r2,[r1,#0x10]  ; uxTopReadyPriority
000046  4290              CMP      r0,r2
000048  d900              BLS      |L29.76|
00004a  6108              STR      r0,[r1,#0x10]  ; uxTopReadyPriority
                  |L29.76|
00004c  2114              MOVS     r1,#0x14
00004e  4348              MULS     r0,r1,r0
000050  1940              ADDS     r0,r0,r5
000052  1d21              ADDS     r1,r4,#4
000054  f7fffffe          BL       vListInsertEnd
                  |L29.88|
;;;4043   					}
;;;4044   					else
;;;4045   					{
;;;4046   						mtCOVERAGE_TEST_MARKER();
;;;4047   					}
;;;4048   				}
;;;4049   				else
;;;4050   				{
;;;4051   					mtCOVERAGE_TEST_MARKER();
;;;4052   				}
;;;4053   			}
;;;4054   			else
;;;4055   			{
;;;4056   				mtCOVERAGE_TEST_MARKER();
;;;4057   			}
;;;4058   		}
;;;4059   		else
;;;4060   		{
;;;4061   			mtCOVERAGE_TEST_MARKER();
;;;4062   		}
;;;4063   	}
000058  bd70              POP      {r4-r6,pc}
;;;4064   
                          ENDP

00005a  0000              DCW      0x0000
                  |L29.92|
                          DCD      NoInit
                  |L29.96|
                          DCD      ||.data||

                          AREA ||i.vTaskPrioritySet||, CODE, READONLY, ALIGN=2

                  vTaskPrioritySet PROC
;;;1465   
;;;1466   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
000000  b5f8              PUSH     {r3-r7,lr}
;;;1467   	{
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1468   	TCB_t *pxTCB;
;;;1469   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1470   	BaseType_t xYieldRequired = pdFALSE;
000006  2600              MOVS     r6,#0
;;;1471   
;;;1472   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
;;;1473   
;;;1474   		/* Ensure the new priority is valid. */
;;;1475   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000008  2d0c              CMP      r5,#0xc
00000a  d300              BCC      |L30.14|
;;;1476   		{
;;;1477   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
00000c  250b              MOVS     r5,#0xb
                  |L30.14|
;;;1478   		}
;;;1479   		else
;;;1480   		{
;;;1481   			mtCOVERAGE_TEST_MARKER();
;;;1482   		}
;;;1483   
;;;1484   		taskENTER_CRITICAL();
00000e  f7fffffe          BL       vPortEnterCritical
;;;1485   		{
;;;1486   			/* If null is passed in here then it is the priority of the calling
;;;1487   			task that is being changed. */
;;;1488   			pxTCB = prvGetTCBFromHandle( xTask );
000012  4f1e              LDR      r7,|L30.140|
000014  2c00              CMP      r4,#0
000016  d100              BNE      |L30.26|
000018  683c              LDR      r4,[r7,#0]  ; pxCurrentTCB
                  |L30.26|
;;;1489   
;;;1490   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1491   
;;;1492   			#if ( configUSE_MUTEXES == 1 )
;;;1493   			{
;;;1494   				uxCurrentBasePriority = pxTCB->uxBasePriority;
00001a  6c60              LDR      r0,[r4,#0x44]
;;;1495   			}
;;;1496   			#else
;;;1497   			{
;;;1498   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1499   			}
;;;1500   			#endif
;;;1501   
;;;1502   			if( uxCurrentBasePriority != uxNewPriority )
00001c  42a8              CMP      r0,r5
00001e  d032              BEQ      |L30.134|
;;;1503   			{
;;;1504   				/* The priority change may have readied a task of higher
;;;1505   				priority than the calling task. */
;;;1506   				if( uxNewPriority > uxCurrentBasePriority )
000020  4285              CMP      r5,r0
000022  d908              BLS      |L30.54|
;;;1507   				{
;;;1508   					if( pxTCB != pxCurrentTCB )
000024  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
000026  428c              CMP      r4,r1
000028  d009              BEQ      |L30.62|
;;;1509   					{
;;;1510   						/* The priority of a task other than the currently
;;;1511   						running task is being raised.  Is the priority being
;;;1512   						raised above that of the running task? */
;;;1513   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
00002a  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
00002c  6ac9              LDR      r1,[r1,#0x2c]
00002e  42a9              CMP      r1,r5
000030  d805              BHI      |L30.62|
;;;1514   						{
;;;1515   							xYieldRequired = pdTRUE;
000032  2601              MOVS     r6,#1
000034  e003              B        |L30.62|
                  |L30.54|
;;;1516   						}
;;;1517   						else
;;;1518   						{
;;;1519   							mtCOVERAGE_TEST_MARKER();
;;;1520   						}
;;;1521   					}
;;;1522   					else
;;;1523   					{
;;;1524   						/* The priority of the running task is being raised,
;;;1525   						but the running task must already be the highest
;;;1526   						priority task able to run so no yield is required. */
;;;1527   					}
;;;1528   				}
;;;1529   				else if( pxTCB == pxCurrentTCB )
000036  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
000038  428c              CMP      r4,r1
00003a  d100              BNE      |L30.62|
;;;1530   				{
;;;1531   					/* Setting the priority of the running task down means
;;;1532   					there may now be another task of higher priority that
;;;1533   					is ready to execute. */
;;;1534   					xYieldRequired = pdTRUE;
00003c  2601              MOVS     r6,#1
                  |L30.62|
;;;1535   				}
;;;1536   				else
;;;1537   				{
;;;1538   					/* Setting the priority of any other task down does not
;;;1539   					require a yield as the running task must be above the
;;;1540   					new priority of the task being modified. */
;;;1541   				}
;;;1542   
;;;1543   				/* Remember the ready list the task might be referenced from
;;;1544   				before its uxPriority member is changed so the
;;;1545   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1546   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
00003e  6ae1              LDR      r1,[r4,#0x2c]
;;;1547   
;;;1548   				#if ( configUSE_MUTEXES == 1 )
;;;1549   				{
;;;1550   					/* Only change the priority being used if the task is not
;;;1551   					currently using an inherited priority. */
;;;1552   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
000040  4288              CMP      r0,r1
000042  d100              BNE      |L30.70|
;;;1553   					{
;;;1554   						pxTCB->uxPriority = uxNewPriority;
000044  62e5              STR      r5,[r4,#0x2c]
                  |L30.70|
;;;1555   					}
;;;1556   					else
;;;1557   					{
;;;1558   						mtCOVERAGE_TEST_MARKER();
;;;1559   					}
;;;1560   
;;;1561   					/* The base priority gets set whatever. */
;;;1562   					pxTCB->uxBasePriority = uxNewPriority;
000046  6465              STR      r5,[r4,#0x44]
;;;1563   				}
;;;1564   				#else
;;;1565   				{
;;;1566   					pxTCB->uxPriority = uxNewPriority;
;;;1567   				}
;;;1568   				#endif
;;;1569   
;;;1570   				/* Only reset the event list item value if the value is not
;;;1571   				being used for anything else. */
;;;1572   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000048  69a0              LDR      r0,[r4,#0x18]
00004a  2800              CMP      r0,#0
00004c  db02              BLT      |L30.84|
;;;1573   				{
;;;1574   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00004e  200c              MOVS     r0,#0xc
000050  1b40              SUBS     r0,r0,r5
000052  61a0              STR      r0,[r4,#0x18]
                  |L30.84|
;;;1575   				}
;;;1576   				else
;;;1577   				{
;;;1578   					mtCOVERAGE_TEST_MARKER();
;;;1579   				}
;;;1580   
;;;1581   				/* If the task is in the blocked or suspended list we need do
;;;1582   				nothing more than change its priority variable. However, if
;;;1583   				the task is in a ready list it needs to be removed and placed
;;;1584   				in the list appropriate to its new priority. */
;;;1585   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000054  2214              MOVS     r2,#0x14
000056  4d0e              LDR      r5,|L30.144|
000058  4351              MULS     r1,r2,r1
00005a  6960              LDR      r0,[r4,#0x14]
00005c  1949              ADDS     r1,r1,r5
00005e  4288              CMP      r0,r1
000060  d10d              BNE      |L30.126|
;;;1586   				{
;;;1587   					/* The task is currently in its ready list - remove before
;;;1588   					adding it to it's new ready list.  As we are in a critical
;;;1589   					section we can do this even if the scheduler is suspended. */
;;;1590   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000062  1d20              ADDS     r0,r4,#4
000064  f7fffffe          BL       uxListRemove
;;;1591   					{
;;;1592   						/* It is known that the task is in its ready list so
;;;1593   						there is no need to check again and the port level
;;;1594   						reset macro can be called directly. */
;;;1595   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
;;;1596   					}
;;;1597   					else
;;;1598   					{
;;;1599   						mtCOVERAGE_TEST_MARKER();
;;;1600   					}
;;;1601   					prvAddTaskToReadyList( pxTCB );
000068  6ae0              LDR      r0,[r4,#0x2c]
00006a  6939              LDR      r1,[r7,#0x10]  ; uxTopReadyPriority
00006c  4288              CMP      r0,r1
00006e  d900              BLS      |L30.114|
000070  6138              STR      r0,[r7,#0x10]  ; uxTopReadyPriority
                  |L30.114|
000072  2114              MOVS     r1,#0x14
000074  4348              MULS     r0,r1,r0
000076  1940              ADDS     r0,r0,r5
000078  1d21              ADDS     r1,r4,#4
00007a  f7fffffe          BL       vListInsertEnd
                  |L30.126|
;;;1602   				}
;;;1603   				else
;;;1604   				{
;;;1605   					mtCOVERAGE_TEST_MARKER();
;;;1606   				}
;;;1607   
;;;1608   				if( xYieldRequired != pdFALSE )
00007e  2e00              CMP      r6,#0
000080  d001              BEQ      |L30.134|
;;;1609   				{
;;;1610   					taskYIELD_IF_USING_PREEMPTION();
000082  f7fffffe          BL       vPortYield
                  |L30.134|
;;;1611   				}
;;;1612   				else
;;;1613   				{
;;;1614   					mtCOVERAGE_TEST_MARKER();
;;;1615   				}
;;;1616   
;;;1617   				/* Remove compiler warning about unused variables when the port
;;;1618   				optimised task selection is not being used. */
;;;1619   				( void ) uxPriorityUsedOnEntry;
;;;1620   			}
;;;1621   		}
;;;1622   		taskEXIT_CRITICAL();
000086  f7fffffe          BL       vPortExitCritical
;;;1623   	}
00008a  bdf8              POP      {r3-r7,pc}
;;;1624   
                          ENDP

                  |L30.140|
                          DCD      ||.data||
                  |L30.144|
                          DCD      NoInit

                          AREA ||i.vTaskRemoveFromUnorderedEventList||, CODE, READONLY, ALIGN=2

                  vTaskRemoveFromUnorderedEventList PROC
;;;3051   
;;;3052   void vTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
000000  b570              PUSH     {r4-r6,lr}
;;;3053   {
;;;3054   TCB_t *pxUnblockedTCB;
;;;3055   
;;;3056   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;3057   	the event flags implementation. */
;;;3058   	configASSERT( uxSchedulerSuspended != pdFALSE );
;;;3059   
;;;3060   	/* Store the new item value in the event list. */
;;;3061   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000002  2201              MOVS     r2,#1
000004  07d2              LSLS     r2,r2,#31
000006  4311              ORRS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;3062   
;;;3063   	/* Remove the event list form the event flag.  Interrupts do not access
;;;3064   	event flags. */
;;;3065   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
00000a  68c4              LDR      r4,[r0,#0xc]
;;;3066   	configASSERT( pxUnblockedTCB );
;;;3067   	( void ) uxListRemove( pxEventListItem );
00000c  f7fffffe          BL       uxListRemove
;;;3068   
;;;3069   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;3070   	scheduler is suspended so interrupts will not be accessing the ready
;;;3071   	lists. */
;;;3072   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       uxListRemove
;;;3073   	prvAddTaskToReadyList( pxUnblockedTCB );
000016  4d0a              LDR      r5,|L31.64|
000018  6ae0              LDR      r0,[r4,#0x2c]
00001a  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
00001c  4288              CMP      r0,r1
00001e  d900              BLS      |L31.34|
000020  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L31.34|
000022  2114              MOVS     r1,#0x14
000024  4348              MULS     r0,r1,r0
000026  4907              LDR      r1,|L31.68|
000028  1840              ADDS     r0,r0,r1
00002a  1d21              ADDS     r1,r4,#4
00002c  f7fffffe          BL       vListInsertEnd
;;;3074   
;;;3075   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000030  6ae0              LDR      r0,[r4,#0x2c]
000032  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000034  6ac9              LDR      r1,[r1,#0x2c]
000036  4288              CMP      r0,r1
000038  d901              BLS      |L31.62|
;;;3076   	{
;;;3077   		/* The unblocked task has a priority above that of the calling task, so
;;;3078   		a context switch is required.  This function is called with the
;;;3079   		scheduler suspended so xYieldPending is set so the context switch
;;;3080   		occurs immediately that the scheduler is resumed (unsuspended). */
;;;3081   		xYieldPending = pdTRUE;
00003a  2001              MOVS     r0,#1
00003c  61e8              STR      r0,[r5,#0x1c]  ; xYieldPending
                  |L31.62|
;;;3082   	}
;;;3083   }
00003e  bd70              POP      {r4-r6,pc}
;;;3084   /*-----------------------------------------------------------*/
                          ENDP

                  |L31.64|
                          DCD      ||.data||
                  |L31.68|
                          DCD      NoInit

                          AREA ||i.vTaskResume||, CODE, READONLY, ALIGN=2

                  vTaskResume PROC
;;;1776   
;;;1777   	void vTaskResume( TaskHandle_t xTaskToResume )
000000  b570              PUSH     {r4-r6,lr}
;;;1778   	{
000002  4604              MOV      r4,r0
;;;1779   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
;;;1780   
;;;1781   		/* It does not make sense to resume the calling task. */
;;;1782   		configASSERT( xTaskToResume );
;;;1783   
;;;1784   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1785   		currently executing task. */
;;;1786   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000004  2c00              CMP      r4,#0
000006  d022              BEQ      |L32.78|
000008  4d11              LDR      r5,|L32.80|
00000a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00000c  4284              CMP      r4,r0
00000e  d01e              BEQ      |L32.78|
;;;1787   		{
;;;1788   			taskENTER_CRITICAL();
000010  f7fffffe          BL       vPortEnterCritical
;;;1789   			{
;;;1790   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       prvTaskIsTaskSuspended
00001a  2800              CMP      r0,#0
00001c  d015              BEQ      |L32.74|
;;;1791   				{
;;;1792   					traceTASK_RESUME( pxTCB );
;;;1793   
;;;1794   					/* The ready list can be accessed even if the scheduler is
;;;1795   					suspended because this is inside a critical section. */
;;;1796   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
00001e  1d20              ADDS     r0,r4,#4
000020  f7fffffe          BL       uxListRemove
;;;1797   					prvAddTaskToReadyList( pxTCB );
000024  6ae0              LDR      r0,[r4,#0x2c]
000026  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000028  4288              CMP      r0,r1
00002a  d900              BLS      |L32.46|
00002c  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L32.46|
00002e  2114              MOVS     r1,#0x14
000030  4348              MULS     r0,r1,r0
000032  4908              LDR      r1,|L32.84|
000034  1840              ADDS     r0,r0,r1
000036  1d21              ADDS     r1,r4,#4
000038  f7fffffe          BL       vListInsertEnd
;;;1798   
;;;1799   					/* A higher priority task may have just been resumed. */
;;;1800   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00003c  6ae0              LDR      r0,[r4,#0x2c]
00003e  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000040  6ac9              LDR      r1,[r1,#0x2c]
000042  4288              CMP      r0,r1
000044  d301              BCC      |L32.74|
;;;1801   					{
;;;1802   						/* This yield may not cause the task just resumed to run,
;;;1803   						but will leave the lists in the correct state for the
;;;1804   						next yield. */
;;;1805   						taskYIELD_IF_USING_PREEMPTION();
000046  f7fffffe          BL       vPortYield
                  |L32.74|
;;;1806   					}
;;;1807   					else
;;;1808   					{
;;;1809   						mtCOVERAGE_TEST_MARKER();
;;;1810   					}
;;;1811   				}
;;;1812   				else
;;;1813   				{
;;;1814   					mtCOVERAGE_TEST_MARKER();
;;;1815   				}
;;;1816   			}
;;;1817   			taskEXIT_CRITICAL();
00004a  f7fffffe          BL       vPortExitCritical
                  |L32.78|
;;;1818   		}
;;;1819   		else
;;;1820   		{
;;;1821   			mtCOVERAGE_TEST_MARKER();
;;;1822   		}
;;;1823   	}
00004e  bd70              POP      {r4-r6,pc}
;;;1824   
                          ENDP

                  |L32.80|
                          DCD      ||.data||
                  |L32.84|
                          DCD      NoInit

                          AREA ||i.vTaskSetTimeOutState||, CODE, READONLY, ALIGN=2

                  vTaskSetTimeOutState PROC
;;;3085   
;;;3086   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000000  b510              PUSH     {r4,lr}
;;;3087   {
000002  4604              MOV      r4,r0
;;;3088   	configASSERT( pxTimeOut );
;;;3089   	taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;3090   	{
;;;3091   		pxTimeOut->xOverflowCount = xNumOfOverflows;
000008  4803              LDR      r0,|L33.24|
00000a  6a01              LDR      r1,[r0,#0x20]  ; xNumOfOverflows
00000c  6021              STR      r1,[r4,#0]
;;;3092   		pxTimeOut->xTimeOnEntering = xTickCount;
00000e  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
000010  6060              STR      r0,[r4,#4]
;;;3093   	}
;;;3094   	taskEXIT_CRITICAL();
000012  f7fffffe          BL       vPortExitCritical
;;;3095   }
000016  bd10              POP      {r4,pc}
;;;3096   /*-----------------------------------------------------------*/
                          ENDP

                  |L33.24|
                          DCD      ||.data||

                          AREA ||i.vTaskStartScheduler||, CODE, READONLY, ALIGN=2

                  vTaskStartScheduler PROC
;;;1900   
;;;1901   void vTaskStartScheduler( void )
000000  b510              PUSH     {r4,lr}
;;;1902   {
000002  b086              SUB      sp,sp,#0x18
;;;1903   BaseType_t xReturn;
;;;1904   
;;;1905   	/* Add the idle task at the lowest priority. */
;;;1906   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1907   	{
;;;1908   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
000004  2400              MOVS     r4,#0
000006  9405              STR      r4,[sp,#0x14]
;;;1909   		StackType_t *pxIdleTaskStackBuffer = NULL;
000008  9404              STR      r4,[sp,#0x10]
;;;1910   		uint32_t ulIdleTaskStackSize;
;;;1911   
;;;1912   		/* The Idle task is created using user provided RAM - obtain the
;;;1913   		address of the RAM then create the idle task. */
;;;1914   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
00000a  aa03              ADD      r2,sp,#0xc
00000c  a904              ADD      r1,sp,#0x10
00000e  a805              ADD      r0,sp,#0x14
000010  f7fffffe          BL       vApplicationGetIdleTaskMemory
;;;1915   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
000014  9805              LDR      r0,[sp,#0x14]
000016  9904              LDR      r1,[sp,#0x10]
000018  9101              STR      r1,[sp,#4]
00001a  9002              STR      r0,[sp,#8]
00001c  2300              MOVS     r3,#0
00001e  9400              STR      r4,[sp,#0]
000020  a10c              ADR      r1,|L34.84|
000022  480e              LDR      r0,|L34.92|
000024  9a03              LDR      r2,[sp,#0xc]
000026  f7fffffe          BL       xTaskCreateStatic
00002a  490d              LDR      r1,|L34.96|
00002c  62c8              STR      r0,[r1,#0x2c]  ; xIdleTaskHandle
;;;1916   												configIDLE_TASK_NAME,
;;;1917   												ulIdleTaskStackSize,
;;;1918   												( void * ) NULL, /*lint !e961.  The cast is not redundant for all compilers. */
;;;1919   												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1920   												pxIdleTaskStackBuffer,
;;;1921   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1922   
;;;1923   		if( xIdleTaskHandle != NULL )
00002e  2800              CMP      r0,#0
000030  d001              BEQ      |L34.54|
;;;1924   		{
;;;1925   			xReturn = pdPASS;
000032  2001              MOVS     r0,#1
000034  e000              B        |L34.56|
                  |L34.54|
;;;1926   		}
;;;1927   		else
;;;1928   		{
;;;1929   			xReturn = pdFAIL;
000036  2000              MOVS     r0,#0
                  |L34.56|
;;;1930   		}
;;;1931   	}
;;;1932   	#else
;;;1933   	{
;;;1934   		/* The Idle task is being created using dynamically allocated RAM. */
;;;1935   		xReturn = xTaskCreate(	prvIdleTask,
;;;1936   								configIDLE_TASK_NAME,
;;;1937   								configMINIMAL_STACK_SIZE,
;;;1938   								( void * ) NULL,
;;;1939   								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1940   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1941   	}
;;;1942   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;1943   
;;;1944   	#if ( configUSE_TIMERS == 1 )
;;;1945   	{
;;;1946   		if( xReturn == pdPASS )
;;;1947   		{
;;;1948   			xReturn = xTimerCreateTimerTask();
;;;1949   		}
;;;1950   		else
;;;1951   		{
;;;1952   			mtCOVERAGE_TEST_MARKER();
;;;1953   		}
;;;1954   	}
;;;1955   	#endif /* configUSE_TIMERS */
;;;1956   
;;;1957   	if( xReturn == pdPASS )
000038  2801              CMP      r0,#1
00003a  d108              BNE      |L34.78|
;;;1958   	{
;;;1959   		/* freertos_tasks_c_additions_init() should only be called if the user
;;;1960   		definable macro FREERTOS_TASKS_C_ADDITIONS_INIT() is defined, as that is
;;;1961   		the only macro called by the function. */
;;;1962   		#ifdef FREERTOS_TASKS_C_ADDITIONS_INIT
;;;1963   		{
;;;1964   			freertos_tasks_c_additions_init();
;;;1965   		}
;;;1966   		#endif
;;;1967   
;;;1968   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1969   		before or during the call to xPortStartScheduler().  The stacks of
;;;1970   		the created tasks contain a status word with interrupts switched on
;;;1971   		so interrupts will automatically get re-enabled when the first task
;;;1972   		starts to run. */
;;;1973   		portDISABLE_INTERRUPTS();
00003c  b672              CPSID    i
;;;1974   
;;;1975   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1976   		{
;;;1977   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1978   			structure specific to the task that will run first. */
;;;1979   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1980   		}
;;;1981   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1982   
;;;1983   		xNextTaskUnblockTime = portMAX_DELAY;
00003e  2000              MOVS     r0,#0
000040  43c0              MVNS     r0,r0
000042  6288              STR      r0,[r1,#0x28]  ; xNextTaskUnblockTime
;;;1984   		xSchedulerRunning = pdTRUE;
000044  2001              MOVS     r0,#1
000046  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;1985   		xTickCount = ( TickType_t ) 0U;
000048  60cc              STR      r4,[r1,#0xc]  ; xTickCount
;;;1986   
;;;1987   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1988   		macro must be defined to configure the timer/counter used to generate
;;;1989   		the run time counter time base.   NOTE:  If configGENERATE_RUN_TIME_STATS
;;;1990   		is set to 0 and the following line fails to build then ensure you do not
;;;1991   		have portCONFIGURE_TIMER_FOR_RUN_TIME_STATS() defined in your
;;;1992   		FreeRTOSConfig.h file. */
;;;1993   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1994   
;;;1995   		/* Setting up the timer tick is hardware specific and thus in the
;;;1996   		portable interface. */
;;;1997   		if( xPortStartScheduler() != pdFALSE )
00004a  f7fffffe          BL       xPortStartScheduler
                  |L34.78|
;;;1998   		{
;;;1999   			/* Should not reach here as if the scheduler is running the
;;;2000   			function will not return. */
;;;2001   		}
;;;2002   		else
;;;2003   		{
;;;2004   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;2005   		}
;;;2006   	}
;;;2007   	else
;;;2008   	{
;;;2009   		/* This line will only be reached if the kernel could not be started,
;;;2010   		because there was not enough FreeRTOS heap to create the idle task
;;;2011   		or the timer task. */
;;;2012   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
;;;2013   	}
;;;2014   
;;;2015   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;2016   	meaning xIdleTaskHandle is not used anywhere else. */
;;;2017   	( void ) xIdleTaskHandle;
;;;2018   }
00004e  b006              ADD      sp,sp,#0x18
000050  bd10              POP      {r4,pc}
;;;2019   /*-----------------------------------------------------------*/
                          ENDP

000052  0000              DCW      0x0000
                  |L34.84|
000054  49444c45          DCB      "IDLE",0
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L34.92|
                          DCD      prvIdleTask
                  |L34.96|
                          DCD      ||.data||

                          AREA ||i.vTaskSuspend||, CODE, READONLY, ALIGN=2

                  vTaskSuspend PROC
;;;1629   
;;;1630   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000000  b570              PUSH     {r4-r6,lr}
;;;1631   	{
000002  4604              MOV      r4,r0
;;;1632   	TCB_t *pxTCB;
;;;1633   
;;;1634   		taskENTER_CRITICAL();
000004  f7fffffe          BL       vPortEnterCritical
;;;1635   		{
;;;1636   			/* If null is passed in here then it is the running task that is
;;;1637   			being suspended. */
;;;1638   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
000008  4d1b              LDR      r5,|L35.120|
00000a  2c00              CMP      r4,#0
00000c  d100              BNE      |L35.16|
00000e  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L35.16|
;;;1639   
;;;1640   			traceTASK_SUSPEND( pxTCB );
;;;1641   
;;;1642   			/* Remove task from the ready/delayed list and place in the
;;;1643   			suspended list. */
;;;1644   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000010  1d20              ADDS     r0,r4,#4
000012  f7fffffe          BL       uxListRemove
;;;1645   			{
;;;1646   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;1647   			}
;;;1648   			else
;;;1649   			{
;;;1650   				mtCOVERAGE_TEST_MARKER();
;;;1651   			}
;;;1652   
;;;1653   			/* Is the task waiting on an event also? */
;;;1654   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000016  6aa0              LDR      r0,[r4,#0x28]
000018  2800              CMP      r0,#0
00001a  d003              BEQ      |L35.36|
;;;1655   			{
;;;1656   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
00001c  4620              MOV      r0,r4
00001e  3018              ADDS     r0,r0,#0x18
000020  f7fffffe          BL       uxListRemove
                  |L35.36|
;;;1657   			}
;;;1658   			else
;;;1659   			{
;;;1660   				mtCOVERAGE_TEST_MARKER();
;;;1661   			}
;;;1662   
;;;1663   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000024  1d21              ADDS     r1,r4,#4
000026  4815              LDR      r0,|L35.124|
000028  f7fffffe          BL       vListInsertEnd
;;;1664   
;;;1665   			#if( configUSE_TASK_NOTIFICATIONS == 1 )
;;;1666   			{
;;;1667   				if( pxTCB->ucNotifyState == taskWAITING_NOTIFICATION )
00002c  4620              MOV      r0,r4
00002e  3040              ADDS     r0,r0,#0x40
000030  7c01              LDRB     r1,[r0,#0x10]
000032  2600              MOVS     r6,#0
000034  2901              CMP      r1,#1
000036  d100              BNE      |L35.58|
;;;1668   				{
;;;1669   					/* The task was blocked to wait for a notification, but is
;;;1670   					now suspended, so no notification was received. */
;;;1671   					pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000038  7406              STRB     r6,[r0,#0x10]
                  |L35.58|
;;;1672   				}
;;;1673   			}
;;;1674   			#endif
;;;1675   		}
;;;1676   		taskEXIT_CRITICAL();
00003a  f7fffffe          BL       vPortExitCritical
;;;1677   
;;;1678   		if( xSchedulerRunning != pdFALSE )
00003e  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000040  2800              CMP      r0,#0
000042  d005              BEQ      |L35.80|
;;;1679   		{
;;;1680   			/* Reset the next expected unblock time in case it referred to the
;;;1681   			task that is now in the Suspended state. */
;;;1682   			taskENTER_CRITICAL();
000044  f7fffffe          BL       vPortEnterCritical
;;;1683   			{
;;;1684   				prvResetNextTaskUnblockTime();
000048  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1685   			}
;;;1686   			taskEXIT_CRITICAL();
00004c  f7fffffe          BL       vPortExitCritical
                  |L35.80|
;;;1687   		}
;;;1688   		else
;;;1689   		{
;;;1690   			mtCOVERAGE_TEST_MARKER();
;;;1691   		}
;;;1692   
;;;1693   		if( pxTCB == pxCurrentTCB )
000050  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000052  4284              CMP      r4,r0
000054  d104              BNE      |L35.96|
;;;1694   		{
;;;1695   			if( xSchedulerRunning != pdFALSE )
000056  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000058  2800              CMP      r0,#0
00005a  d002              BEQ      |L35.98|
;;;1696   			{
;;;1697   				/* The current task has just been suspended. */
;;;1698   				configASSERT( uxSchedulerSuspended == 0 );
;;;1699   				portYIELD_WITHIN_API();
00005c  f7fffffe          BL       vPortYield
                  |L35.96|
;;;1700   			}
;;;1701   			else
;;;1702   			{
;;;1703   				/* The scheduler is not running, but the task that was pointed
;;;1704   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1705   				must be adjusted to point to a different task. */
;;;1706   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
;;;1707   				{
;;;1708   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1709   					NULL so when the next task is created pxCurrentTCB will
;;;1710   					be set to point to it no matter what its relative priority
;;;1711   					is. */
;;;1712   					pxCurrentTCB = NULL;
;;;1713   				}
;;;1714   				else
;;;1715   				{
;;;1716   					vTaskSwitchContext();
;;;1717   				}
;;;1718   			}
;;;1719   		}
;;;1720   		else
;;;1721   		{
;;;1722   			mtCOVERAGE_TEST_MARKER();
;;;1723   		}
;;;1724   	}
000060  bd70              POP      {r4-r6,pc}
                  |L35.98|
000062  4806              LDR      r0,|L35.124|
000064  6800              LDR      r0,[r0,#0]            ;1706  ; xSuspendedTaskList
000066  68a9              LDR      r1,[r5,#8]            ;1706  ; uxCurrentNumberOfTasks
000068  4288              CMP      r0,r1                 ;1706
00006a  d101              BNE      |L35.112|
00006c  602e              STR      r6,[r5,#0]            ;1712  ; pxCurrentTCB
00006e  bd70              POP      {r4-r6,pc}
                  |L35.112|
000070  f7fffffe          BL       vTaskSwitchContext
000074  bd70              POP      {r4-r6,pc}
;;;1725   
                          ENDP

000076  0000              DCW      0x0000
                  |L35.120|
                          DCD      ||.data||
                  |L35.124|
                          DCD      NoInit+0x140

                          AREA ||i.vTaskSuspendAll||, CODE, READONLY, ALIGN=2

                  vTaskSuspendAll PROC
;;;2031   
;;;2032   void vTaskSuspendAll( void )
000000  4802              LDR      r0,|L36.12|
;;;2033   {
;;;2034   	/* A critical section is not required as the variable is of type
;;;2035   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;2036   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;2037   	http://goo.gl/wu4acr */
;;;2038   	++uxSchedulerSuspended;
000002  6b01              LDR      r1,[r0,#0x30]  ; uxSchedulerSuspended
000004  1c49              ADDS     r1,r1,#1
000006  6301              STR      r1,[r0,#0x30]  ; uxSchedulerSuspended
;;;2039   }
000008  4770              BX       lr
;;;2040   /*----------------------------------------------------------*/
                          ENDP

00000a  0000              DCW      0x0000
                  |L36.12|
                          DCD      ||.data||

                          AREA ||i.vTaskSwitchContext||, CODE, READONLY, ALIGN=2

                  vTaskSwitchContext PROC
;;;2850   
;;;2851   void vTaskSwitchContext( void )
000000  b510              PUSH     {r4,lr}
;;;2852   {
;;;2853   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
000002  4b11              LDR      r3,|L37.72|
000004  6b18              LDR      r0,[r3,#0x30]  ; uxSchedulerSuspended
000006  2800              CMP      r0,#0
000008  d002              BEQ      |L37.16|
;;;2854   	{
;;;2855   		/* The scheduler is currently suspended - do not allow a context
;;;2856   		switch. */
;;;2857   		xYieldPending = pdTRUE;
00000a  2001              MOVS     r0,#1
00000c  61d8              STR      r0,[r3,#0x1c]  ; xYieldPending
;;;2858   	}
;;;2859   	else
;;;2860   	{
;;;2861   		xYieldPending = pdFALSE;
;;;2862   		traceTASK_SWITCHED_OUT();
;;;2863   
;;;2864   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2865   		{
;;;2866   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2867   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2868   				#else
;;;2869   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2870   				#endif
;;;2871   
;;;2872   				/* Add the amount of time the task has been running to the
;;;2873   				accumulated time so far.  The time the task started running was
;;;2874   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2875   				protection here so count values are only valid until the timer
;;;2876   				overflows.  The guard against negative values is to protect
;;;2877   				against suspect run time stat counter implementations - which
;;;2878   				are provided by the application, not the kernel. */
;;;2879   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2880   				{
;;;2881   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2882   				}
;;;2883   				else
;;;2884   				{
;;;2885   					mtCOVERAGE_TEST_MARKER();
;;;2886   				}
;;;2887   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2888   		}
;;;2889   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2890   
;;;2891   		/* Check for stack overflow, if configured. */
;;;2892   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2893   
;;;2894   		/* Select a new task to run using either the generic C or port
;;;2895   		optimised asm code. */
;;;2896   		taskSELECT_HIGHEST_PRIORITY_TASK();
;;;2897   		traceTASK_SWITCHED_IN();
;;;2898   
;;;2899   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2900   		{
;;;2901   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2902   			structure specific to this task. */
;;;2903   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2904   		}
;;;2905   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2906   	}
;;;2907   }
00000e  bd10              POP      {r4,pc}
                  |L37.16|
000010  2000              MOVS     r0,#0                 ;2861
000012  61d8              STR      r0,[r3,#0x1c]         ;2861  ; xYieldPending
000014  6918              LDR      r0,[r3,#0x10]         ;2896  ; uxTopReadyPriority
000016  490d              LDR      r1,|L37.76|
000018  e000              B        |L37.28|
                  |L37.26|
00001a  1e40              SUBS     r0,r0,#1              ;2896
                  |L37.28|
00001c  2214              MOVS     r2,#0x14              ;2896
00001e  4342              MULS     r2,r0,r2              ;2896
000020  588a              LDR      r2,[r1,r2]            ;2896
000022  2a00              CMP      r2,#0                 ;2896
000024  d0f9              BEQ      |L37.26|
000026  2214              MOVS     r2,#0x14              ;2896
000028  4342              MULS     r2,r0,r2              ;2896
00002a  1851              ADDS     r1,r2,r1              ;2896
00002c  684a              LDR      r2,[r1,#4]            ;2896
00002e  6852              LDR      r2,[r2,#4]            ;2896
000030  604a              STR      r2,[r1,#4]            ;2896
000032  460c              MOV      r4,r1                 ;2896
000034  3408              ADDS     r4,r4,#8              ;2896
000036  42a2              CMP      r2,r4                 ;2896
000038  d101              BNE      |L37.62|
00003a  6852              LDR      r2,[r2,#4]            ;2896
00003c  604a              STR      r2,[r1,#4]            ;2896
                  |L37.62|
00003e  6849              LDR      r1,[r1,#4]            ;2896
000040  68c9              LDR      r1,[r1,#0xc]          ;2896
000042  6019              STR      r1,[r3,#0]            ;2896  ; pxCurrentTCB
000044  6118              STR      r0,[r3,#0x10]         ;2896  ; uxTopReadyPriority
000046  bd10              POP      {r4,pc}
;;;2908   /*-----------------------------------------------------------*/
                          ENDP

                  |L37.72|
                          DCD      ||.data||
                  |L37.76|
                          DCD      NoInit

                          AREA ||i.xTaskCheckForTimeOut||, CODE, READONLY, ALIGN=2

                  xTaskCheckForTimeOut PROC
;;;3105   
;;;3106   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000000  b5f8              PUSH     {r3-r7,lr}
;;;3107   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;3108   BaseType_t xReturn;
;;;3109   
;;;3110   	configASSERT( pxTimeOut );
;;;3111   	configASSERT( pxTicksToWait );
;;;3112   
;;;3113   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;3114   	{
;;;3115   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3116   		const TickType_t xConstTickCount = xTickCount;
00000a  4e10              LDR      r6,|L38.76|
00000c  68f2              LDR      r2,[r6,#0xc]  ; xTickCount
;;;3117   		const TickType_t xElapsedTime = xConstTickCount - pxTimeOut->xTimeOnEntering;
00000e  686b              LDR      r3,[r5,#4]
000010  1ad0              SUBS     r0,r2,r3
;;;3118   
;;;3119   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3120   			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
;;;3121   			{
;;;3122   				/* The delay was aborted, which is not the same as a time out,
;;;3123   				but has the same result. */
;;;3124   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3125   				xReturn = pdTRUE;
;;;3126   			}
;;;3127   			else
;;;3128   		#endif
;;;3129   
;;;3130   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3131   			if( *pxTicksToWait == portMAX_DELAY )
000012  6821              LDR      r1,[r4,#0]
000014  1c4f              ADDS     r7,r1,#1
000016  d007              BEQ      |L38.40|
;;;3132   			{
;;;3133   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3134   				specified is the maximum block time then the task should block
;;;3135   				indefinitely, and therefore never time out. */
;;;3136   				xReturn = pdFALSE;
;;;3137   			}
;;;3138   			else
;;;3139   		#endif
;;;3140   
;;;3141   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000018  682f              LDR      r7,[r5,#0]
00001a  6a36              LDR      r6,[r6,#0x20]  ; xNumOfOverflows
00001c  42b7              CMP      r7,r6
00001e  d005              BEQ      |L38.44|
000020  4293              CMP      r3,r2
000022  d803              BHI      |L38.44|
;;;3142   		{
;;;3143   			/* The tick count is greater than the time at which
;;;3144   			vTaskSetTimeout() was called, but has also overflowed since
;;;3145   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3146   			around and gone past again. This passed since vTaskSetTimeout()
;;;3147   			was called. */
;;;3148   			xReturn = pdTRUE;
000024  2401              MOVS     r4,#1
000026  e00d              B        |L38.68|
                  |L38.40|
000028  2400              MOVS     r4,#0                 ;3136
00002a  e00b              B        |L38.68|
                  |L38.44|
;;;3149   		}
;;;3150   		else if( xElapsedTime < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
00002c  4281              CMP      r1,r0
00002e  d906              BLS      |L38.62|
;;;3151   		{
;;;3152   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3153   			*pxTicksToWait -= xElapsedTime;
000030  1a08              SUBS     r0,r1,r0
000032  6020              STR      r0,[r4,#0]
;;;3154   			vTaskInternalSetTimeOutState( pxTimeOut );
000034  4628              MOV      r0,r5
000036  f7fffffe          BL       vTaskInternalSetTimeOutState
;;;3155   			xReturn = pdFALSE;
00003a  2400              MOVS     r4,#0
00003c  e002              B        |L38.68|
                  |L38.62|
;;;3156   		}
;;;3157   		else
;;;3158   		{
;;;3159   			*pxTicksToWait = 0;
00003e  2000              MOVS     r0,#0
000040  6020              STR      r0,[r4,#0]
;;;3160   			xReturn = pdTRUE;
000042  2401              MOVS     r4,#1
                  |L38.68|
;;;3161   		}
;;;3162   	}
;;;3163   	taskEXIT_CRITICAL();
000044  f7fffffe          BL       vPortExitCritical
;;;3164   
;;;3165   	return xReturn;
000048  4620              MOV      r0,r4
;;;3166   }
00004a  bdf8              POP      {r3-r7,pc}
;;;3167   /*-----------------------------------------------------------*/
                          ENDP

                  |L38.76|
                          DCD      ||.data||

                          AREA ||i.xTaskCreate||, CODE, READONLY, ALIGN=1

                  xTaskCreate PROC
;;;731    
;;;732    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
000000  b5ff              PUSH     {r0-r7,lr}
;;;733    							const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;734    							const configSTACK_DEPTH_TYPE usStackDepth,
;;;735    							void * const pvParameters,
;;;736    							UBaseType_t uxPriority,
;;;737    							TaskHandle_t * const pxCreatedTask )
;;;738    	{
000002  b085              SUB      sp,sp,#0x14
000004  9f0e              LDR      r7,[sp,#0x38]
000006  4616              MOV      r6,r2
;;;739    	TCB_t *pxNewTCB;
;;;740    	BaseType_t xReturn;
;;;741    
;;;742    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;743    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;744    		the TCB then the stack. */
;;;745    		#if( portSTACK_GROWTH > 0 )
;;;746    		{
;;;747    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;748    			the implementation of the port malloc function and whether or not static
;;;749    			allocation is being used. */
;;;750    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;751    
;;;752    			if( pxNewTCB != NULL )
;;;753    			{
;;;754    				/* Allocate space for the stack used by the task being created.
;;;755    				The base of the stack memory stored in the TCB so the task can
;;;756    				be deleted later if required. */
;;;757    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;758    
;;;759    				if( pxNewTCB->pxStack == NULL )
;;;760    				{
;;;761    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;762    					vPortFree( pxNewTCB );
;;;763    					pxNewTCB = NULL;
;;;764    				}
;;;765    			}
;;;766    		}
;;;767    		#else /* portSTACK_GROWTH */
;;;768    		{
;;;769    		StackType_t *pxStack;
;;;770    
;;;771    			/* Allocate space for the stack used by the task being created. */
;;;772    			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000008  00b0              LSLS     r0,r6,#2
00000a  f7fffffe          BL       pvPortMalloc
00000e  4605              MOV      r5,r0
;;;773    
;;;774    			if( pxStack != NULL )
000010  0028              MOVS     r0,r5
000012  d00b              BEQ      |L39.44|
;;;775    			{
;;;776    				/* Allocate space for the TCB. */
;;;777    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
000014  2054              MOVS     r0,#0x54
000016  f7fffffe          BL       pvPortMalloc
00001a  4604              MOV      r4,r0
;;;778    
;;;779    				if( pxNewTCB != NULL )
00001c  2c00              CMP      r4,#0
00001e  d001              BEQ      |L39.36|
;;;780    				{
;;;781    					/* Store the stack location in the TCB. */
;;;782    					pxNewTCB->pxStack = pxStack;
000020  6325              STR      r5,[r4,#0x30]
000022  e004              B        |L39.46|
                  |L39.36|
;;;783    				}
;;;784    				else
;;;785    				{
;;;786    					/* The stack cannot be used as the TCB was not created.  Free
;;;787    					it again. */
;;;788    					vPortFree( pxStack );
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       vPortFree
00002a  e000              B        |L39.46|
                  |L39.44|
;;;789    				}
;;;790    			}
;;;791    			else
;;;792    			{
;;;793    				pxNewTCB = NULL;
00002c  2400              MOVS     r4,#0
                  |L39.46|
;;;794    			}
;;;795    		}
;;;796    		#endif /* portSTACK_GROWTH */
;;;797    
;;;798    		if( pxNewTCB != NULL )
00002e  2c00              CMP      r4,#0
000030  d013              BEQ      |L39.90|
;;;799    		{
;;;800    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
;;;801    			{
;;;802    				/* Tasks can be created statically or dynamically, so note this
;;;803    				task was created dynamically in case it is later deleted. */
;;;804    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
000032  2000              MOVS     r0,#0
000034  2151              MOVS     r1,#0x51
000036  5508              STRB     r0,[r1,r4]
;;;805    			}
;;;806    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;807    
;;;808    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
000038  990f              LDR      r1,[sp,#0x3c]
00003a  9003              STR      r0,[sp,#0xc]
00003c  9700              STR      r7,[sp,#0]
00003e  9101              STR      r1,[sp,#4]
000040  9402              STR      r4,[sp,#8]
000042  4632              MOV      r2,r6
000044  9b08              LDR      r3,[sp,#0x20]
000046  9906              LDR      r1,[sp,#0x18]
000048  9805              LDR      r0,[sp,#0x14]
00004a  f7fffffe          BL       prvInitialiseNewTask
;;;809    			prvAddNewTaskToReadyList( pxNewTCB );
00004e  4620              MOV      r0,r4
000050  f7fffffe          BL       prvAddNewTaskToReadyList
;;;810    			xReturn = pdPASS;
000054  2001              MOVS     r0,#1
                  |L39.86|
;;;811    		}
;;;812    		else
;;;813    		{
;;;814    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
;;;815    		}
;;;816    
;;;817    		return xReturn;
;;;818    	}
000056  b009              ADD      sp,sp,#0x24
000058  bdf0              POP      {r4-r7,pc}
                  |L39.90|
00005a  2000              MOVS     r0,#0                 ;814
00005c  43c0              MVNS     r0,r0                 ;814
00005e  e7fa              B        |L39.86|
;;;819    
                          ENDP


                          AREA ||i.xTaskCreateStatic||, CODE, READONLY, ALIGN=1

                  xTaskCreateStatic PROC
;;;580    
;;;581    	TaskHandle_t xTaskCreateStatic(	TaskFunction_t pxTaskCode,
000000  b5f0              PUSH     {r4-r7,lr}
;;;582    									const char * const pcName,		/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;583    									const uint32_t ulStackDepth,
;;;584    									void * const pvParameters,
;;;585    									UBaseType_t uxPriority,
;;;586    									StackType_t * const puxStackBuffer,
;;;587    									StaticTask_t * const pxTaskBuffer )
;;;588    	{
000002  b085              SUB      sp,sp,#0x14
000004  9f0a              LDR      r7,[sp,#0x28]
000006  9d0b              LDR      r5,[sp,#0x2c]
000008  9c0c              LDR      r4,[sp,#0x30]
00000a  4684              MOV      r12,r0
;;;589    	TCB_t *pxNewTCB;
;;;590    	TaskHandle_t xReturn;
;;;591    
;;;592    		configASSERT( puxStackBuffer != NULL );
;;;593    		configASSERT( pxTaskBuffer != NULL );
;;;594    
;;;595    		#if( configASSERT_DEFINED == 1 )
;;;596    		{
;;;597    			/* Sanity check that the size of the structure used to declare a
;;;598    			variable of type StaticTask_t equals the size of the real task
;;;599    			structure. */
;;;600    			volatile size_t xSize = sizeof( StaticTask_t );
;;;601    			configASSERT( xSize == sizeof( TCB_t ) );
;;;602    		}
;;;603    		#endif /* configASSERT_DEFINED */
;;;604    
;;;605    
;;;606    		if( ( pxTaskBuffer != NULL ) && ( puxStackBuffer != NULL ) )
00000c  2600              MOVS     r6,#0
00000e  2c00              CMP      r4,#0
000010  d010              BEQ      |L40.52|
000012  2d00              CMP      r5,#0
000014  d00e              BEQ      |L40.52|
;;;607    		{
;;;608    			/* The memory used for the task's TCB and stack are passed into this
;;;609    			function - use them. */
;;;610    			pxNewTCB = ( TCB_t * ) pxTaskBuffer; /*lint !e740 Unusual cast is ok as the structures are designed to have the same alignment, and the size is checked by an assert. */
;;;611    			pxNewTCB->pxStack = ( StackType_t * ) puxStackBuffer;
000016  6325              STR      r5,[r4,#0x30]
;;;612    
;;;613    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 ) /*lint !e731 Macro has been consolidated for readability reasons. */
;;;614    			{
;;;615    				/* Tasks can be created statically or dynamically, so note this
;;;616    				task was created statically in case the task is later deleted. */
;;;617    				pxNewTCB->ucStaticallyAllocated = tskSTATICALLY_ALLOCATED_STACK_AND_TCB;
000018  2502              MOVS     r5,#2
00001a  2051              MOVS     r0,#0x51
00001c  5505              STRB     r5,[r0,r4]
;;;618    			}
;;;619    			#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;620    
;;;621    			prvInitialiseNewTask( pxTaskCode, pcName, ulStackDepth, pvParameters, uxPriority, &xReturn, pxNewTCB, NULL );
00001e  a804              ADD      r0,sp,#0x10
000020  9700              STR      r7,[sp,#0]
000022  ad01              ADD      r5,sp,#4
000024  c551              STM      r5!,{r0,r4,r6}
000026  4660              MOV      r0,r12
000028  f7fffffe          BL       prvInitialiseNewTask
;;;622    			prvAddNewTaskToReadyList( pxNewTCB );
00002c  4620              MOV      r0,r4
00002e  f7fffffe          BL       prvAddNewTaskToReadyList
000032  e000              B        |L40.54|
                  |L40.52|
;;;623    		}
;;;624    		else
;;;625    		{
;;;626    			xReturn = NULL;
000034  9604              STR      r6,[sp,#0x10]
                  |L40.54|
;;;627    		}
;;;628    
;;;629    		return xReturn;
000036  9804              LDR      r0,[sp,#0x10]
;;;630    	}
000038  b005              ADD      sp,sp,#0x14
00003a  bdf0              POP      {r4-r7,pc}
;;;631    
                          ENDP


                          AREA ||i.xTaskGenericNotify||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotify PROC
;;;4562   
;;;4563   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000000  b5ff              PUSH     {r0-r7,lr}
;;;4564   	{
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  461f              MOV      r7,r3
;;;4565   	TCB_t * pxTCB;
;;;4566   	BaseType_t xReturn = pdPASS;
00000a  2601              MOVS     r6,#1
;;;4567   	uint8_t ucOriginalNotifyState;
;;;4568   
;;;4569   		configASSERT( xTaskToNotify );
;;;4570   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4571   
;;;4572   		taskENTER_CRITICAL();
00000c  f7fffffe          BL       vPortEnterCritical
;;;4573   		{
;;;4574   			if( pulPreviousNotificationValue != NULL )
000010  2f00              CMP      r7,#0
000012  d001              BEQ      |L41.24|
;;;4575   			{
;;;4576   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000014  6ce0              LDR      r0,[r4,#0x4c]
000016  6038              STR      r0,[r7,#0]
                  |L41.24|
;;;4577   			}
;;;4578   
;;;4579   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000018  4620              MOV      r0,r4
00001a  3040              ADDS     r0,r0,#0x40
00001c  4601              MOV      r1,r0
00001e  7c00              LDRB     r0,[r0,#0x10]
;;;4580   
;;;4581   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000020  2202              MOVS     r2,#2
000022  740a              STRB     r2,[r1,#0x10]
;;;4582   
;;;4583   			switch( eAction )
000024  9903              LDR      r1,[sp,#0xc]
000026  000b              MOVS     r3,r1
000028  f7fffffe          BL       __ARM_common_switch8
00002c  05130408          DCB      0x05,0x13,0x04,0x08
000030  0c0e1300          DCB      0x0c,0x0e,0x13,0x00
;;;4584   			{
;;;4585   				case eSetBits	:
;;;4586   					pxTCB->ulNotifiedValue |= ulValue;
000034  6ce1              LDR      r1,[r4,#0x4c]
000036  4329              ORRS     r1,r1,r5
000038  64e1              STR      r1,[r4,#0x4c]
;;;4587   					break;
00003a  e00a              B        |L41.82|
;;;4588   
;;;4589   				case eIncrement	:
;;;4590   					( pxTCB->ulNotifiedValue )++;
00003c  6ce1              LDR      r1,[r4,#0x4c]
00003e  1c49              ADDS     r1,r1,#1
000040  64e1              STR      r1,[r4,#0x4c]
;;;4591   					break;
000042  e006              B        |L41.82|
;;;4592   
;;;4593   				case eSetValueWithOverwrite	:
;;;4594   					pxTCB->ulNotifiedValue = ulValue;
000044  64e5              STR      r5,[r4,#0x4c]
;;;4595   					break;
000046  e004              B        |L41.82|
;;;4596   
;;;4597   				case eSetValueWithoutOverwrite :
;;;4598   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000048  2802              CMP      r0,#2
00004a  d001              BEQ      |L41.80|
;;;4599   					{
;;;4600   						pxTCB->ulNotifiedValue = ulValue;
00004c  64e5              STR      r5,[r4,#0x4c]
00004e  e000              B        |L41.82|
                  |L41.80|
;;;4601   					}
;;;4602   					else
;;;4603   					{
;;;4604   						/* The value could not be written to the task. */
;;;4605   						xReturn = pdFAIL;
000050  2600              MOVS     r6,#0
                  |L41.82|
;;;4606   					}
;;;4607   					break;
;;;4608   
;;;4609   				case eNoAction:
;;;4610   					/* The task is being notified without its notify value being
;;;4611   					updated. */
;;;4612   					break;
;;;4613   			}
;;;4614   
;;;4615   			traceTASK_NOTIFY();
;;;4616   
;;;4617   			/* If the task is in the blocked state specifically to wait for a
;;;4618   			notification then unblock it now. */
;;;4619   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000052  2801              CMP      r0,#1
000054  d116              BNE      |L41.132|
;;;4620   			{
;;;4621   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000056  1d20              ADDS     r0,r4,#4
000058  f7fffffe          BL       uxListRemove
;;;4622   				prvAddTaskToReadyList( pxTCB );
00005c  4d0c              LDR      r5,|L41.144|
00005e  6ae0              LDR      r0,[r4,#0x2c]
000060  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000062  4288              CMP      r0,r1
000064  d900              BLS      |L41.104|
000066  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L41.104|
000068  2114              MOVS     r1,#0x14
00006a  4348              MULS     r0,r1,r0
00006c  4909              LDR      r1,|L41.148|
00006e  1840              ADDS     r0,r0,r1
000070  1d21              ADDS     r1,r4,#4
000072  f7fffffe          BL       vListInsertEnd
;;;4623   
;;;4624   				/* The task should not have been on an event list. */
;;;4625   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4626   
;;;4627   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4628   				{
;;;4629   					/* If a task is blocked waiting for a notification then
;;;4630   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4631   					out time.  If the task is unblocked for a reason other than
;;;4632   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4633   					because it will automatically get reset to a new value when
;;;4634   					the tick count equals xNextTaskUnblockTime.  However if
;;;4635   					tickless idling is used it might be more important to enter
;;;4636   					sleep mode at the earliest possible time - so reset
;;;4637   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4638   					earliest possible time. */
;;;4639   					prvResetNextTaskUnblockTime();
;;;4640   				}
;;;4641   				#endif
;;;4642   
;;;4643   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000076  6ae0              LDR      r0,[r4,#0x2c]
000078  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00007a  6ac9              LDR      r1,[r1,#0x2c]
00007c  4288              CMP      r0,r1
00007e  d901              BLS      |L41.132|
;;;4644   				{
;;;4645   					/* The notified task has a priority above the currently
;;;4646   					executing task so a yield is required. */
;;;4647   					taskYIELD_IF_USING_PREEMPTION();
000080  f7fffffe          BL       vPortYield
                  |L41.132|
;;;4648   				}
;;;4649   				else
;;;4650   				{
;;;4651   					mtCOVERAGE_TEST_MARKER();
;;;4652   				}
;;;4653   			}
;;;4654   			else
;;;4655   			{
;;;4656   				mtCOVERAGE_TEST_MARKER();
;;;4657   			}
;;;4658   		}
;;;4659   		taskEXIT_CRITICAL();
000084  f7fffffe          BL       vPortExitCritical
;;;4660   
;;;4661   		return xReturn;
000088  4630              MOV      r0,r6
;;;4662   	}
00008a  b005              ADD      sp,sp,#0x14
00008c  bdf0              POP      {r4-r7,pc}
;;;4663   
                          ENDP

00008e  0000              DCW      0x0000
                  |L41.144|
                          DCD      ||.data||
                  |L41.148|
                          DCD      NoInit

                          AREA ||i.xTaskGenericNotifyFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGenericNotifyFromISR PROC
;;;4668   
;;;4669   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000000  b5ff              PUSH     {r0-r7,lr}
;;;4670   	{
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  461f              MOV      r7,r3
;;;4671   	TCB_t * pxTCB;
;;;4672   	uint8_t ucOriginalNotifyState;
;;;4673   	BaseType_t xReturn = pdPASS;
00000a  2601              MOVS     r6,#1
;;;4674   	UBaseType_t uxSavedInterruptStatus;
;;;4675   
;;;4676   		configASSERT( xTaskToNotify );
;;;4677   
;;;4678   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4679   		maximum	system call (or maximum API call) interrupt priority.
;;;4680   		Interrupts that are	above the maximum system call priority are keep
;;;4681   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4682   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4683   		is defined in FreeRTOSConfig.h then
;;;4684   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4685   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4686   		been assigned a priority above the configured maximum system call
;;;4687   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4688   		from interrupts	that have been assigned a priority at or (logically)
;;;4689   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4690   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4691   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4692   		provided on the following link:
;;;4693   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4694   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;4695   
;;;4696   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4697   
;;;4698   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
00000c  f7fffffe          BL       ulSetInterruptMaskFromISR
000010  9000              STR      r0,[sp,#0]
;;;4699   		{
;;;4700   			if( pulPreviousNotificationValue != NULL )
000012  2f00              CMP      r7,#0
000014  d001              BEQ      |L42.26|
;;;4701   			{
;;;4702   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000016  6ce0              LDR      r0,[r4,#0x4c]
000018  6038              STR      r0,[r7,#0]
                  |L42.26|
;;;4703   			}
;;;4704   
;;;4705   			ucOriginalNotifyState = pxTCB->ucNotifyState;
00001a  4620              MOV      r0,r4
00001c  3040              ADDS     r0,r0,#0x40
00001e  4601              MOV      r1,r0
000020  7c00              LDRB     r0,[r0,#0x10]
;;;4706   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000022  2202              MOVS     r2,#2
000024  740a              STRB     r2,[r1,#0x10]
;;;4707   
;;;4708   			switch( eAction )
000026  9903              LDR      r1,[sp,#0xc]
000028  000b              MOVS     r3,r1
00002a  f7fffffe          BL       __ARM_common_switch8
00002e  0513              DCB      0x05,0x13
000030  04080c0e          DCB      0x04,0x08,0x0c,0x0e
000034  1300              DCB      0x13,0x00
;;;4709   			{
;;;4710   				case eSetBits	:
;;;4711   					pxTCB->ulNotifiedValue |= ulValue;
000036  6ce1              LDR      r1,[r4,#0x4c]
000038  4329              ORRS     r1,r1,r5
00003a  64e1              STR      r1,[r4,#0x4c]
;;;4712   					break;
00003c  e00a              B        |L42.84|
;;;4713   
;;;4714   				case eIncrement	:
;;;4715   					( pxTCB->ulNotifiedValue )++;
00003e  6ce1              LDR      r1,[r4,#0x4c]
000040  1c49              ADDS     r1,r1,#1
000042  64e1              STR      r1,[r4,#0x4c]
;;;4716   					break;
000044  e006              B        |L42.84|
;;;4717   
;;;4718   				case eSetValueWithOverwrite	:
;;;4719   					pxTCB->ulNotifiedValue = ulValue;
000046  64e5              STR      r5,[r4,#0x4c]
;;;4720   					break;
000048  e004              B        |L42.84|
;;;4721   
;;;4722   				case eSetValueWithoutOverwrite :
;;;4723   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
00004a  2802              CMP      r0,#2
00004c  d001              BEQ      |L42.82|
;;;4724   					{
;;;4725   						pxTCB->ulNotifiedValue = ulValue;
00004e  64e5              STR      r5,[r4,#0x4c]
000050  e000              B        |L42.84|
                  |L42.82|
;;;4726   					}
;;;4727   					else
;;;4728   					{
;;;4729   						/* The value could not be written to the task. */
;;;4730   						xReturn = pdFAIL;
000052  2600              MOVS     r6,#0
                  |L42.84|
;;;4731   					}
;;;4732   					break;
;;;4733   
;;;4734   				case eNoAction :
;;;4735   					/* The task is being notified without its notify value being
;;;4736   					updated. */
;;;4737   					break;
;;;4738   			}
;;;4739   
;;;4740   			traceTASK_NOTIFY_FROM_ISR();
;;;4741   
;;;4742   			/* If the task is in the blocked state specifically to wait for a
;;;4743   			notification then unblock it now. */
;;;4744   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000054  2801              CMP      r0,#1
000056  d125              BNE      |L42.164|
;;;4745   			{
;;;4746   				/* The task should not have been on an event list. */
;;;4747   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
;;;4748   
;;;4749   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000058  4d15              LDR      r5,|L42.176|
00005a  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00005c  2800              CMP      r0,#0
00005e  d010              BEQ      |L42.130|
;;;4750   				{
;;;4751   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;4752   					prvAddTaskToReadyList( pxTCB );
;;;4753   				}
;;;4754   				else
;;;4755   				{
;;;4756   					/* The delayed and ready lists cannot be accessed, so hold
;;;4757   					this task pending until the scheduler is resumed. */
;;;4758   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000060  4621              MOV      r1,r4
000062  3118              ADDS     r1,r1,#0x18
000064  4813              LDR      r0,|L42.180|
000066  f7fffffe          BL       vListInsertEnd
                  |L42.106|
;;;4759   				}
;;;4760   
;;;4761   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
00006a  6ae0              LDR      r0,[r4,#0x2c]
00006c  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
00006e  6ac9              LDR      r1,[r1,#0x2c]
000070  4288              CMP      r0,r1
000072  d917              BLS      |L42.164|
;;;4762   				{
;;;4763   					/* The notified task has a priority above the currently
;;;4764   					executing task so a yield is required. */
;;;4765   					if( pxHigherPriorityTaskWoken != NULL )
000074  990a              LDR      r1,[sp,#0x28]
000076  2001              MOVS     r0,#1                 ;4673
000078  2900              CMP      r1,#0
00007a  d012              BEQ      |L42.162|
;;;4766   					{
;;;4767   						*pxHigherPriorityTaskWoken = pdTRUE;
00007c  990a              LDR      r1,[sp,#0x28]
00007e  6008              STR      r0,[r1,#0]
000080  e010              B        |L42.164|
                  |L42.130|
000082  1d20              ADDS     r0,r4,#4              ;4751
000084  f7fffffe          BL       uxListRemove
000088  6ae0              LDR      r0,[r4,#0x2c]         ;4752
00008a  6929              LDR      r1,[r5,#0x10]         ;4752  ; uxTopReadyPriority
00008c  4288              CMP      r0,r1                 ;4752
00008e  d900              BLS      |L42.146|
000090  6128              STR      r0,[r5,#0x10]         ;4752  ; uxTopReadyPriority
                  |L42.146|
000092  2114              MOVS     r1,#0x14              ;4752
000094  4348              MULS     r0,r1,r0              ;4752
000096  4908              LDR      r1,|L42.184|
000098  1840              ADDS     r0,r0,r1              ;4752
00009a  1d21              ADDS     r1,r4,#4              ;4752
00009c  f7fffffe          BL       vListInsertEnd
0000a0  e7e3              B        |L42.106|
                  |L42.162|
;;;4768   					}
;;;4769   					else
;;;4770   					{
;;;4771   						/* Mark that a yield is pending in case the user is not
;;;4772   						using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4773   						safe FreeRTOS function. */
;;;4774   						xYieldPending = pdTRUE;
0000a2  61e8              STR      r0,[r5,#0x1c]  ; xYieldPending
                  |L42.164|
;;;4775   					}
;;;4776   				}
;;;4777   				else
;;;4778   				{
;;;4779   					mtCOVERAGE_TEST_MARKER();
;;;4780   				}
;;;4781   			}
;;;4782   		}
;;;4783   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
0000a4  9800              LDR      r0,[sp,#0]
0000a6  f7fffffe          BL       vClearInterruptMaskFromISR
;;;4784   
;;;4785   		return xReturn;
0000aa  4630              MOV      r0,r6
;;;4786   	}
0000ac  b005              ADD      sp,sp,#0x14
0000ae  bdf0              POP      {r4-r7,pc}
;;;4787   
                          ENDP

                  |L42.176|
                          DCD      ||.data||
                  |L42.180|
                          DCD      NoInit+0x118
                  |L42.184|
                          DCD      NoInit

                          AREA ||i.xTaskGetCurrentTaskHandle||, CODE, READONLY, ALIGN=2

                  xTaskGetCurrentTaskHandle PROC
;;;3755   
;;;3756   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000000  4801              LDR      r0,|L43.8|
;;;3757   	{
;;;3758   	TaskHandle_t xReturn;
;;;3759   
;;;3760   		/* A critical section is not required as this is not called from
;;;3761   		an interrupt and the current TCB will always be the same for any
;;;3762   		individual execution thread. */
;;;3763   		xReturn = pxCurrentTCB;
000002  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;3764   
;;;3765   		return xReturn;
;;;3766   	}
000004  4770              BX       lr
;;;3767   
                          ENDP

000006  0000              DCW      0x0000
                  |L43.8|
                          DCD      ||.data||

                          AREA ||i.xTaskGetSchedulerState||, CODE, READONLY, ALIGN=2

                  xTaskGetSchedulerState PROC
;;;3772   
;;;3773   	BaseType_t xTaskGetSchedulerState( void )
000000  4806              LDR      r0,|L44.28|
;;;3774   	{
;;;3775   	BaseType_t xReturn;
;;;3776   
;;;3777   		if( xSchedulerRunning == pdFALSE )
000002  6941              LDR      r1,[r0,#0x14]  ; xSchedulerRunning
000004  2900              CMP      r1,#0
000006  d004              BEQ      |L44.18|
;;;3778   		{
;;;3779   			xReturn = taskSCHEDULER_NOT_STARTED;
;;;3780   		}
;;;3781   		else
;;;3782   		{
;;;3783   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000008  6b00              LDR      r0,[r0,#0x30]  ; uxSchedulerSuspended
00000a  2800              CMP      r0,#0
00000c  d003              BEQ      |L44.22|
;;;3784   			{
;;;3785   				xReturn = taskSCHEDULER_RUNNING;
;;;3786   			}
;;;3787   			else
;;;3788   			{
;;;3789   				xReturn = taskSCHEDULER_SUSPENDED;
00000e  2000              MOVS     r0,#0
;;;3790   			}
;;;3791   		}
;;;3792   
;;;3793   		return xReturn;
;;;3794   	}
000010  4770              BX       lr
                  |L44.18|
000012  2001              MOVS     r0,#1                 ;3779
000014  4770              BX       lr
                  |L44.22|
000016  2002              MOVS     r0,#2                 ;3785
000018  4770              BX       lr
;;;3795   
                          ENDP

00001a  0000              DCW      0x0000
                  |L44.28|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCount||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCount PROC
;;;2214   
;;;2215   TickType_t xTaskGetTickCount( void )
000000  4801              LDR      r0,|L45.8|
;;;2216   {
;;;2217   TickType_t xTicks;
;;;2218   
;;;2219   	/* Critical section required if running on a 16 bit processor. */
;;;2220   	portTICK_TYPE_ENTER_CRITICAL();
;;;2221   	{
;;;2222   		xTicks = xTickCount;
000002  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2223   	}
;;;2224   	portTICK_TYPE_EXIT_CRITICAL();
;;;2225   
;;;2226   	return xTicks;
;;;2227   }
000004  4770              BX       lr
;;;2228   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L45.8|
                          DCD      ||.data||

                          AREA ||i.xTaskGetTickCountFromISR||, CODE, READONLY, ALIGN=2

                  xTaskGetTickCountFromISR PROC
;;;2229   
;;;2230   TickType_t xTaskGetTickCountFromISR( void )
000000  4801              LDR      r0,|L46.8|
;;;2231   {
;;;2232   TickType_t xReturn;
;;;2233   UBaseType_t uxSavedInterruptStatus;
;;;2234   
;;;2235   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2236   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2237   	above the maximum system call priority are kept permanently enabled, even
;;;2238   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2239   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2240   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2241   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2242   	assigned a priority above the configured maximum system call priority.
;;;2243   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2244   	that have been assigned a priority at or (logically) below the maximum
;;;2245   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2246   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2247   	More information (albeit Cortex-M specific) is provided on the following
;;;2248   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2249   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;2250   
;;;2251   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;2252   	{
;;;2253   		xReturn = xTickCount;
000002  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2254   	}
;;;2255   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2256   
;;;2257   	return xReturn;
;;;2258   }
000004  4770              BX       lr
;;;2259   /*-----------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L46.8|
                          DCD      ||.data||

                          AREA ||i.xTaskIncrementTick||, CODE, READONLY, ALIGN=2

                  xTaskIncrementTick PROC
;;;2588   
;;;2589   BaseType_t xTaskIncrementTick( void )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2590   {
;;;2591   TCB_t * pxTCB;
;;;2592   TickType_t xItemValue;
;;;2593   BaseType_t xSwitchRequired = pdFALSE;
000002  2600              MOVS     r6,#0
;;;2594   
;;;2595   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2596   	Increments the tick then checks to see if the new tick value will cause any
;;;2597   	tasks to be unblocked. */
;;;2598   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2599   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000004  4f29              LDR      r7,|L47.172|
000006  6b38              LDR      r0,[r7,#0x30]  ; uxSchedulerSuspended
000008  2800              CMP      r0,#0
00000a  d008              BEQ      |L47.30|
;;;2600   	{
;;;2601   		/* Minor optimisation.  The tick count cannot change in this
;;;2602   		block. */
;;;2603   		const TickType_t xConstTickCount = xTickCount + ( TickType_t ) 1;
;;;2604   
;;;2605   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2606   		delayed lists if it wraps to 0. */
;;;2607   		xTickCount = xConstTickCount;
;;;2608   
;;;2609   		if( xConstTickCount == ( TickType_t ) 0U ) /*lint !e774 'if' does not always evaluate to false as it is looking for an overflow. */
;;;2610   		{
;;;2611   			taskSWITCH_DELAYED_LISTS();
;;;2612   		}
;;;2613   		else
;;;2614   		{
;;;2615   			mtCOVERAGE_TEST_MARKER();
;;;2616   		}
;;;2617   
;;;2618   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2619   		the	queue in the order of their wake time - meaning once one task
;;;2620   		has been found whose block time has not expired there is no need to
;;;2621   		look any further down the list. */
;;;2622   		if( xConstTickCount >= xNextTaskUnblockTime )
;;;2623   		{
;;;2624   			for( ;; )
;;;2625   			{
;;;2626   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;2627   				{
;;;2628   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2629   					to the maximum possible value so it is extremely
;;;2630   					unlikely that the
;;;2631   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2632   					next time through. */
;;;2633   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;2634   					break;
;;;2635   				}
;;;2636   				else
;;;2637   				{
;;;2638   					/* The delayed list is not empty, get the value of the
;;;2639   					item at the head of the delayed list.  This is the time
;;;2640   					at which the task at the head of the delayed list must
;;;2641   					be removed from the Blocked state. */
;;;2642   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
;;;2643   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
;;;2644   
;;;2645   					if( xConstTickCount < xItemValue )
;;;2646   					{
;;;2647   						/* It is not time to unblock this item yet, but the
;;;2648   						item value is the time at which the task at the head
;;;2649   						of the blocked list must be removed from the Blocked
;;;2650   						state -	so record the item value in
;;;2651   						xNextTaskUnblockTime. */
;;;2652   						xNextTaskUnblockTime = xItemValue;
;;;2653   						break;
;;;2654   					}
;;;2655   					else
;;;2656   					{
;;;2657   						mtCOVERAGE_TEST_MARKER();
;;;2658   					}
;;;2659   
;;;2660   					/* It is time to remove the item from the Blocked state. */
;;;2661   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;2662   
;;;2663   					/* Is the task waiting on an event also?  If so remove
;;;2664   					it from the event list. */
;;;2665   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
;;;2666   					{
;;;2667   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2668   					}
;;;2669   					else
;;;2670   					{
;;;2671   						mtCOVERAGE_TEST_MARKER();
;;;2672   					}
;;;2673   
;;;2674   					/* Place the unblocked task into the appropriate ready
;;;2675   					list. */
;;;2676   					prvAddTaskToReadyList( pxTCB );
;;;2677   
;;;2678   					/* A task being unblocked cannot cause an immediate
;;;2679   					context switch if preemption is turned off. */
;;;2680   					#if (  configUSE_PREEMPTION == 1 )
;;;2681   					{
;;;2682   						/* Preemption is on, but a context switch should
;;;2683   						only be performed if the unblocked task has a
;;;2684   						priority that is equal to or higher than the
;;;2685   						currently executing task. */
;;;2686   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;2687   						{
;;;2688   							xSwitchRequired = pdTRUE;
;;;2689   						}
;;;2690   						else
;;;2691   						{
;;;2692   							mtCOVERAGE_TEST_MARKER();
;;;2693   						}
;;;2694   					}
;;;2695   					#endif /* configUSE_PREEMPTION */
;;;2696   				}
;;;2697   			}
;;;2698   		}
;;;2699   
;;;2700   		/* Tasks of equal priority to the currently running task will share
;;;2701   		processing time (time slice) if preemption is on, and the application
;;;2702   		writer has not explicitly turned time slicing off. */
;;;2703   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2704   		{
;;;2705   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
;;;2706   			{
;;;2707   				xSwitchRequired = pdTRUE;
;;;2708   			}
;;;2709   			else
;;;2710   			{
;;;2711   				mtCOVERAGE_TEST_MARKER();
;;;2712   			}
;;;2713   		}
;;;2714   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2715   
;;;2716   		#if ( configUSE_TICK_HOOK == 1 )
;;;2717   		{
;;;2718   			/* Guard against the tick hook being called when the pended tick
;;;2719   			count is being unwound (when the scheduler is being unlocked). */
;;;2720   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2721   			{
;;;2722   				vApplicationTickHook();
;;;2723   			}
;;;2724   			else
;;;2725   			{
;;;2726   				mtCOVERAGE_TEST_MARKER();
;;;2727   			}
;;;2728   		}
;;;2729   		#endif /* configUSE_TICK_HOOK */
;;;2730   	}
;;;2731   	else
;;;2732   	{
;;;2733   		++uxPendedTicks;
00000c  69b8              LDR      r0,[r7,#0x18]  ; uxPendedTicks
00000e  1c40              ADDS     r0,r0,#1
000010  61b8              STR      r0,[r7,#0x18]  ; uxPendedTicks
                  |L47.18|
;;;2734   
;;;2735   		/* The tick hook gets called at regular intervals, even if the
;;;2736   		scheduler is locked. */
;;;2737   		#if ( configUSE_TICK_HOOK == 1 )
;;;2738   		{
;;;2739   			vApplicationTickHook();
;;;2740   		}
;;;2741   		#endif
;;;2742   	}
;;;2743   
;;;2744   	#if ( configUSE_PREEMPTION == 1 )
;;;2745   	{
;;;2746   		if( xYieldPending != pdFALSE )
000012  69f8              LDR      r0,[r7,#0x1c]  ; xYieldPending
000014  2800              CMP      r0,#0
000016  d000              BEQ      |L47.26|
;;;2747   		{
;;;2748   			xSwitchRequired = pdTRUE;
000018  2601              MOVS     r6,#1
                  |L47.26|
;;;2749   		}
;;;2750   		else
;;;2751   		{
;;;2752   			mtCOVERAGE_TEST_MARKER();
;;;2753   		}
;;;2754   	}
;;;2755   	#endif /* configUSE_PREEMPTION */
;;;2756   
;;;2757   	return xSwitchRequired;
00001a  4630              MOV      r0,r6
;;;2758   }
00001c  bdf8              POP      {r3-r7,pc}
                  |L47.30|
00001e  68fd              LDR      r5,[r7,#0xc]          ;2603  ; xTickCount
000020  1c6d              ADDS     r5,r5,#1              ;2603
000022  60fd              STR      r5,[r7,#0xc]          ;2607  ; xTickCount
000024  2d00              CMP      r5,#0                 ;2609
000026  d108              BNE      |L47.58|
000028  6b78              LDR      r0,[r7,#0x34]         ;2611  ; pxDelayedTaskList
00002a  6bb9              LDR      r1,[r7,#0x38]         ;2611  ; pxOverflowDelayedTaskList
00002c  6379              STR      r1,[r7,#0x34]         ;2611  ; pxDelayedTaskList
00002e  63b8              STR      r0,[r7,#0x38]         ;2611  ; pxOverflowDelayedTaskList
000030  6a38              LDR      r0,[r7,#0x20]         ;2611  ; xNumOfOverflows
000032  1c40              ADDS     r0,r0,#1              ;2611
000034  6238              STR      r0,[r7,#0x20]         ;2611  ; xNumOfOverflows
000036  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L47.58|
00003a  6ab8              LDR      r0,[r7,#0x28]         ;2622  ; xNextTaskUnblockTime
00003c  4285              CMP      r5,r0                 ;2622
00003e  d30e              BCC      |L47.94|
                  |L47.64|
000040  6b78              LDR      r0,[r7,#0x34]         ;2626  ; pxDelayedTaskList
000042  6800              LDR      r0,[r0,#0]            ;2626
000044  2800              CMP      r0,#0                 ;2626
000046  d007              BEQ      |L47.88|
000048  6b78              LDR      r0,[r7,#0x34]         ;2642  ; pxDelayedTaskList
00004a  68c0              LDR      r0,[r0,#0xc]          ;2642
00004c  68c4              LDR      r4,[r0,#0xc]          ;2642
00004e  6860              LDR      r0,[r4,#4]            ;2643
000050  4285              CMP      r5,r0                 ;2645
000052  d20e              BCS      |L47.114|
000054  62b8              STR      r0,[r7,#0x28]         ;2652  ; xNextTaskUnblockTime
000056  e002              B        |L47.94|
                  |L47.88|
000058  2000              MOVS     r0,#0                 ;2633
00005a  43c0              MVNS     r0,r0                 ;2633
00005c  62b8              STR      r0,[r7,#0x28]         ;2633  ; xNextTaskUnblockTime
                  |L47.94|
00005e  6838              LDR      r0,[r7,#0]            ;2705  ; pxCurrentTCB
000060  2114              MOVS     r1,#0x14              ;2705
000062  6ac0              LDR      r0,[r0,#0x2c]         ;2705
000064  4348              MULS     r0,r1,r0              ;2705
000066  4912              LDR      r1,|L47.176|
000068  5808              LDR      r0,[r1,r0]            ;2705
00006a  2801              CMP      r0,#1                 ;2705
00006c  d9d1              BLS      |L47.18|
00006e  2601              MOVS     r6,#1                 ;2707
000070  e7cf              B        |L47.18|
                  |L47.114|
000072  1d20              ADDS     r0,r4,#4              ;2661
000074  f7fffffe          BL       uxListRemove
000078  6aa0              LDR      r0,[r4,#0x28]         ;2665
00007a  2800              CMP      r0,#0                 ;2665
00007c  d003              BEQ      |L47.134|
00007e  4620              MOV      r0,r4                 ;2667
000080  3018              ADDS     r0,r0,#0x18           ;2667
000082  f7fffffe          BL       uxListRemove
                  |L47.134|
000086  6ae0              LDR      r0,[r4,#0x2c]         ;2676
000088  6939              LDR      r1,[r7,#0x10]         ;2676  ; uxTopReadyPriority
00008a  4288              CMP      r0,r1                 ;2676
00008c  d900              BLS      |L47.144|
00008e  6138              STR      r0,[r7,#0x10]         ;2676  ; uxTopReadyPriority
                  |L47.144|
000090  2114              MOVS     r1,#0x14              ;2676
000092  4348              MULS     r0,r1,r0              ;2676
000094  4906              LDR      r1,|L47.176|
000096  1840              ADDS     r0,r0,r1              ;2676
000098  1d21              ADDS     r1,r4,#4              ;2676
00009a  f7fffffe          BL       vListInsertEnd
00009e  6ae0              LDR      r0,[r4,#0x2c]         ;2686
0000a0  6839              LDR      r1,[r7,#0]            ;2686  ; pxCurrentTCB
0000a2  6ac9              LDR      r1,[r1,#0x2c]         ;2686
0000a4  4288              CMP      r0,r1                 ;2686
0000a6  d3cb              BCC      |L47.64|
0000a8  2601              MOVS     r6,#1                 ;2688
0000aa  e7c9              B        |L47.64|
;;;2759   /*-----------------------------------------------------------*/
                          ENDP

                  |L47.172|
                          DCD      ||.data||
                  |L47.176|
                          DCD      NoInit

                          AREA ||i.xTaskNotifyStateClear||, CODE, READONLY, ALIGN=2

                  xTaskNotifyStateClear PROC
;;;4881   
;;;4882   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000000  b510              PUSH     {r4,lr}
;;;4883   	{
;;;4884   	TCB_t *pxTCB;
;;;4885   	BaseType_t xReturn;
;;;4886   
;;;4887   		/* If null is passed in here then it is the calling task that is having
;;;4888   		its notification state cleared. */
;;;4889   		pxTCB = prvGetTCBFromHandle( xTask );
000002  2800              CMP      r0,#0
000004  d00b              BEQ      |L48.30|
000006  4604              MOV      r4,r0
                  |L48.8|
;;;4890   
;;;4891   		taskENTER_CRITICAL();
000008  f7fffffe          BL       vPortEnterCritical
;;;4892   		{
;;;4893   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
00000c  3440              ADDS     r4,r4,#0x40
00000e  7c20              LDRB     r0,[r4,#0x10]
000010  2802              CMP      r0,#2
000012  d007              BEQ      |L48.36|
;;;4894   			{
;;;4895   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
;;;4896   				xReturn = pdPASS;
;;;4897   			}
;;;4898   			else
;;;4899   			{
;;;4900   				xReturn = pdFAIL;
000014  2400              MOVS     r4,#0
                  |L48.22|
;;;4901   			}
;;;4902   		}
;;;4903   		taskEXIT_CRITICAL();
000016  f7fffffe          BL       vPortExitCritical
;;;4904   
;;;4905   		return xReturn;
00001a  4620              MOV      r0,r4
;;;4906   	}
00001c  bd10              POP      {r4,pc}
                  |L48.30|
00001e  4803              LDR      r0,|L48.44|
000020  6804              LDR      r4,[r0,#0]            ;4889  ; pxCurrentTCB
000022  e7f1              B        |L48.8|
                  |L48.36|
000024  2000              MOVS     r0,#0                 ;4895
000026  7420              STRB     r0,[r4,#0x10]         ;4895
000028  2401              MOVS     r4,#1                 ;4896
00002a  e7f4              B        |L48.22|
;;;4907   
                          ENDP

                  |L48.44|
                          DCD      ||.data||

                          AREA ||i.xTaskNotifyWait||, CODE, READONLY, ALIGN=2

                  xTaskNotifyWait PROC
;;;4482   
;;;4483   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000000  b5ff              PUSH     {r0-r7,lr}
;;;4484   	{
000002  b081              SUB      sp,sp,#4
000004  4607              MOV      r7,r0
000006  4615              MOV      r5,r2
000008  461e              MOV      r6,r3
;;;4485   	BaseType_t xReturn;
;;;4486   
;;;4487   		taskENTER_CRITICAL();
00000a  f7fffffe          BL       vPortEnterCritical
;;;4488   		{
;;;4489   			/* Only block if a notification is not already pending. */
;;;4490   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
00000e  4c1a              LDR      r4,|L49.120|
000010  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000012  3040              ADDS     r0,r0,#0x40
000014  7c00              LDRB     r0,[r0,#0x10]
000016  2802              CMP      r0,#2
000018  d00e              BEQ      |L49.56|
;;;4491   			{
;;;4492   				/* Clear bits in the task's notification value as bits may get
;;;4493   				set	by the notifying task or interrupt.  This can be used to
;;;4494   				clear the value to zero. */
;;;4495   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
00001a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00001c  6cc1              LDR      r1,[r0,#0x4c]
00001e  43b9              BICS     r1,r1,r7
000020  64c1              STR      r1,[r0,#0x4c]
;;;4496   
;;;4497   				/* Mark this task as waiting for a notification. */
;;;4498   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000022  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000024  2101              MOVS     r1,#1
000026  3040              ADDS     r0,r0,#0x40
000028  7401              STRB     r1,[r0,#0x10]
;;;4499   
;;;4500   				if( xTicksToWait > ( TickType_t ) 0 )
00002a  2e00              CMP      r6,#0
00002c  d004              BEQ      |L49.56|
;;;4501   				{
;;;4502   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4503   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4504   
;;;4505   					/* All ports are written to allow a yield in a critical
;;;4506   					section (some will yield immediately, others wait until the
;;;4507   					critical section exits) - but it is not something that
;;;4508   					application code should ever do. */
;;;4509   					portYIELD_WITHIN_API();
000034  f7fffffe          BL       vPortYield
                  |L49.56|
;;;4510   				}
;;;4511   				else
;;;4512   				{
;;;4513   					mtCOVERAGE_TEST_MARKER();
;;;4514   				}
;;;4515   			}
;;;4516   			else
;;;4517   			{
;;;4518   				mtCOVERAGE_TEST_MARKER();
;;;4519   			}
;;;4520   		}
;;;4521   		taskEXIT_CRITICAL();
000038  f7fffffe          BL       vPortExitCritical
;;;4522   
;;;4523   		taskENTER_CRITICAL();
00003c  f7fffffe          BL       vPortEnterCritical
;;;4524   		{
;;;4525   			traceTASK_NOTIFY_WAIT();
;;;4526   
;;;4527   			if( pulNotificationValue != NULL )
000040  2d00              CMP      r5,#0
000042  d002              BEQ      |L49.74|
;;;4528   			{
;;;4529   				/* Output the current notification value, which may or may not
;;;4530   				have changed. */
;;;4531   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000044  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000046  6cc0              LDR      r0,[r0,#0x4c]
000048  6028              STR      r0,[r5,#0]
                  |L49.74|
;;;4532   			}
;;;4533   
;;;4534   			/* If ucNotifyValue is set then either the task never entered the
;;;4535   			blocked state (because a notification was already pending) or the
;;;4536   			task unblocked because of a notification.  Otherwise the task
;;;4537   			unblocked because of a timeout. */
;;;4538   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
00004a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00004c  3040              ADDS     r0,r0,#0x40
00004e  7c00              LDRB     r0,[r0,#0x10]
000050  2802              CMP      r0,#2
000052  d001              BEQ      |L49.88|
;;;4539   			{
;;;4540   				/* A notification was not received. */
;;;4541   				xReturn = pdFALSE;
000054  2500              MOVS     r5,#0
000056  e005              B        |L49.100|
                  |L49.88|
;;;4542   			}
;;;4543   			else
;;;4544   			{
;;;4545   				/* A notification was already pending or a notification was
;;;4546   				received while the task was waiting. */
;;;4547   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000058  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
00005a  6cc1              LDR      r1,[r0,#0x4c]
00005c  9a02              LDR      r2,[sp,#8]
00005e  4391              BICS     r1,r1,r2
000060  64c1              STR      r1,[r0,#0x4c]
;;;4548   				xReturn = pdTRUE;
000062  2501              MOVS     r5,#1
                  |L49.100|
;;;4549   			}
;;;4550   
;;;4551   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000064  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000066  2100              MOVS     r1,#0
000068  3040              ADDS     r0,r0,#0x40
00006a  7401              STRB     r1,[r0,#0x10]
;;;4552   		}
;;;4553   		taskEXIT_CRITICAL();
00006c  f7fffffe          BL       vPortExitCritical
;;;4554   
;;;4555   		return xReturn;
000070  4628              MOV      r0,r5
;;;4556   	}
000072  b005              ADD      sp,sp,#0x14
000074  bdf0              POP      {r4-r7,pc}
;;;4557   
                          ENDP

000076  0000              DCW      0x0000
                  |L49.120|
                          DCD      ||.data||

                          AREA ||i.xTaskPriorityDisinherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityDisinherit PROC
;;;3887   
;;;3888   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000000  b510              PUSH     {r4,lr}
;;;3889   	{
000002  4604              MOV      r4,r0
;;;3890   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
;;;3891   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;3892   
;;;3893   		if( pxMutexHolder != NULL )
000006  2c00              CMP      r4,#0
000008  d01e              BEQ      |L50.72|
;;;3894   		{
;;;3895   			/* A task can only have an inherited priority if it holds the mutex.
;;;3896   			If the mutex is held by a task then it cannot be given from an
;;;3897   			interrupt, and if a mutex is given by the holding task then it must
;;;3898   			be the running state task. */
;;;3899   			configASSERT( pxTCB == pxCurrentTCB );
;;;3900   			configASSERT( pxTCB->uxMutexesHeld );
;;;3901   			( pxTCB->uxMutexesHeld )--;
00000a  6ca1              LDR      r1,[r4,#0x48]
00000c  1e49              SUBS     r1,r1,#1
00000e  64a1              STR      r1,[r4,#0x48]
;;;3902   
;;;3903   			/* Has the holder of the mutex inherited the priority of another
;;;3904   			task? */
;;;3905   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000010  6c63              LDR      r3,[r4,#0x44]
000012  6ae2              LDR      r2,[r4,#0x2c]
000014  429a              CMP      r2,r3
000016  d017              BEQ      |L50.72|
;;;3906   			{
;;;3907   				/* Only disinherit if no other mutexes are held. */
;;;3908   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000018  2900              CMP      r1,#0
00001a  d115              BNE      |L50.72|
;;;3909   				{
;;;3910   					/* A task can only have an inherited priority if it holds
;;;3911   					the mutex.  If the mutex is held by a task then it cannot be
;;;3912   					given from an interrupt, and if a mutex is given by the
;;;3913   					holding task then it must be the running state task.  Remove
;;;3914   					the holding task from the ready list. */
;;;3915   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00001c  1d20              ADDS     r0,r4,#4
00001e  f7fffffe          BL       uxListRemove
;;;3916   					{
;;;3917   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
;;;3918   					}
;;;3919   					else
;;;3920   					{
;;;3921   						mtCOVERAGE_TEST_MARKER();
;;;3922   					}
;;;3923   
;;;3924   					/* Disinherit the priority before adding the task into the
;;;3925   					new	ready list. */
;;;3926   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3927   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000022  6c60              LDR      r0,[r4,#0x44]
000024  62e0              STR      r0,[r4,#0x2c]
;;;3928   
;;;3929   					/* Reset the event list item value.  It cannot be in use for
;;;3930   					any other purpose if this task is running, and it must be
;;;3931   					running to give back the mutex. */
;;;3932   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000026  210c              MOVS     r1,#0xc
000028  1a08              SUBS     r0,r1,r0
00002a  61a0              STR      r0,[r4,#0x18]
;;;3933   					prvAddTaskToReadyList( pxTCB );
00002c  4907              LDR      r1,|L50.76|
00002e  6ae0              LDR      r0,[r4,#0x2c]
000030  690a              LDR      r2,[r1,#0x10]  ; uxTopReadyPriority
000032  4290              CMP      r0,r2
000034  d900              BLS      |L50.56|
000036  6108              STR      r0,[r1,#0x10]  ; uxTopReadyPriority
                  |L50.56|
000038  2114              MOVS     r1,#0x14
00003a  4348              MULS     r0,r1,r0
00003c  4904              LDR      r1,|L50.80|
00003e  1840              ADDS     r0,r0,r1
000040  1d21              ADDS     r1,r4,#4
000042  f7fffffe          BL       vListInsertEnd
;;;3934   
;;;3935   					/* Return true to indicate that a context switch is required.
;;;3936   					This is only actually required in the corner case whereby
;;;3937   					multiple mutexes were held and the mutexes were given back
;;;3938   					in an order different to that in which they were taken.
;;;3939   					If a context switch did not occur when the first mutex was
;;;3940   					returned, even if a task was waiting on it, then a context
;;;3941   					switch should occur when the last mutex is returned whether
;;;3942   					a task is waiting on it or not. */
;;;3943   					xReturn = pdTRUE;
000046  2001              MOVS     r0,#1
                  |L50.72|
;;;3944   				}
;;;3945   				else
;;;3946   				{
;;;3947   					mtCOVERAGE_TEST_MARKER();
;;;3948   				}
;;;3949   			}
;;;3950   			else
;;;3951   			{
;;;3952   				mtCOVERAGE_TEST_MARKER();
;;;3953   			}
;;;3954   		}
;;;3955   		else
;;;3956   		{
;;;3957   			mtCOVERAGE_TEST_MARKER();
;;;3958   		}
;;;3959   
;;;3960   		return xReturn;
;;;3961   	}
000048  bd10              POP      {r4,pc}
;;;3962   
                          ENDP

00004a  0000              DCW      0x0000
                  |L50.76|
                          DCD      ||.data||
                  |L50.80|
                          DCD      NoInit

                          AREA ||i.xTaskPriorityInherit||, CODE, READONLY, ALIGN=2

                  xTaskPriorityInherit PROC
;;;3800   
;;;3801   	BaseType_t xTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000000  b570              PUSH     {r4-r6,lr}
;;;3802   	{
000002  4604              MOV      r4,r0
;;;3803   	TCB_t * const pxMutexHolderTCB = ( TCB_t * ) pxMutexHolder;
;;;3804   	BaseType_t xReturn = pdFALSE;
000004  2000              MOVS     r0,#0
;;;3805   
;;;3806   		/* If the mutex was given back by an interrupt while the queue was
;;;3807   		locked then the mutex holder might now be NULL.  _RB_ Is this still
;;;3808   		needed as interrupts can no longer use mutexes? */
;;;3809   		if( pxMutexHolder != NULL )
000006  2c00              CMP      r4,#0
000008  d02a              BEQ      |L51.96|
;;;3810   		{
;;;3811   			/* If the holder of the mutex has a priority below the priority of
;;;3812   			the task attempting to obtain the mutex then it will temporarily
;;;3813   			inherit the priority of the task attempting to obtain the mutex. */
;;;3814   			if( pxMutexHolderTCB->uxPriority < pxCurrentTCB->uxPriority )
00000a  4d19              LDR      r5,|L51.112|
00000c  6ae1              LDR      r1,[r4,#0x2c]
00000e  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
000010  6ad2              LDR      r2,[r2,#0x2c]
000012  4291              CMP      r1,r2
000014  d225              BCS      |L51.98|
;;;3815   			{
;;;3816   				/* Adjust the mutex holder state to account for its new
;;;3817   				priority.  Only reset the event list item value if the value is
;;;3818   				not being used for anything else. */
;;;3819   				if( ( listGET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000016  69a0              LDR      r0,[r4,#0x18]
000018  2800              CMP      r0,#0
00001a  db04              BLT      |L51.38|
;;;3820   				{
;;;3821   					listSET_LIST_ITEM_VALUE( &( pxMutexHolderTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
00001c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00001e  210c              MOVS     r1,#0xc
000020  6ac0              LDR      r0,[r0,#0x2c]
000022  1a08              SUBS     r0,r1,r0
000024  61a0              STR      r0,[r4,#0x18]
                  |L51.38|
;;;3822   				}
;;;3823   				else
;;;3824   				{
;;;3825   					mtCOVERAGE_TEST_MARKER();
;;;3826   				}
;;;3827   
;;;3828   				/* If the task being modified is in the ready state it will need
;;;3829   				to be moved into a new list. */
;;;3830   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxMutexHolderTCB->uxPriority ] ), &( pxMutexHolderTCB->xStateListItem ) ) != pdFALSE )
000026  6ae0              LDR      r0,[r4,#0x2c]
000028  2214              MOVS     r2,#0x14
00002a  4e12              LDR      r6,|L51.116|
00002c  4350              MULS     r0,r2,r0
00002e  6961              LDR      r1,[r4,#0x14]
000030  1980              ADDS     r0,r0,r6
000032  4281              CMP      r1,r0
000034  d110              BNE      |L51.88|
;;;3831   				{
;;;3832   					if( uxListRemove( &( pxMutexHolderTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000036  1d20              ADDS     r0,r4,#4
000038  f7fffffe          BL       uxListRemove
;;;3833   					{
;;;3834   						taskRESET_READY_PRIORITY( pxMutexHolderTCB->uxPriority );
;;;3835   					}
;;;3836   					else
;;;3837   					{
;;;3838   						mtCOVERAGE_TEST_MARKER();
;;;3839   					}
;;;3840   
;;;3841   					/* Inherit the priority before being moved into the new list. */
;;;3842   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
00003c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00003e  6ac0              LDR      r0,[r0,#0x2c]
000040  62e0              STR      r0,[r4,#0x2c]
;;;3843   					prvAddTaskToReadyList( pxMutexHolderTCB );
000042  6929              LDR      r1,[r5,#0x10]  ; uxTopReadyPriority
000044  4288              CMP      r0,r1
000046  d900              BLS      |L51.74|
000048  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L51.74|
00004a  2114              MOVS     r1,#0x14
00004c  4348              MULS     r0,r1,r0
00004e  1980              ADDS     r0,r0,r6
000050  1d21              ADDS     r1,r4,#4
000052  f7fffffe          BL       vListInsertEnd
000056  e002              B        |L51.94|
                  |L51.88|
;;;3844   				}
;;;3845   				else
;;;3846   				{
;;;3847   					/* Just inherit the priority. */
;;;3848   					pxMutexHolderTCB->uxPriority = pxCurrentTCB->uxPriority;
000058  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00005a  6ac0              LDR      r0,[r0,#0x2c]
00005c  62e0              STR      r0,[r4,#0x2c]
                  |L51.94|
;;;3849   				}
;;;3850   
;;;3851   				traceTASK_PRIORITY_INHERIT( pxMutexHolderTCB, pxCurrentTCB->uxPriority );
;;;3852   
;;;3853   				/* Inheritance occurred. */
;;;3854   				xReturn = pdTRUE;
00005e  2001              MOVS     r0,#1
                  |L51.96|
;;;3855   			}
;;;3856   			else
;;;3857   			{
;;;3858   				if( pxMutexHolderTCB->uxBasePriority < pxCurrentTCB->uxPriority )
;;;3859   				{
;;;3860   					/* The base priority of the mutex holder is lower than the
;;;3861   					priority of the task attempting to take the mutex, but the
;;;3862   					current priority of the mutex holder is not lower than the
;;;3863   					priority of the task attempting to take the mutex.
;;;3864   					Therefore the mutex holder must have already inherited a
;;;3865   					priority, but inheritance would have occurred if that had
;;;3866   					not been the case. */
;;;3867   					xReturn = pdTRUE;
;;;3868   				}
;;;3869   				else
;;;3870   				{
;;;3871   					mtCOVERAGE_TEST_MARKER();
;;;3872   				}
;;;3873   			}
;;;3874   		}
;;;3875   		else
;;;3876   		{
;;;3877   			mtCOVERAGE_TEST_MARKER();
;;;3878   		}
;;;3879   
;;;3880   		return xReturn;
;;;3881   	}
000060  bd70              POP      {r4-r6,pc}
                  |L51.98|
000062  6c61              LDR      r1,[r4,#0x44]         ;3858
000064  682a              LDR      r2,[r5,#0]            ;3858  ; pxCurrentTCB
000066  6ad2              LDR      r2,[r2,#0x2c]         ;3858
000068  4291              CMP      r1,r2                 ;3858
00006a  d2f9              BCS      |L51.96|
00006c  2001              MOVS     r0,#1                 ;3867
00006e  bd70              POP      {r4-r6,pc}
;;;3882   
                          ENDP

                  |L51.112|
                          DCD      ||.data||
                  |L51.116|
                          DCD      NoInit

                          AREA ||i.xTaskRemoveFromEventList||, CODE, READONLY, ALIGN=2

                  xTaskRemoveFromEventList PROC
;;;2983   
;;;2984   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
000000  b570              PUSH     {r4-r6,lr}
;;;2985   {
;;;2986   TCB_t *pxUnblockedTCB;
;;;2987   BaseType_t xReturn;
;;;2988   
;;;2989   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2990   	called from a critical section within an ISR. */
;;;2991   
;;;2992   	/* The event list is sorted in priority order, so the first in the list can
;;;2993   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2994   	the delayed list, and add it to the ready list.
;;;2995   
;;;2996   	If an event is for a queue that is locked then this function will never
;;;2997   	get called - the lock count on the queue will get modified instead.  This
;;;2998   	means exclusive access to the event list is guaranteed here.
;;;2999   
;;;3000   	This function assumes that a check has already been made to ensure that
;;;3001   	pxEventList is not empty. */
;;;3002   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000002  68c0              LDR      r0,[r0,#0xc]
000004  68c4              LDR      r4,[r0,#0xc]
;;;3003   	configASSERT( pxUnblockedTCB );
;;;3004   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000006  4620              MOV      r0,r4
000008  3018              ADDS     r0,r0,#0x18
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       uxListRemove
;;;3005   
;;;3006   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000010  4d11              LDR      r5,|L52.88|
000012  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000014  2800              CMP      r0,#0
000016  d00c              BEQ      |L52.50|
;;;3007   	{
;;;3008   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
;;;3009   		prvAddTaskToReadyList( pxUnblockedTCB );
;;;3010   	}
;;;3011   	else
;;;3012   	{
;;;3013   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;3014   		pending until the scheduler is resumed. */
;;;3015   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
000018  4631              MOV      r1,r6
00001a  4810              LDR      r0,|L52.92|
00001c  f7fffffe          BL       vListInsertEnd
                  |L52.32|
;;;3016   	}
;;;3017   
;;;3018   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000020  6ae0              LDR      r0,[r4,#0x2c]
000022  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000024  6ac9              LDR      r1,[r1,#0x2c]
000026  4288              CMP      r0,r1
000028  d913              BLS      |L52.82|
;;;3019   	{
;;;3020   		/* Return true if the task removed from the event list has a higher
;;;3021   		priority than the calling task.  This allows the calling task to know if
;;;3022   		it should force a context switch now. */
;;;3023   		xReturn = pdTRUE;
00002a  2001              MOVS     r0,#1
;;;3024   
;;;3025   		/* Mark that a yield is pending in case the user is not using the
;;;3026   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;3027   		xYieldPending = pdTRUE;
00002c  2101              MOVS     r1,#1
00002e  61e9              STR      r1,[r5,#0x1c]  ; xYieldPending
;;;3028   	}
;;;3029   	else
;;;3030   	{
;;;3031   		xReturn = pdFALSE;
;;;3032   	}
;;;3033   
;;;3034   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;3035   	{
;;;3036   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;3037   		might be set to the blocked task's time out time.  If the task is
;;;3038   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;3039   		normally left unchanged, because it is automatically reset to a new
;;;3040   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;3041   		tickless idling is used it might be more important to enter sleep mode
;;;3042   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;3043   		ensure it is updated at the earliest possible time. */
;;;3044   		prvResetNextTaskUnblockTime();
;;;3045   	}
;;;3046   	#endif
;;;3047   
;;;3048   	return xReturn;
;;;3049   }
000030  bd70              POP      {r4-r6,pc}
                  |L52.50|
000032  1d20              ADDS     r0,r4,#4              ;3008
000034  f7fffffe          BL       uxListRemove
000038  6ae0              LDR      r0,[r4,#0x2c]         ;3009
00003a  6929              LDR      r1,[r5,#0x10]         ;3009  ; uxTopReadyPriority
00003c  4288              CMP      r0,r1                 ;3009
00003e  d900              BLS      |L52.66|
000040  6128              STR      r0,[r5,#0x10]         ;3009  ; uxTopReadyPriority
                  |L52.66|
000042  2114              MOVS     r1,#0x14              ;3009
000044  4348              MULS     r0,r1,r0              ;3009
000046  4906              LDR      r1,|L52.96|
000048  1840              ADDS     r0,r0,r1              ;3009
00004a  1d21              ADDS     r1,r4,#4              ;3009
00004c  f7fffffe          BL       vListInsertEnd
000050  e7e6              B        |L52.32|
                  |L52.82|
000052  2000              MOVS     r0,#0                 ;3031
000054  bd70              POP      {r4-r6,pc}
;;;3050   /*-----------------------------------------------------------*/
                          ENDP

000056  0000              DCW      0x0000
                  |L52.88|
                          DCD      ||.data||
                  |L52.92|
                          DCD      NoInit+0x118
                  |L52.96|
                          DCD      NoInit

                          AREA ||i.xTaskResumeAll||, CODE, READONLY, ALIGN=2

                  xTaskResumeAll PROC
;;;2104   
;;;2105   BaseType_t xTaskResumeAll( void )
000000  b5f8              PUSH     {r3-r7,lr}
;;;2106   {
;;;2107   TCB_t *pxTCB = NULL;
000002  2400              MOVS     r4,#0
;;;2108   BaseType_t xAlreadyYielded = pdFALSE;
000004  2700              MOVS     r7,#0
;;;2109   
;;;2110   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2111   	previous call to vTaskSuspendAll(). */
;;;2112   	configASSERT( uxSchedulerSuspended );
;;;2113   
;;;2114   	/* It is possible that an ISR caused a task to be removed from an event
;;;2115   	list while the scheduler was suspended.  If this was the case then the
;;;2116   	removed task will have been added to the xPendingReadyList.  Once the
;;;2117   	scheduler has been resumed it is safe to move all the pending ready
;;;2118   	tasks from this list into their appropriate ready list. */
;;;2119   	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;2120   	{
;;;2121   		--uxSchedulerSuspended;
00000a  4d23              LDR      r5,|L53.152|
00000c  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00000e  1e40              SUBS     r0,r0,#1
000010  6328              STR      r0,[r5,#0x30]  ; uxSchedulerSuspended
;;;2122   
;;;2123   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000012  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000014  2800              CMP      r0,#0
000016  d13a              BNE      |L53.142|
;;;2124   		{
;;;2125   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000018  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
00001a  2800              CMP      r0,#0
00001c  d037              BEQ      |L53.142|
;;;2126   			{
;;;2127   				/* Move any readied tasks from the pending list into the
;;;2128   				appropriate ready list. */
;;;2129   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
;;;2130   				{
;;;2131   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
;;;2132   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2133   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;2134   					prvAddTaskToReadyList( pxTCB );
;;;2135   
;;;2136   					/* If the moved task has a priority higher than the current
;;;2137   					task then a yield must be performed. */
;;;2138   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;2139   					{
;;;2140   						xYieldPending = pdTRUE;
00001e  2601              MOVS     r6,#1
000020  e01a              B        |L53.88|
                  |L53.34|
000022  68c0              LDR      r0,[r0,#0xc]          ;2131  ; xPendingReadyList
000024  68c4              LDR      r4,[r0,#0xc]          ;2131
000026  4620              MOV      r0,r4                 ;2132
000028  3018              ADDS     r0,r0,#0x18           ;2132
00002a  f7fffffe          BL       uxListRemove
00002e  1d20              ADDS     r0,r4,#4              ;2133
000030  f7fffffe          BL       uxListRemove
000034  6ae0              LDR      r0,[r4,#0x2c]         ;2134
000036  6929              LDR      r1,[r5,#0x10]         ;2134  ; uxTopReadyPriority
000038  4288              CMP      r0,r1                 ;2134
00003a  d900              BLS      |L53.62|
00003c  6128              STR      r0,[r5,#0x10]         ;2134  ; uxTopReadyPriority
                  |L53.62|
00003e  2114              MOVS     r1,#0x14              ;2134
000040  4348              MULS     r0,r1,r0              ;2134
000042  4916              LDR      r1,|L53.156|
000044  1840              ADDS     r0,r0,r1              ;2134
000046  1d21              ADDS     r1,r4,#4              ;2134
000048  f7fffffe          BL       vListInsertEnd
00004c  6ae0              LDR      r0,[r4,#0x2c]         ;2138
00004e  6829              LDR      r1,[r5,#0]            ;2138  ; pxCurrentTCB
000050  6ac9              LDR      r1,[r1,#0x2c]         ;2138
000052  4288              CMP      r0,r1                 ;2138
000054  d300              BCC      |L53.88|
000056  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L53.88|
000058  4811              LDR      r0,|L53.160|
00005a  6801              LDR      r1,[r0,#0]            ;2129  ; xPendingReadyList
00005c  2900              CMP      r1,#0                 ;2129
00005e  d1e0              BNE      |L53.34|
;;;2141   					}
;;;2142   					else
;;;2143   					{
;;;2144   						mtCOVERAGE_TEST_MARKER();
;;;2145   					}
;;;2146   				}
;;;2147   
;;;2148   				if( pxTCB != NULL )
000060  2c00              CMP      r4,#0
000062  d001              BEQ      |L53.104|
;;;2149   				{
;;;2150   					/* A task was unblocked while the scheduler was suspended,
;;;2151   					which may have prevented the next unblock time from being
;;;2152   					re-calculated, in which case re-calculate it now.  Mainly
;;;2153   					important for low power tickless implementations, where
;;;2154   					this can prevent an unnecessary exit from low power
;;;2155   					state. */
;;;2156   					prvResetNextTaskUnblockTime();
000064  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L53.104|
;;;2157   				}
;;;2158   
;;;2159   				/* If any ticks occurred while the scheduler was suspended then
;;;2160   				they should be processed now.  This ensures the tick count does
;;;2161   				not	slip, and that any delayed tasks are resumed at the correct
;;;2162   				time. */
;;;2163   				{
;;;2164   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
000068  69ac              LDR      r4,[r5,#0x18]  ; uxPendedTicks
;;;2165   
;;;2166   					if( uxPendedCounts > ( UBaseType_t ) 0U )
00006a  2c00              CMP      r4,#0
00006c  d009              BEQ      |L53.130|
                  |L53.110|
;;;2167   					{
;;;2168   						do
;;;2169   						{
;;;2170   							if( xTaskIncrementTick() != pdFALSE )
00006e  f7fffffe          BL       xTaskIncrementTick
000072  2800              CMP      r0,#0
000074  d000              BEQ      |L53.120|
;;;2171   							{
;;;2172   								xYieldPending = pdTRUE;
000076  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L53.120|
;;;2173   							}
;;;2174   							else
;;;2175   							{
;;;2176   								mtCOVERAGE_TEST_MARKER();
;;;2177   							}
;;;2178   							--uxPendedCounts;
000078  1e64              SUBS     r4,r4,#1
;;;2179   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
00007a  2c00              CMP      r4,#0
00007c  d1f7              BNE      |L53.110|
;;;2180   
;;;2181   						uxPendedTicks = 0;
00007e  2000              MOVS     r0,#0
000080  61a8              STR      r0,[r5,#0x18]  ; uxPendedTicks
                  |L53.130|
;;;2182   					}
;;;2183   					else
;;;2184   					{
;;;2185   						mtCOVERAGE_TEST_MARKER();
;;;2186   					}
;;;2187   				}
;;;2188   
;;;2189   				if( xYieldPending != pdFALSE )
000082  69e8              LDR      r0,[r5,#0x1c]  ; xYieldPending
000084  2800              CMP      r0,#0
000086  d002              BEQ      |L53.142|
;;;2190   				{
;;;2191   					#if( configUSE_PREEMPTION != 0 )
;;;2192   					{
;;;2193   						xAlreadyYielded = pdTRUE;
000088  2701              MOVS     r7,#1
;;;2194   					}
;;;2195   					#endif
;;;2196   					taskYIELD_IF_USING_PREEMPTION();
00008a  f7fffffe          BL       vPortYield
                  |L53.142|
;;;2197   				}
;;;2198   				else
;;;2199   				{
;;;2200   					mtCOVERAGE_TEST_MARKER();
;;;2201   				}
;;;2202   			}
;;;2203   		}
;;;2204   		else
;;;2205   		{
;;;2206   			mtCOVERAGE_TEST_MARKER();
;;;2207   		}
;;;2208   	}
;;;2209   	taskEXIT_CRITICAL();
00008e  f7fffffe          BL       vPortExitCritical
;;;2210   
;;;2211   	return xAlreadyYielded;
000092  4638              MOV      r0,r7
;;;2212   }
000094  bdf8              POP      {r3-r7,pc}
;;;2213   /*-----------------------------------------------------------*/
                          ENDP

000096  0000              DCW      0x0000
                  |L53.152|
                          DCD      ||.data||
                  |L53.156|
                          DCD      NoInit
                  |L53.160|
                          DCD      NoInit+0x118

                          AREA ||i.xTaskResumeFromISR||, CODE, READONLY, ALIGN=2

                  xTaskResumeFromISR PROC
;;;1830   
;;;1831   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000000  b5f8              PUSH     {r3-r7,lr}
;;;1832   	{
000002  4604              MOV      r4,r0
;;;1833   	BaseType_t xYieldRequired = pdFALSE;
000004  2500              MOVS     r5,#0
;;;1834   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
;;;1835   	UBaseType_t uxSavedInterruptStatus;
;;;1836   
;;;1837   		configASSERT( xTaskToResume );
;;;1838   
;;;1839   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1840   		maximum	system call (or maximum API call) interrupt priority.
;;;1841   		Interrupts that are	above the maximum system call priority are keep
;;;1842   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1843   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1844   		is defined in FreeRTOSConfig.h then
;;;1845   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1846   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1847   		been assigned a priority above the configured maximum system call
;;;1848   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1849   		from interrupts	that have been assigned a priority at or (logically)
;;;1850   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1851   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1852   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1853   		provided on the following link:
;;;1854   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1855   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
;;;1856   
;;;1857   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
000006  f7fffffe          BL       ulSetInterruptMaskFromISR
00000a  4607              MOV      r7,r0
;;;1858   		{
;;;1859   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       prvTaskIsTaskSuspended
000012  2800              CMP      r0,#0
000014  d008              BEQ      |L54.40|
;;;1860   			{
;;;1861   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1862   
;;;1863   				/* Check the ready lists can be accessed. */
;;;1864   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000016  4e12              LDR      r6,|L54.96|
000018  6b30              LDR      r0,[r6,#0x30]  ; uxSchedulerSuspended
00001a  2800              CMP      r0,#0
00001c  d009              BEQ      |L54.50|
;;;1865   				{
;;;1866   					/* Ready lists can be accessed so move the task from the
;;;1867   					suspended list to the ready list directly. */
;;;1868   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1869   					{
;;;1870   						xYieldRequired = pdTRUE;
;;;1871   					}
;;;1872   					else
;;;1873   					{
;;;1874   						mtCOVERAGE_TEST_MARKER();
;;;1875   					}
;;;1876   
;;;1877   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;1878   					prvAddTaskToReadyList( pxTCB );
;;;1879   				}
;;;1880   				else
;;;1881   				{
;;;1882   					/* The delayed or ready lists cannot be accessed so the task
;;;1883   					is held in the pending ready list until the scheduler is
;;;1884   					unsuspended. */
;;;1885   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
00001e  4621              MOV      r1,r4
000020  3118              ADDS     r1,r1,#0x18
000022  4810              LDR      r0,|L54.100|
000024  f7fffffe          BL       vListInsertEnd
                  |L54.40|
;;;1886   				}
;;;1887   			}
;;;1888   			else
;;;1889   			{
;;;1890   				mtCOVERAGE_TEST_MARKER();
;;;1891   			}
;;;1892   		}
;;;1893   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       vClearInterruptMaskFromISR
;;;1894   
;;;1895   		return xYieldRequired;
00002e  4628              MOV      r0,r5
;;;1896   	}
000030  bdf8              POP      {r3-r7,pc}
                  |L54.50|
000032  6ae0              LDR      r0,[r4,#0x2c]         ;1868
000034  6831              LDR      r1,[r6,#0]            ;1868  ; pxCurrentTCB
000036  6ac9              LDR      r1,[r1,#0x2c]         ;1868
000038  4288              CMP      r0,r1                 ;1868
00003a  d300              BCC      |L54.62|
00003c  2501              MOVS     r5,#1                 ;1870
                  |L54.62|
00003e  1d20              ADDS     r0,r4,#4              ;1877
000040  f7fffffe          BL       uxListRemove
000044  6ae0              LDR      r0,[r4,#0x2c]         ;1878
000046  6931              LDR      r1,[r6,#0x10]         ;1878  ; uxTopReadyPriority
000048  4288              CMP      r0,r1                 ;1878
00004a  d900              BLS      |L54.78|
00004c  6130              STR      r0,[r6,#0x10]         ;1878  ; uxTopReadyPriority
                  |L54.78|
00004e  2114              MOVS     r1,#0x14              ;1878
000050  4348              MULS     r0,r1,r0              ;1878
000052  4905              LDR      r1,|L54.104|
000054  1840              ADDS     r0,r0,r1              ;1878
000056  1d21              ADDS     r1,r4,#4              ;1878
000058  f7fffffe          BL       vListInsertEnd
00005c  e7e4              B        |L54.40|
;;;1897   
                          ENDP

00005e  0000              DCW      0x0000
                  |L54.96|
                          DCD      ||.data||
                  |L54.100|
                          DCD      NoInit+0x118
                  |L54.104|
                          DCD      NoInit

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000

                          AREA NoInit, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        240
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L325.16|
00000e  461d              MOV      r5,r3
                  |L325.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP


;*** Start embedded assembler ***

#line 1 "Common\\CMSIS-FreeRTOS\\10.0.1\\Source\\tasks.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_tasks_c_f31043e3____REV16|
#line 492 "C:\\Users\\bbb\\AppData\\Local\\Arm\\Packs\\ARM\\CMSIS\\5.6.0\\CMSIS\\Core\\Include\\cmsis_armcc.h"
|__asm___7_tasks_c_f31043e3____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_tasks_c_f31043e3____REVSH|
#line 507
|__asm___7_tasks_c_f31043e3____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
